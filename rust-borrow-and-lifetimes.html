<!DOCTYPE html>
<html lang="zh">

<head>
    <meta charset="utf-8">
  <meta http-equiv="Content-Type" content="text/html" charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />


  <title>【译】Rust 借用和生命周期</title>

  <meta name="description" content="博主一个爱好开源技术的人，对 Python 比较熟悉，也喜欢用 Python 捣腾一些东西，本博主要分享一些开源技术，其中包括但不限于 Linux/Python/Vim。" />

  <meta name="HandheldFriendly" content="True" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="referrer" content="origin" />
  <meta name="generator" content="Pelican" />

  <link rel="shortcut icon" href="/favicon.ico" type="image/vnd.microsoft.icon" />
  <link rel="icon" href="/favicon.ico" type="image/vnd.microsoft.icon" />

<link href="https://www.linuxzen.com/rust-borrow-and-lifetimes.html" rel="canonical" />
  <!-- Feed -->
      <link href="/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="cold's world Full Atom Feed" />

  <link href="https://www.linuxzen.com/theme/css/style.css" type="text/css" rel="stylesheet" />

  <!-- Code highlight color scheme -->
      <link href="https://www.linuxzen.com/theme/css/code_blocks/tomorrow.css" rel="stylesheet">

    <!-- CSS specified by the user -->


    <link href="https://www.linuxzen.com/static/css/wide.css" type="text/css" rel="stylesheet" />

  <!-- Custom fonts -->
  <link href='https://fonts.googleapis.cnpmjs.org/css?family=Montserrat:400,300' rel='stylesheet' type='text/css' />
  <link href="https://fonts.googleapis.cnpmjs.org/css?family=Lato" rel="stylesheet" type="text/css" />

  <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
  <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
  <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
  <![endif]-->



    <meta name="description" content="译者注：这是我学习 Rust 生命周期对我最有帮助的文章之一，故翻译了一下。 原文链接：Rust Borrow and Lifetimes。 Rust 是一门处于往 1.0 活跃开 …">

    <meta name="author" content="cold">

    <meta name="tags" content="Rust">
    <meta name="tags" content="借用">
    <meta name="tags" content="生命周期">




<!-- Open Graph -->
<meta property="og:site_name" content="cold's world"/>
<meta property="og:title" content="【译】Rust 借用和生命周期"/>
<meta property="og:description" content="译者注：这是我学习 Rust 生命周期对我最有帮助的文章之一，故翻译了一下。 原文链接：Rust Borrow and Lifetimes。 Rust 是一门处于往 1.0 活跃开 …"/>
<meta property="og:locale" content="en_US"/>
<meta property="og:url" content="https://www.linuxzen.com/rust-borrow-and-lifetimes.html"/>
<meta property="og:type" content="article"/>
<meta property="article:published_time" content="2020-08-26 00:00:00+08:00"/>
<meta property="article:modified_time" content=""/>
<meta property="article:author" content="https://www.linuxzen.com/author/cold.html">
<meta property="article:section" content="Rust"/>
<meta property="article:tag" content="Rust"/>
<meta property="article:tag" content="借用"/>
<meta property="article:tag" content="生命周期"/>
<meta property="og:image" content="https://www.linuxzen.com/theme/images/post-bg.jpg">

<!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@grayking_w">
    <meta name="twitter:title" content="【译】Rust 借用和生命周期">
    <meta name="twitter:url" content="https://www.linuxzen.com/rust-borrow-and-lifetimes.html">

        <meta name="twitter:image:src" content="https://www.linuxzen.com/theme/images/post-bg.jpg">

      <meta name="twitter:description" content="译者注：这是我学习 Rust 生命周期对我最有帮助的文章之一，故翻译了一下。 原文链接：Rust Borrow and Lifetimes。 Rust 是一门处于往 1.0 活跃开 …">

<script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "Article",
  "name": "【译】Rust 借用和生命周期",
  "headline": "【译】Rust 借用和生命周期",
  "datePublished": "2020-08-26 00:00:00+08:00",
  "dateModified": "",
  "author": {
    "@type": "Person",
    "name": "cold",
    "url": "https://www.linuxzen.com/author/cold.html"
  },
  "image": "https://www.linuxzen.com/theme/images/post-bg.jpg",
  "url": "https://www.linuxzen.com/rust-borrow-and-lifetimes.html",
  "description": "译者注：这是我学习 Rust 生命周期对我最有帮助的文章之一，故翻译了一下。 原文链接：Rust Borrow and Lifetimes。 Rust 是一门处于往 1.0 活跃开 …"
}
</script>
</head>
<!-- TODO : Body class -->
<body class="home-template">

<nav id="menu">
  <a class="close-button">Close</a>
  <div class="nav-wrapper">
    <p class="nav-label">Menu</p>
    <ul>
          <li><a href="/notes/" role="presentation">Zettelkasten</a></li>

                  <li role="presentation"><a href="https://www.linuxzen.com/category/git.html">Git</a></li>
                  <li role="presentation"><a href="https://www.linuxzen.com/category/go.html">Go</a></li>
                  <li role="presentation"><a href="https://www.linuxzen.com/category/linux.html">Linux</a></li>
                  <li role="presentation"><a href="https://www.linuxzen.com/category/other.html">Other</a></li>
                  <li role="presentation"><a href="https://www.linuxzen.com/category/pyqt.html">PyQt</a></li>
                  <li role="presentation"><a href="https://www.linuxzen.com/category/python.html">Python</a></li>
                  <li class="nav-rust active" role="presentation"><a href="https://www.linuxzen.com/category/rust.html">Rust</a></li>
                  <li role="presentation"><a href="https://www.linuxzen.com/category/tech.html">Tech</a></li>
                  <li role="presentation"><a href="https://www.linuxzen.com/category/vim.html">Vim</a></li>

        <li class="nav-rss"><a href="/feeds/all.atom.xml"><i class="ic ic-rss"></i> Subscribe</a></li>
    </ul>
  </div>
</nav>
    <!-- Progressbar -->
    <div class="progress-container">
        <span class="progress-bar"></span>
    </div>

    <!-- Page Header -->
    <!-- Set your background image for this header on the line below. -->
    <header id="post-header" >
      <div class="inner">
        <nav id="navigation">
            <span id="home-button" class="nav-button">
                <a class="home-button" href="https://www.linuxzen.com/" title="Home"><i class="ic ic-arrow-left"></i> Home</a>
            </span>
          <span id="menu-button" class="nav-button">
            <a class="menu-button"><i class="ic ic-menu"></i> Menu</a>
          </span>
        </nav>
        <h1 class="post-title">【译】Rust 借用和生命周期</h1>
        <!-- TODO : Proper class for headline -->
        <span class="post-meta">
                <a href="https://www.linuxzen.com/author/cold.html">Gray King</a>
            | <time datetime="Wed 26 August 2020">Wed 26 August 2020</time>
        </span>
        <!-- TODO : Modified check -->
      </div>
    </header>

  <section id="wrapper">
    <a class="hidden-close"></a>

    <!-- Post content -->
    <main class="content" role="main">
        <article class="post">
        <div class="inner">
            <section class="post-content">
                <blockquote>
<p>译者注：这是我学习 Rust 生命周期对我最有帮助的文章之一，故翻译了一下。</p>
</blockquote>
<p>原文链接：<a href="http://arthurtw.github.io/2014/11/30/rust-borrow-lifetimes.html">Rust Borrow and Lifetimes</a>。</p>
<p>Rust 是一门处于往 1.0 活跃开发的新语言（译注：1.0 早已发布，目前最新稳定版本 <a href="https://github.com/rust-lang/rust/releases/tag/1.42.0">1.42</a>）。
我必须再写一篇关于我为什么觉得 Rust 很棒的新博客，但是今天我将关注在它的借用（borrow）
和生命周期（lifetimes）系统，这也是常常让包括我在内的 Rust 新手陷入困境的地方。这篇文章假设
你基本了解 Rust，如果还没推荐你先阅读<a href="http://doc.rust-lang.org/guide.html">指南</a>和<a href="http://doc.rust-lang.org/guide-pointers.html">指针指南</a>。</p>
<h2 id="资源所有权和借用">资源所有权和借用</h2>
<p>Rust 通过一个难缠的（sophisticated）借用系统在不用 GC 的情况下达到内存安全。对于任何资源
（栈内存、堆内存、文件句柄等），他们都对应一个唯一的所有者（owner）在需要的情况下处理资源回收。
你可以通过 <code>&amp;</code> 或者 <code>&amp;mut</code> 创建一个新的绑定指向该资源，这被称之为借用或可变借用。编译器确保
所有的所有者（owners）和借用者（borrowers）行为正确。</p>
<h2 id="拷贝和转移-copy-and-move">拷贝和转移（Copy and move）</h2>
<p>在我们开始进入借用系统之前，我们需要知道 Rust 如何处理拷贝和转移。这个 <a href="https://stackoverflow.com/questions/24253344/is-it-possible-to-make-a-type-only-movable-and-not-copyable/24253573#24253573">StackOverflow 答案</a>非常值得一读。
基本上，在赋值和函数调用上：</p>
<ol>
<li>如果值是可拷贝的（copyable）（仅涉及原始（primitive）类型，不涉及如内存或文件句柄的资源），编译器默认进行拷贝。</li>
<li>其他情况，编译器转移（moves）所有权（ownership）并使原来的绑定无效。</li>
</ol>
<p>简而言之，POD（Plan Old Data） =&gt; 拷贝，Non-POD（线性类型（linear types））=&gt; 转移。</p>
<p>以下是一些额外的注释供你参考：</p>
<ul>
<li>Rust 拷贝像 C。每一个按值（by-value）使用一个值都是字节拷贝（通过 <code>memcpy</code> 浅拷贝），而不是语义上的拷贝或克隆。</li>
<li>如果想要让一个 POD 结构体变成不可拷贝的，你可以使用一个 <a href="http://doc.rust-lang.org/std/kinds/marker/struct.NoCopy.html">NoCopy</a> 标记，或者实现 <a href="http://doc.rust-lang.org/std/ops/trait.Drop.html">Drop</a> 特性（trait）。</li>
</ul>
<p>转移之后，所有权就转移到了下一个所有者那。</p>
<h2 id="资源回收">资源回收</h2>
<p>Rust 会在任何资源的所有权消失后立刻释放该资源，就这些，当：</p>
<ol>
<li>所有者超出作用域，或</li>
<li>正在持有的所有者改变绑定（原始绑定变成 void）。</li>
</ol>
<h2 id="所有者和借用者的权限-privileges-和限制">所有者和借用者的权限（privileges）和限制</h2>
<p>这一节基于 <a href="http://doc.rust-lang.org/guide.html">Rust Guide</a> 在权限（privileges）一部分提到拷贝和转移。</p>
<p>所有者有一些权限。它可以：</p>
<ol>
<li>控制资源回收。</li>
<li>借出资源，不可变的（可多次借用）或可变的（只能独占），和</li>
<li>交出所有权（通过转移）</li>
</ol>
<p>同时所有者也存在一些限制：</p>
<ol>
<li>
<p>不可变借用期间，所有者不能</p>
<p>a. 改变资源，或者</p>
<p>b. 以可变的方式借出资源。</p>
</li>
<li>
<p>可变借用期间所有者不能</p>
<p>a. 访问该资源，或者</p>
<p>b. 再次借出该资源。</p>
</li>
</ol>
<p>借用者同时也有一些权限。除了访问或者更改借用的资源外，借用者也可以进一步借出（share the borrow）：</p>
<ol>
<li>不可变借用者可以借出（拷贝）不可变借用（译注：再次以不可变借用借出）</li>
<li>可变借用者可以交出（转移）可变借用。（可变引用默认使用转移。）</li>
</ol>
<h2 id="代码示例">代码示例</h2>
<p>关于借用我们已经聊的够多了，让我们一起来看一些代码吧（你可以通过 <a href="https://play.rust-lang.org">https://play.rust-lang.org</a> 运行这些 Rust 代码。）
在下面所有的例子中，我们将使用不可拷贝的 <code>struct Foo</code> ，因为它包含了一个装箱（boxed）（堆分配）值。
使用不可拷贝资源可以限制相关操作，让我们更好的学习。</p>
<p>对于每一个代码示例，我们还提供了一个“作用域图表”（scope chart）来展示所有者和借用者的作用域。
图表第一行的大括号和代码中的大括号一一对应。</p>
<h3 id="所有者在可变借用期间不能访问资源">所有者在可变借用期间不能访问资源</h3>
<p>如果我们将代码中的 <code>println!</code> 解除注释，代码将不能编译：</p>
<div class="highlight"><pre><span></span><code><span class="k">struct</span> <span class="nc">Foo</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">f</span>: <span class="nb">Box</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">f</span>: <span class="nc">box</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">};</span>
<span class="w">    </span><span class="c1">// mutable borrow</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// error: cannot borrow `a.f` as immutable because `a` is also borrowed as mutable</span>
<span class="w">    </span><span class="c1">// println!(&quot;{}&quot;, a.f);</span>
<span class="p">}</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code>           { a x * }
   owner a   |_____|
borrower x     |___| x = &amp;mut a
access a.f       |   error
</code></pre></div>

<p>这违反了所有者限制 #2(a)。如果我们将 <code>let x = &amp;mut a;</code> 在一个嵌套的代码块里：借用
在 <code>println!</code> 之前结束，这段代码将能正常工作：</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">f</span>: <span class="nc">box</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">};</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// mutable borrow</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>
<span class="w">        </span><span class="c1">// mutable borrow ends here</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;{}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">f</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code>           { a { x } * }
   owner a   |_________|
borrower x       |_|     x = &amp;mut a
access a.f           |   OK
</code></pre></div>

<h3 id="借用者可以转移可变借用到一个新的借用者">借用者可以转移可变借用到一个新的借用者</h3>
<p>这段代码展示借用者的权限 #2: 可变借用 <code>x</code> 可以将所有权转移可变借用到一个新的借用者 <code>y</code> 。</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">f</span>: <span class="nc">box</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">};</span>
<span class="w">    </span><span class="c1">// mutable borrow</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// move the mutable borrow to new borrower y</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// error: use of moved value: `x.f`</span>
<span class="w">    </span><span class="c1">// println!(&quot;{}&quot;, x.f);</span>
<span class="p">}</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code>           { a x y * }
   owner a   |_______|
borrower x     |_|     x = &amp;mut a
borrower y       |___| y = x
access x.f         |   error
</code></pre></div>

<p>转移之后，原始的借用者 <code>x</code> 不再能访问借用的资源。</p>
<h2 id="借用作用域-borrow-scope">借用作用域（Borrow scope）</h2>
<p>如果我们开始传递引用（ <code>&amp;</code> 和 =&amp;mut=）事情就开始变得有趣，同时也是 Rust 新手们开始困惑的地方。</p>
<h3 id="生命周期-lifetime">生命周期（Lifetime）</h3>
<p>在整个借用过程中，知道借用者的借用什么时候开始和结束非常重要。在<a href="http://doc.rust-lang.org/guide-lifetimes.html">生命周期指南</a>中是这样定义生命周期的：</p>
<blockquote>
<p>A lifetime is a static approximation of the span of execution during which the pointer is valid: it always corresponds to some expression or block within the program.</p>
</blockquote>
<!--quoteend-->

<blockquote>
<p>生命周期是指针有效范围的静态近似值：它始终对应程序中的某些表达式或代码块。</p>
</blockquote>
<p>然而，我更喜欢使用 <strong>借用作用域（borrow scope）</strong> 这个术语去描述借用生效的作用域。请注意它不同于上面生命周期的定义。
（我第一次见到这个术语是在一个 Rust <a href="https://github.com/rust-lang/rfcs/pull/431">RFC 讨论</a> 中，尽管我的定义可能会有所不同。）我会在稍后给出我为什么避免使用生命周期的原因。
现在我们先把生命周期放在一边。</p>
<h3 id="and-borrow">&amp; = borrow</h3>
<p>一些关于借用的事情：</p>
<p>首先，只需要记住 <code>&amp;</code> = 借用， <code>&amp;mut</code> = 可变借用。任何地方你看到一个 <code>&amp;</code> ，那就是一个借用。</p>
<p>其次，当一个 <code>&amp;</code> 出现在任何结构体中（在它的字段中）或者函数/闭包（返回值或者捕获的引用），结构体/函数/闭包就是一个借用者，
并且应用所有的借用规则。</p>
<p>再次，对于每一个借用，都存在一个所有者和一个或多个借用者。</p>
<h3 id="扩展借用作用域">扩展借用作用域</h3>
<p>一些关于借用作用域的事情：</p>
<p>首先，一个借用作用域：</p>
<ul>
<li>是一个借用生效的范围，并且</li>
<li>不一定是借用者的词法作用域，因为借用者可以扩展借用作用域（参见下面）。</li>
</ul>
<p>其次，借用者在赋值或者函数调用中可以通过拷贝（不可变借用）或者转移（可变借用）扩展借用作用域。
接收者（receiver）（可以是新的绑定、结构体、函数或者闭包）变成新的借用者。</p>
<p>再次，借用作用域是所有借用者作用域的并集，并且被借用的资源必须在整个借用作用域里有效。</p>
<h3 id="借用公式">借用公式</h3>
<p>根据最后一点，我们得到一个借用公式：</p>
<blockquote>
<p>资源作用域 &gt;= 借用作用域 = 所有借用者作用域的并集。</p>
</blockquote>
<h3 id="代码示例">代码示例</h3>
<p>让我们看一些扩展作用域的代码示例。结构体 <code>struct Foo</code> 和前面的一样：</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">f</span>: <span class="nc">box</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">};</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">y</span>: <span class="kp">&amp;</span><span class="nc">Foo</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="kc">false</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// borrow</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">a</span><span class="p">;</span>
<span class="w">        </span><span class="c1">// share the borrow with new borrower y, hence extend the borrow scope</span>
<span class="w">        </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">// error: cannot assign to `a.f` because it is borrowed</span>
<span class="w">    </span><span class="c1">// a.f = box 1;</span>
<span class="p">}</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code>             { a { x y } * }
  resource a   |___________|
  borrower x       |___|     x = &amp;a
  borrower y         |_____| y = x
borrow scope       |=======|
  mutate a.f             |   error
</code></pre></div>

<p>即使借用发生在 <code>if</code> 代码块之内并且借用者 <code>x</code> 在 <code>if</code> 代码块之后超出作用域，它已经通过赋值 <code>y=x;</code> 扩展了借用作用域，
所以存在两个借用者： <code>x</code> 和 <code>y</code> 。根据借用公式：借用作用域是借用者 <code>x</code> 和借用者 <code>y</code> 作用域的并集：
范围开始第一次借用于 <code>let x = &amp;a;</code> 直到 <code>main</code> 代码块的结尾。（注意绑定 <code>y</code> 在 <code>y=x;</code> 之前不是借用者。）</p>
<p>你可能注意到了由于条件永远是 false <code>if</code> 代码块永远不会执行，但是编译器始终拒绝资源所有者 <code>a</code> 去访问
它的资源。这是因为所有的借用检查发生在编译期，这样程序运行时就不需要做任何事情。</p>
<h2 id="借用多个资源">借用多个资源</h2>
<p>目前为止我们只关注借用单个资源。借用者可以借用多个资源吗？当然！比如一个函数可以接受两个引用然后
基于一些情况返回其中一个，e.g. 其中字段值比较大的那一个。</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span> <span class="nf">max</span><span class="p">(</span><span class="n">x</span>: <span class="kp">&amp;</span><span class="nc">Foo</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="kp">&amp;</span><span class="nc">Foo</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">Foo</span>
</code></pre></div>

<p><code>max</code> 函数返回一个 <code>&amp;</code> 指针，因此它是一个借用者。返回的结果可以是输入参数的任意一个，所以它借用了
两鞥额资源。</p>
<h3 id="命名借用作用域-named-borrow-scope">命名借用作用域（Named borrow scope）</h3>
<p>当存在多个 <code>&amp;</code> 指针作为输入，我们需要使用 <strong>命名生命周期（named lifetimes）</strong> 指定它们之间的关系，
参见 <a href="http://doc.rust-lang.org/guide-lifetimes.html#named-lifetimes">Lifetimes Guide</a>。但现在，让我们叫它们 <strong>命名借用作用域（named borrow scopes）</strong> 。</p>
<p>上面的代码没有使用 <strong>命名生命周期</strong> 指定它们之间的关系是不会通过编译器的，i.e. 哪些借用者 <strong>分组（grouped）</strong>
到哪个借用作用域。下面的实现是合法的：</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span> <span class="nf">max</span><span class="o">&lt;&#39;</span><span class="na">a</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span>: <span class="kp">&amp;</span><span class="o">&#39;</span><span class="na">a</span> <span class="nc">Foo</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="kp">&amp;</span><span class="o">&#39;</span><span class="na">a</span> <span class="nc">Foo</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="o">&#39;</span><span class="na">a</span> <span class="nc">Foo</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="n">f</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">y</span><span class="p">.</span><span class="n">f</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="kr">All</span><span class="w"> </span><span class="n">resources</span><span class="w"> </span><span class="kr">and</span><span class="w"> </span><span class="n">borrowers</span><span class="w"> </span><span class="n">are</span><span class="w"> </span><span class="n">grouped</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="n">borrow</span><span class="w"> </span><span class="n">scope</span><span class="w"> </span><span class="s">&#39;a.)</span>
<span class="s">                  max( {   } )</span>
<span class="s">    resource *x &lt;--------------&gt;</span>
<span class="s">    resource *y &lt;--------------&gt;</span>
<span class="s">borrow scope &#39;</span><span class="n">a</span><span class="w"> </span><span class="o">&lt;==============&gt;</span>
<span class="w">     </span><span class="n">borrower</span><span class="w"> </span><span class="n">x</span><span class="w">        </span><span class="o">|</span><span class="n">___</span><span class="o">|</span>
<span class="w">     </span><span class="n">borrower</span><span class="w"> </span><span class="n">y</span><span class="w">        </span><span class="o">|</span><span class="n">___</span><span class="o">|</span>
<span class="w">   </span><span class="kr">return</span><span class="w"> </span><span class="n">value</span><span class="w">          </span><span class="o">|</span><span class="n">___</span><span class="o">|</span><span class="w">   </span><span class="n">pass</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">caller</span>
</code></pre></div>

<p>在这个函数中，我们有一个借用作用域 <code>'a</code> 和三个借用者：两个输入参数和函数返回结果。
前面提到的借用公式依然生效，但是现在每个被借用的资源必须满足公式。参见下面的例子：</p>
<h3 id="代码示例">代码示例</h3>
<p>在接下来的代码中，我们来使用上面的 <code>max</code> 函数在 <code>a</code> 和 <code>b</code> 之间选择一个更大 <code>Foo</code> ：</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">f</span>: <span class="nc">box</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">};</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">y</span>: <span class="kp">&amp;</span><span class="nc">Foo</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="kc">false</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">f</span>: <span class="nc">box</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">};</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">max</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
<span class="w">        </span><span class="c1">// error: `b` does not live long enough</span>
<span class="w">        </span><span class="c1">// y = x;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code>              { a { b x (  ) y } }
   resource a   |________________| pass
   resource b       |__________|   fail
 borrow scope         |==========|
temp borrower            |_|       &amp;a
temp borrower            |_|       &amp;b
   borrower x         |________|   x = max(&amp;a, &amp;b)
   borrower y                |___| y = x
</code></pre></div>

<p>直到 <code>let x = max(&amp;a, &amp;b)</code> 都一些正常，因为 <code>&amp;a</code> 和 <code>&amp;b</code> 都是尽在表达式中有效的临时引用，
并且第三个借用 <code>x</code> 借用了两个资源（不管最终是 <code>a</code> 或 <code>b</code> ，对于借用检查器而言它都借用了）直到 <code>if</code>
块结束，所以借用作用域是从 <code>let x = max(&amp;a, &amp;b);</code> 到 <code>if</code> 块结尾。两个资源 <code>a</code> 和 <code>b</code> 在整个借用作用域
都有效,因此满足借用公式。</p>
<p>现在如果我们解除最后一个赋值 <code>y = x;</code> 的注释， <code>y</code> 变成第四个借用者，然后借用作用域被扩展到 <code>main</code>
块的结尾，导致资源 <code>b</code> 不能满足公式。</p>
<h2 id="结构体作为借用者">结构体作为借用者</h2>
<p>除了函数和闭包之外，一个结构体也可以通过其字段存储多个引用来借用多个资源。我们通过下面的一些例子
来看看借用公式如何生效的。我们来使用 <code>Link</code> 结构体来保存一个引用（不可变借用）：</p>
<div class="highlight"><pre><span></span><code><span class="k">struct</span> <span class="nc">Link</span><span class="o">&lt;&#39;</span><span class="na">a</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">link</span>: <span class="kp">&amp;</span><span class="o">&#39;</span><span class="na">a</span> <span class="nc">Foo</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="结构体借用多个资源">结构体借用多个资源</h3>
<p>即使只有一个字段，结构体 <code>Link</code> 也可以借用多个资源：</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">f</span>: <span class="nc">box</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">};</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Link</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">link</span>: <span class="kp">&amp;</span><span class="nc">a</span><span class="w"> </span><span class="p">};</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="kc">false</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">f</span>: <span class="nc">box</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">};</span>
<span class="w">        </span><span class="c1">// error: `b` does not live long enough</span>
<span class="w">        </span><span class="c1">// x.link = &amp;b;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code>             { a x { b * } }
  resource a   |___________| pass
  resource b         |___|   fail
borrow scope     |=========|
  borrower x     |_________| x.link = &amp;a
  borrower x           |___| x.link = &amp;b
</code></pre></div>

<p>在上面例子中，借用者 <code>x</code> 从所有者 <code>a</code> 借用资源，借用作用域到 <code>main</code> 块的结尾。So far so good。
如果我们解除最后一个赋值 <code>x.link = &amp;b;</code> 的注释， <code>x</code> 也尝试从所有者 <code>b</code> 借用资源，这会让资源 <code>b</code>
不能满足借用公式。</p>
<h3 id="没有返回值的函数扩展借用作用域">没有返回值的函数扩展借用作用域</h3>
<p>一个没有返回值的函数同样也可以通过输出参数能扩展借用作用域。例如，这个函数 <code>store_foo</code> 接受一个
<code>Link</code> 的可变引用，然后存储一个引用（不可变借用）到 <code>Foo</code> 里：</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span> <span class="nf">store_foo</span><span class="o">&lt;</span><span class="sc">&#39;a&#39;</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Link</span><span class="o">&lt;&#39;</span><span class="na">a</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="kp">&amp;</span><span class="o">&#39;</span><span class="na">a</span> <span class="nc">Foo</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">x</span><span class="p">.</span><span class="n">link</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">y</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>在接下来的代码中，被 <code>a</code> 所有的资源是被借用资源； <code>Link</code> 结构体被借用者 <code>x</code> 可变的引用着（i.e. <code>*x</code> 是借用者）；
借用作用域直到 <code>main</code> 块的结尾。</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">f</span>: <span class="nc">box</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">};</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">Link</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">link</span>: <span class="kp">&amp;</span><span class="nc">a</span><span class="w"> </span><span class="p">};</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="kc">false</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">f</span>: <span class="nc">box</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">};</span>
<span class="w">        </span><span class="c1">// store_foo(x, &amp;b);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code>             { a x { b * } }
  resource a   |___________| pass
  resource b         |___|   fail
borrow scope     |=========|
 borrower *x     |_________| x.link = &amp;a
 borrower *x           |___| x.link = &amp;b
</code></pre></div>

<p>如果我们解除最后一个函数调用 <code>store_foo(x, &amp;b);</code> ,这个函数将会尝试将 <code>&amp;b</code> 存储到 <code>x.link</code> ，
将资源 <code>b</code> 作为另外一个被借用的资源，由于 <code>b</code> 的作用域没有覆盖整个借用作用域，导致不满足借用公式。</p>
<h3 id="多个借用作用域">多个借用作用域</h3>
<p>一个函数中可以存在多个借用作用域。例如：</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span> <span class="nf">superstore_foo</span><span class="o">&lt;&#39;</span><span class="na">a</span><span class="p">,</span><span class="w"> </span><span class="o">&#39;</span><span class="na">b</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Link</span><span class="o">&lt;&#39;</span><span class="na">a</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="kp">&amp;</span><span class="o">&#39;</span><span class="na">a</span> <span class="nc">Foo</span><span class="p">,</span>
<span class="w">                          </span><span class="n">x2</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Link</span><span class="o">&lt;&#39;</span><span class="na">b</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">y2</span>: <span class="kp">&amp;</span><span class="o">&#39;</span><span class="na">b</span> <span class="nc">Foo</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">x</span><span class="p">.</span><span class="n">link</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">y</span><span class="p">;</span>
<span class="w">    </span><span class="n">x2</span><span class="p">.</span><span class="n">link</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">y2</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>这个的函数（可能不是特别有用）中，涉及两个不同的借用作用域。每个借用作用域都有它们自己的作用域公式要满足。</p>
<h2 id="为什么生命周期会造成困惑">为什么生命周期会造成困惑</h2>
<p>最后，我想解释一下为什么我认为 Rust 借用系统使用 <strong>生命周期</strong> 术语会造成困惑（同时避免在这片博文中使用它）。</p>
<p>当我们讨论借用时会涉及到不同类型的“生命周期”：</p>
<p>A. 资源所有者的生命周期（或者 被所有/被借用 资源
B. 被借用的生命周期，i.e. 从开始借用到最后返还
C. 每一个独立的借用者或被借用的指针的生命周期</p>
<p>当有人说“生命周期”，它可以指上面的任何一个。如果涉及多个资源和借用者就会变的更加困惑。
比如，在函数或者结构体生命中一个“命名的生命周期”指哪个？是 A、B 或者 C？</p>
<p>在我们的前一个 <code>max</code> 函数中：</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span> <span class="nf">max</span><span class="o">&lt;&#39;</span><span class="na">a</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span>: <span class="kp">&amp;</span><span class="o">&#39;</span><span class="na">a</span> <span class="nc">Foo</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="kp">&amp;</span><span class="o">&#39;</span><span class="na">a</span> <span class="nc">Foo</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="o">&#39;</span><span class="na">a</span> <span class="nc">Foo</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="n">f</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">y</span><span class="p">.</span><span class="n">f</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<p>生命周期 <code>'a</code> 的意义是什么？它不应该是 A，因为涉及两个资源并且他们有不同的生命周期。也不可能是 C，
因为有三个借用者： <code>x</code> 、 <code>y</code> 和函数的返回值，并且他们也都有不同的生命周期。它是 B 吗？可能。
但是整个借用作用域并不是一个具体的对象，它怎么能有一个“生命周期”呢？称它为生命周期就会造成困惑。</p>
<p>另一种说法是它意味着对被借用资源的最小生命周期要求。一定程度上是有道理的，
但是我们怎么称呼最小生命周期要求“生命周期”？</p>
<p>所有权/借用概念自身已经够复杂了。我会说：对术语“生命周期”的困惑对学习这个概念造成了更多的莫名其妙。</p>
<p>P.S. 使用上面定义的 A、B 和 C，借用公式变成：</p>
<blockquote>
<p>A &gt;= B = C_1,UC_2U...UC_n</p>
</blockquote>
<h2 id="学习-rust-是值得的">学习 Rust 是值得的！</h2>
<p>尽管借用和所有权可能让你花一些时间来掌握（to grok），但是是一个非常有趣的学习。Rust 尝试不用 GC
来实现内存安全，并且目前来看做的非常好。一些人说他们通过学习 Haskell 改变了他们编程的方式。
我认为Rust 同样也值得你学习。</p>
<p>希望这篇博文能提供一些帮助。</p>
            </section>

            <section class="post-info">
                <div class="post-share">
                    <a class="twitter" href="https://twitter.com/share?text=【译】Rust 借用和生命周期&amp;url=https://www.linuxzen.com/rust-borrow-and-lifetimes.html" onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
                    <i class="ic ic-twitter"></i><span class="hidden">Twitter</span>
                    </a>
                    <a class="facebook" href="https://www.facebook.com/sharer/sharer.php?u=https://www.linuxzen.com/rust-borrow-and-lifetimes.html" onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;">
                    <i class="ic ic-facebook"></i><span class="hidden">Facebook</span>
                    </a>
                    <a class="googleplus" href="https://plus.google.com/share?url=https://www.linuxzen.com/rust-borrow-and-lifetimes.html" onclick="window.open(this.href, 'google-plus-share', 'width=490,height=530');return false;">
                    <i class="ic ic-googleplus"></i><span class="hidden">Google+</span>
                    </a>
                    <div class="clear"></div>
                </div>

                <aside class="post-tags">
<a href="https://www.linuxzen.com/tag/rust.html">Rust</a><a href="https://www.linuxzen.com/tag/jie-yong.html">借用</a><a href="https://www.linuxzen.com/tag/sheng-ming-zhou-qi.html">生命周期</a>                </aside>

                <div class="clear"></div>

                <aside class="post-author">


                        <figure class="post-author-avatar">
                            <img src="https://s.gravatar.com/avatar/4d0bc04ed0e44ab750ba32b5224101d7?s=200" alt="Gray King" />
                        </figure>
                    <div class="post-author-bio">
                        <h4 class="post-author-name"><a href="https://www.linuxzen.com/author/cold.html">Gray King</a></h4>
                            <p class="post-author-about">纸上得来终觉浅，绝知此事要躬行</p>
                            <span class="post-author-location"><i class="ic ic-location"></i> Beijing</span>
                            <span class="post-author-website"><a href="https://github.com/coldnight"><i class="ic ic-link"></i> Website</a></span>
                        <!-- Social linkes in alphabet order. -->
                    </div>
                    <div class="clear"></div>
                </aside>

                </section>

                <script type="text/javascript">
                    var disqus = 'linuxzen';
                    var disqus_shortname = 'linuxzen';
                    var disqus_identifier = '/rust-borrow-and-lifetimes.html';
                    var disqus_url = 'https://www.linuxzen.com/rust-borrow-and-lifetimes.html';
                </script>
                <noscript>Please enable JavaScript to view the comments.</noscript>
                <section class="post-comments">
                        <a id="show-disqus" class="post-comments-activate" data-disqus-identifier="/rust-borrow-and-lifetimes.html" >Show Comments</a>
                    <div id="disqus_thread"></div>
                </section>

                <aside class="post-nav">
                    <div class="clear"></div>
                </aside>

            </div>
        </article>
    </main>
      <!-- TODO : Body class -->
    <div id="body-class" style="display: none;" class=""></div>

    <footer id="footer">
      <div class="inner">
        <section class="credits">


          <span class="credits-theme">Theme <a href="https://github.com/arulrajnet/attila" rel="nofollow">Attila</a></span>
          <span class="credits-software">Published with <a href="https://github.com/getpelican/pelican" rel="nofollow">Pelican</a></span>
        </section>
      </div>
    </footer>
  </section>

  <script src="https://ajax.googleapis.cnpmjs.org/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.1.2/build/highlight.min.js"></script>
  <script type="text/javascript" src="https://www.linuxzen.com/theme/js/script.js"></script>

    <script type="text/javascript">
        var pkBaseURL = "piwik.linuxzen.com";
    var _paq = _paq || [];
    _paq.push(["trackPageView"]);
    _paq.push(["enableLinkTracking"]);
    (function() {
        var u=(("https:" == document.location.protocol) ? "https" : "http")+"://"+pkBaseURL+"/";
        _paq.push(["setTrackerUrl", u+"piwik.php"]);
        _paq.push(["setSiteId", "2"]);
        var d=document, g=d.createElement("script"), s=d.getElementsByTagName("script")[0]; g.type="text/javascript";
        g.defer=true; g.async=true; g.src=u+"piwik.js"; s.parentNode.insertBefore(g,s);
    })();
    </script>
<script type="text/javascript">
    var disqus_shortname = 'linuxzen';
    (function () {
        var s = document.createElement('script'); s.async = true;
        s.type = 'text/javascript';
        s.src = '//' + disqus_shortname + '.disqus.com/count.js';
        (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
    }());
</script>
</body>
</html>