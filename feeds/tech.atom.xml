<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>cold's world - Tech</title><link href="https://www.linuxzen.com/" rel="alternate"></link><link href="https://www.linuxzen.com/feeds/tech.atom.xml" rel="self"></link><id>https://www.linuxzen.com/</id><updated>2019-05-10T00:00:00+08:00</updated><subtitle>纸上得来终觉浅，绝知此事要躬行</subtitle><entry><title>【译文】理解布隆过滤器</title><link href="https://www.linuxzen.com/understanding-bloom-filter.html" rel="alternate"></link><published>2019-05-10T00:00:00+08:00</published><updated>2019-05-10T00:00:00+08:00</updated><author><name>cold</name></author><id>tag:www.linuxzen.com,2019-05-10:/understanding-bloom-filter.html</id><summary type="html">&lt;p&gt;原文：&lt;a href="https://osoco.es/thoughts/2019/05/understanding-bloom-filters-with-pharo-smalltalk/"&gt;Understanding Bloom filters with Pharo Smalltalk&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;本文通过 HTML 转录了 &lt;a href="https://github.com/osoco/PharoPDS"&gt;PharoPDS&lt;/a&gt; 库及其扩展附带的交互式教程，以探索和理解布隆过滤器。&lt;/p&gt;
&lt;p&gt;因此，如果您想在真实 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;原文：&lt;a href="https://osoco.es/thoughts/2019/05/understanding-bloom-filters-with-pharo-smalltalk/"&gt;Understanding Bloom filters with Pharo Smalltalk&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;本文通过 HTML 转录了 &lt;a href="https://github.com/osoco/PharoPDS"&gt;PharoPDS&lt;/a&gt; 库及其扩展附带的交互式教程，以探索和理解布隆过滤器。&lt;/p&gt;
&lt;p&gt;因此，如果您想在真实的环境中修改这些数据结构，请尝试在 &lt;a href="https://pharo.org/"&gt;Pharo&lt;/a&gt; 镜像中&lt;a href="https://github.com/osoco/PharoPDS#install-pharopds"&gt;安装这个库&lt;/a&gt;，并按照交互式教程并使用提供的自定义工具进行操作。&lt;/p&gt;
&lt;h2 id="_1"&gt;理解布隆过滤器&lt;/h2&gt;
&lt;p&gt;布隆过滤器是一个非常节省空间的数据结构，由 Burton Howard Bloom 于 1970 年所提出（&lt;a href="http://crystal.uta.edu/~mcguigan/cse6350/papers/Bloom.pdf"&gt;Space/Time Trade-offs in Hash Coding with Allowable Errors&lt;/a&gt;），布隆过滤器用于测试一个元素是否是集合的成员之一。&lt;/p&gt;
&lt;p&gt;常规的哈希搜索通过将一系列值存储在哈希表上，不管是基于链表还是开放寻址（&lt;a href="https://en.wikipedia.org/wiki/Open_addressing"&gt;open addressing&lt;/a&gt;)，随着越来越多的元素添加到哈希表中，定位元素的期望时间都会从初始的常量的 O(1) 退化或增加到线性的 O(N)。&lt;/p&gt;
&lt;p&gt;布隆过滤器提供了一个替代的数据结构，可以实现在添加元素或检查元素是否是成员上，不管在空间和时间上都可以保证常量级的性能，并且和已经添加到过滤器中的元素数量是无关的。&lt;/p&gt;
&lt;p&gt;为了达到如此高效的表现所需要付出的代价是：布隆过滤器是一个概率性的数据结构。Bloom 他在开创性的论文中解释如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;新的方法打算比传统相关的方法减少一定量哈希码所需要的空间。通过利用某些应用可以容忍少量的误差来减少空间的使用，特别是那些拥有大量的数据参与无法通过传统的方法保留核心哈希区域的应用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="_2"&gt;背景&lt;/h2&gt;
&lt;p&gt;Donald Knuth 在他著名的 &lt;a href="https://www-cs-faculty.stanford.edu/~knuth/taocp.html"&gt;The Art of Computer Programming&lt;/a&gt; 中写下了如下对布隆过滤器的描述：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;想象一个拥有非常大量的数据且如果搜索没有成功则无需完成任何计算的搜索应用。比如，我们可能想检查一些人的信用评级或者护照编号，如果文档中没有该人的任何记录我们就无需做任何调查。类似地，在计算机排版应用程序中，我们可能有一个简单算法可以正确地连接大多数单词，但该算法会对大约 5W 个异常单词无效; 如果我们在异常文件中找不到该单词，就可以放心的使用该简单算法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;同时 Andrei Broder 和 Michael Mitzenmacher 在著名的布隆过滤器原理（The Bloom Filter Principle(&lt;a href="https://www.eecs.harvard.edu/~michaelm/postscripts/im2005b.pdf"&gt;Internet Mathematics Vol. 1, No. 4: 485-509Network Applications ofBloom Filters: A Survey&lt;/a&gt;)）中提出：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在一个空间宝贵的情况下要使用列表或集合并且可以接受误报，则可以考虑使用布隆过滤器。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="_3"&gt;真实世界的例子&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Medium 使用布隆过滤器避免推荐给用户已经读过的文章。&lt;/li&gt;
&lt;li&gt;Google Chrome 使用布隆过滤器识别恶意 URL。&lt;/li&gt;
&lt;li&gt;Google BigTable，Apache HBbase 和 Apache Cassandra 使用布隆过滤器减少对不存在的行和列的查找。&lt;/li&gt;
&lt;li&gt;Squid Web 代理使用布隆过滤器处理缓存摘要。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="_4"&gt;基本理解&lt;/h2&gt;
&lt;p&gt;布隆过滤器可以通过舍弃元素的特征来高效的存储大规模集合，比如它仅将通过算法对每一个元素应用哈希函数得到的数字存储到一系列位上进行关联。&lt;/p&gt;
&lt;p&gt;事实上，布隆过滤器通过一个长度（m）和不同哈希函数的数量（k）的比特数组（bit arrary）来表示。&lt;/p&gt;
&lt;p&gt;该数据结构仅支持两种操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;添加一个元素到集合中来，&lt;/li&gt;
&lt;li&gt;测试一个元素是否集合的成员。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;布隆过滤器的数据结构是一个初始比特位都为 0 的比特数组，代表布隆过滤器为空。&lt;/p&gt;
&lt;p&gt;举个例子，考虑如下示例中创建的布隆过滤器表示一个包含 10 个元素的集合并且误报率（FPP, False Positive Probability）为  &lt;code&gt;0.1&lt;/code&gt; （10%）。&lt;/p&gt;
&lt;p&gt;一个空的布隆过滤器将通过一个长度为 &lt;code&gt;m=48&lt;/code&gt; (storageSize) 和 4 个哈希函数的比特数组用以支持生产范围在 &lt;code&gt;{1, 2, ..., m}&lt;/code&gt; 的值。表示如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="nf"&gt;emptyBloomFilter&lt;/span&gt;
  &lt;span class="err"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;gtExample&lt;/span&gt;&lt;span class="nf"&gt;&amp;gt;&lt;/span&gt;
  &lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="nv"&gt; bloom &lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;
  &lt;span class="nv"&gt;bloom&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nc"&gt;PDSBloomFilter&lt;/span&gt; &lt;span class="nf"&gt;new:&lt;/span&gt; &lt;span class="m"&gt;10&lt;/span&gt; &lt;span class="nf"&gt;fpp:&lt;/span&gt; &lt;span class="m"&gt;0.1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
  &lt;span class="bp"&gt;self&lt;/span&gt; &lt;span class="nf"&gt;assert:&lt;/span&gt; &lt;span class="nv"&gt;bloom&lt;/span&gt; &lt;span class="nf"&gt;size&lt;/span&gt; &lt;span class="nf"&gt;eqauls:&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
  &lt;span class="bp"&gt;self&lt;/span&gt; &lt;span class="nf"&gt;assert:&lt;/span&gt; &lt;span class="nv"&gt;bloom&lt;/span&gt; &lt;span class="nf"&gt;hashes&lt;/span&gt; &lt;span class="nf"&gt;equals:&lt;/span&gt; &lt;span class="m"&gt;4&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
  &lt;span class="bp"&gt;self&lt;/span&gt; &lt;span class="nf"&gt;assert:&lt;/span&gt; &lt;span class="nv"&gt;bllom&lt;/span&gt; &lt;span class="nf"&gt;storageSize&lt;/span&gt; &lt;span class="nf"&gt;equals:&lt;/span&gt; &lt;span class="m"&gt;48&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
  &lt;span class="o"&gt;^&lt;/span&gt; &lt;span class="nv"&gt;bloom&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img alt="" src="/static/upload/trans-understanding-bloom-filter/empty-bloom-filter.png"&gt;&lt;/p&gt;
&lt;p&gt;要插入一个元素 &lt;code&gt;x&lt;/code&gt; 到布隆过滤器中，需要对元素 &lt;code&gt;x&lt;/code&gt; 应用到每一个哈希函数 $h_i$ 上并计算它的值为 $j=h_i(x)$ ，然后将布隆过滤器中 &lt;code&gt;j&lt;/code&gt; 对应的位设置为 1 。&lt;/p&gt;
&lt;p&gt;作为一个例子，我们将在上面的过滤器中插入一些城市的名字。让我们通过 &lt;code&gt;'Madrid'&lt;/code&gt; 开始：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="nf"&gt;withMadridBloomFilter&lt;/span&gt;
  &lt;span class="err"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;gtExample&lt;/span&gt;&lt;span class="nf"&gt;&amp;gt;&lt;/span&gt;
  &lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="nv"&gt; bloom &lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;
  &lt;span class="nv"&gt;bloom&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt; &lt;span class="nf"&gt;emptyBloomfilter&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
  &lt;span class="nv"&gt;bloom&lt;/span&gt; &lt;span class="nf"&gt;add:&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;Madrid&amp;#39;&lt;/span&gt; &lt;span class="nf"&gt;asByteArray&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
  &lt;span class="bp"&gt;self&lt;/span&gt; &lt;span class="nf"&gt;assert:&lt;/span&gt; &lt;span class="nv"&gt;bloom&lt;/span&gt; &lt;span class="nf"&gt;size&lt;/span&gt; &lt;span class="nf"&gt;equals:&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
  &lt;span class="o"&gt;^&lt;/span&gt; &lt;span class="nv"&gt;bloom&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img alt="" src="/static/upload/trans-understanding-bloom-filter/withMadrid-bloom-filter.png"&gt;&lt;/p&gt;
&lt;p&gt;布隆过滤器计算出了 4 个哈希值用以在集合中找到关联 &lt;code&gt;'Madrid'&lt;/code&gt; 的比特位。如上图所展示，布隆过滤器设置了 9, 18, 39 和 48 。&lt;/p&gt;
&lt;p&gt;不同的元素可能共享一个比特位，比如现在我们添加另一个城市 &lt;code&gt;'Barcelona'&lt;/code&gt; 到上面相同的布隆过滤器中：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="/static/upload/trans-understanding-bloom-filter/withMadridAndBarcelona-bloom-filter.png"&gt;&lt;/p&gt;
&lt;p&gt;如你所见，在添加 &lt;code&gt;'Barcelona'&lt;/code&gt; 到上面布隆过滤器之后只有 30, 36 和 42 所对应的比特位被设置，也就意味着元素 &lt;code&gt;'Madrid'&lt;/code&gt; 和 &lt;code&gt;'Barcelona'&lt;/code&gt; 共享了一个比特位。&lt;/p&gt;
&lt;p&gt;要想测试给定的元素 &lt;code&gt;x&lt;/code&gt; 是否在布隆过滤器之中，只需要检查所有的哈希函数 &lt;code&gt;k&lt;/code&gt; 计算出的对应的比特位。如果所有位都被设置来，则表示元素 &lt;code&gt;x&lt;/code&gt; 可能在布隆过滤器中，否则元素 &lt;code&gt;x&lt;/code&gt; 一定不在其中。&lt;/p&gt;
&lt;p&gt;元素存在不确定性是由于一些比特位可能是被之前添加的其他不同的元素所设置。&lt;/p&gt;
&lt;p&gt;考虑前面的例子，在已经添加了元素 &lt;code&gt;'Madrid'&lt;/code&gt; 和 &lt;code&gt;'Barcelona'&lt;/code&gt; 的情况下，我们来测试元素 &lt;code&gt;'Barcelona'&lt;/code&gt; 是否是该过滤器的成员，布隆过滤器计算出该元素的 4 个哈希值并且检查对应的比特位是否被设置，结果显示字符串 &lt;code&gt;'Barcelona'&lt;/code&gt; 可能存在于过滤器之中，然后 &lt;code&gt;contains: 'Barcelona'&lt;/code&gt; 返回 &lt;code&gt;true&lt;/code&gt; ：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="nf"&gt;withMadridAndBarcelonaCheckBarcelonaBloomFilter&lt;/span&gt;
  &lt;span class="err"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;gtExample&lt;/span&gt;&lt;span class="nf"&gt;&amp;gt;&lt;/span&gt;
  &lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="nv"&gt; bloom &lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;
  &lt;span class="nv"&gt;bloom&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt; &lt;span class="nf"&gt;withMadridBloomFilter&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
  &lt;span class="nv"&gt;bloom&lt;/span&gt; &lt;span class="nf"&gt;add:&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;Barcelona&amp;#39;&lt;/span&gt; &lt;span class="nf"&gt;asByteArray&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
  &lt;span class="bp"&gt;self&lt;/span&gt; &lt;span class="nf"&gt;assert:&lt;/span&gt; &lt;span class="nv"&gt;bloom&lt;/span&gt; &lt;span class="nf"&gt;size&lt;/span&gt; &lt;span class="nf"&gt;equals:&lt;/span&gt; &lt;span class="m"&gt;2&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
  &lt;span class="bp"&gt;self&lt;/span&gt; &lt;span class="nf"&gt;assert:&lt;/span&gt; (&lt;span class="nv"&gt;bloom&lt;/span&gt; &lt;span class="nf"&gt;contains:&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;Barcelona&amp;#39;&lt;/span&gt; &lt;span class="nf"&gt;asByteArray&lt;/span&gt;)&lt;span class="p"&gt;.&lt;/span&gt;
  &lt;span class="o"&gt;^&lt;/span&gt; &lt;span class="nv"&gt;bloom&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;现在如果我们检查元素 &lt;code&gt;'Berlin'&lt;/code&gt; ，布隆过滤器为了找到对应的比特位会通过如下方式计算它的哈希值：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="nf"&gt;withBerlinBloomFilter&lt;/span&gt;
  &lt;span class="err"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;gtExample&lt;/span&gt;&lt;span class="nf"&gt;&amp;gt;&lt;/span&gt;
    &lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="nv"&gt; bloom &lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;
    &lt;span class="nv"&gt;bloom&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt; &lt;span class="nf"&gt;emptyBloomFilter&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
    &lt;span class="nv"&gt;bloom&lt;/span&gt; &lt;span class="nf"&gt;add:&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;Berlin&amp;#39;&lt;/span&gt; &lt;span class="nf"&gt;asByteArray&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
    &lt;span class="bp"&gt;self&lt;/span&gt; &lt;span class="nf"&gt;assert:&lt;/span&gt; &lt;span class="nv"&gt;bloom&lt;/span&gt; &lt;span class="nf"&gt;size&lt;/span&gt; &lt;span class="nf"&gt;equals:&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
    &lt;span class="o"&gt;^&lt;/span&gt; &lt;span class="nv"&gt;bloom&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img alt="" src="/static/upload/trans-understanding-bloom-filter/withBerlin-bloom-filter.png"&gt;&lt;/p&gt;
&lt;p&gt;我们看到比特位 27 和 33 没有被设置，所以元素 &lt;code&gt;'Berlin'&lt;/code&gt; 一定不存在于布隆过滤器中，所以 &lt;code&gt;contains:&lt;/code&gt; 方法返回 &lt;code&gt;false&lt;/code&gt; ：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="nf"&gt;withMadridAndBarcelonaCheckBerlinBloomFilter&lt;/span&gt;
  &lt;span class="err"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;gtExample&lt;/span&gt;&lt;span class="nf"&gt;&amp;gt;&lt;/span&gt;
  &lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="nv"&gt; bloom &lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;
  &lt;span class="nv"&gt;bloom&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt; &lt;span class="nf"&gt;withMadridBloomFilter&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
  &lt;span class="nv"&gt;bloom&lt;/span&gt; &lt;span class="nf"&gt;add:&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;Barcelona&amp;#39;&lt;/span&gt; &lt;span class="nf"&gt;asByteArray&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
  &lt;span class="bp"&gt;self&lt;/span&gt; &lt;span class="nf"&gt;assert:&lt;/span&gt; &lt;span class="nv"&gt;bloom&lt;/span&gt; &lt;span class="nf"&gt;size&lt;/span&gt; &lt;span class="nf"&gt;equals:&lt;/span&gt; &lt;span class="m"&gt;2&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
  &lt;span class="bp"&gt;self&lt;/span&gt; &lt;span class="nf"&gt;assert:&lt;/span&gt; (&lt;span class="nv"&gt;bloom&lt;/span&gt; &lt;span class="nf"&gt;contains:&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;Berlin&amp;#39;&lt;/span&gt; &lt;span class="nf"&gt;asByteArray&lt;/span&gt;) &lt;span class="nf"&gt;not&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
  &lt;span class="o"&gt;^&lt;/span&gt; &lt;span class="nv"&gt;bloom&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;布隆过滤器的结果也可能是错误的。例如，考虑元素 &lt;code&gt;'Roma'&lt;/code&gt; 的 4 个哈希值 36 由于碰撞已经在我们的示例过滤器中设置，所以 &lt;code&gt;contains:&lt;/code&gt; 方法认为该元素可能已经存在于过滤器中。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="nf"&gt;withMadridAndBarcelonaCheckRomaBloomFilter&lt;/span&gt;
  &lt;span class="err"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;gtExample&lt;/span&gt;&lt;span class="nf"&gt;&amp;gt;&lt;/span&gt;
    &lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="nv"&gt; bloom &lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;
    &lt;span class="nv"&gt;bloom&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt; &lt;span class="nf"&gt;withMadridBloomFilter&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
    &lt;span class="nv"&gt;bloom&lt;/span&gt; &lt;span class="nf"&gt;add:&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;Barcelona&amp;#39;&lt;/span&gt; &lt;span class="nf"&gt;asByteArray&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
    &lt;span class="bp"&gt;self&lt;/span&gt; &lt;span class="nf"&gt;assert:&lt;/span&gt; &lt;span class="nv"&gt;bloom&lt;/span&gt; &lt;span class="nf"&gt;size&lt;/span&gt; &lt;span class="nf"&gt;equals:&lt;/span&gt; &lt;span class="m"&gt;2&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
    &lt;span class="bp"&gt;self&lt;/span&gt; &lt;span class="nf"&gt;assert:&lt;/span&gt; (&lt;span class="nv"&gt;bloom&lt;/span&gt; &lt;span class="nf"&gt;contains:&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;Roma&amp;#39;&lt;/span&gt; &lt;span class="nf"&gt;asByteArray&lt;/span&gt;)&lt;span class="p"&gt;.&lt;/span&gt;
    &lt;span class="o"&gt;^&lt;/span&gt; &lt;span class="nv"&gt;bloom&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;就像我们所了解到的，我们并没有添加过该元素到布隆过滤器中，所以这是一个误报的例子。在这个特别的案例中，比特位 &lt;code&gt;36&lt;/code&gt; 已经被前面的元素 &lt;code&gt;'Barcelona'&lt;/code&gt; 所设置。&lt;/p&gt;
&lt;h2 id="_5"&gt;特性&lt;/h2&gt;
&lt;h3 id="_6"&gt;误报&lt;/h3&gt;
&lt;p&gt;如我们前面所展示，布隆过滤器会对一些不是集合中的成员的元素返回 &lt;code&gt;true&lt;/code&gt; 。这种情况被成为误报（false positive），产生于哈希碰撞导致的巧合而将不同的元素存储在相同的比特位上。在测试操作中无法得知我们对比的特定的位是否被相同的哈希函数所设置。&lt;/p&gt;
&lt;p&gt;幸运的是，布隆过滤器有一个可预测的误报率（FPP）：&lt;/p&gt;
&lt;p&gt;$$P_fp\approx\left(1-e^{-\frac{kn}{m}}\right)^k$$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;n&lt;/code&gt; 是已经添加元素的数量；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;k&lt;/code&gt; 哈希的次数；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;m&lt;/code&gt; 布隆过滤器的长度（如比特数组的大小）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;极端情况下，当布隆过滤器没有空闲空间时（满），每一次查询都会返回 &lt;code&gt;true&lt;/code&gt; 。这也就意味着 &lt;code&gt;m&lt;/code&gt; 的选择取决于期望预计添加元素的数量 &lt;code&gt;n&lt;/code&gt; ，并且 &lt;code&gt;m&lt;/code&gt; 需要远远大于 &lt;code&gt;n&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;实际情况中，布隆过滤器的长度 &lt;code&gt;m&lt;/code&gt; 可以根据给定的误报率（FFP）的和期望添加的元素个数 &lt;code&gt;n&lt;/code&gt; 的通过如下公式计算：&lt;/p&gt;
&lt;p&gt;$$m=-\frac{n\ln{P_{fp}}}{(\ln2)^2}$$&lt;/p&gt;
&lt;p&gt;对于 $\frac{m}{n}$ 比率表示每一个元素需要分配的比特位的数量，也就是哈希函数 &lt;code&gt;k&lt;/code&gt; 的数量可以调整误报率。通过如下公式来选择最佳的 &lt;code&gt;k&lt;/code&gt; 可以减少误报率（FPP）：&lt;/p&gt;
&lt;p&gt;$$k=\frac{m}{n}\ln2$$&lt;/p&gt;
&lt;p&gt;我们实现的 &lt;code&gt;PDSBloomFilter&lt;/code&gt; 建立在指定预计添加元素的数量（ &lt;code&gt;n&lt;/code&gt; ）和误报率（ &lt;code&gt;FPP&lt;/code&gt; ）之上，然后使用上面的公式去计算最优的哈希次数和比特数组的长度。&lt;/p&gt;
&lt;p&gt;比如，要处理 10 亿个元素并且保持 2% 左右的误报率我们需要如下布隆过滤器：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="nf"&gt;oneBillionBloomFilter&lt;/span&gt;
    &lt;span class="err"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;gtExample&lt;/span&gt;&lt;span class="nf"&gt;&amp;gt;&lt;/span&gt;
      &lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="nv"&gt; bloom &lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;
      &lt;span class="nv"&gt;bloom&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nc"&gt;PDSBloomFilter&lt;/span&gt; &lt;span class="nf"&gt;new:&lt;/span&gt; &lt;span class="m"&gt;1000000000&lt;/span&gt; &lt;span class="nf"&gt;fpp:&lt;/span&gt; &lt;span class="m"&gt;0.02&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
      &lt;span class="bp"&gt;self&lt;/span&gt; &lt;span class="nf"&gt;assert:&lt;/span&gt; &lt;span class="nv"&gt;bloom&lt;/span&gt; &lt;span class="nf"&gt;size&lt;/span&gt; &lt;span class="nf"&gt;equals:&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
      &lt;span class="bp"&gt;self&lt;/span&gt; &lt;span class="nf"&gt;assert:&lt;/span&gt; &lt;span class="nv"&gt;bloom&lt;/span&gt; &lt;span class="nf"&gt;hashes&lt;/span&gt; &lt;span class="nf"&gt;equals:&lt;/span&gt; &lt;span class="m"&gt;6&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
      &lt;span class="bp"&gt;self&lt;/span&gt; &lt;span class="nf"&gt;assert:&lt;/span&gt; &lt;span class="nv"&gt;bloom&lt;/span&gt; &lt;span class="nf"&gt;storageSize&lt;/span&gt; &lt;span class="nf"&gt;equals:&lt;/span&gt; &lt;span class="m"&gt;8142363337&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
      &lt;span class="o"&gt;^&lt;/span&gt; &lt;span class="nv"&gt;bloom&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如你所见，最优的哈希次数是 6 并且过滤器的长度是 $8.14 x 10^9$ 个比特位，大约占用 1 GB 内存。&lt;/p&gt;
&lt;h3 id="_7"&gt;非误报&lt;/h3&gt;
&lt;p&gt;如果布隆过滤器返回特定的元素不是成员之一，那么该元素就绝对不在集合之中。&lt;/p&gt;
&lt;h3 id="_8"&gt;无法删除&lt;/h3&gt;
&lt;p&gt;要想从过滤器中删除一个元素需要在比特数组中取消设置相应数量（ &lt;code&gt;k&lt;/code&gt; ）的比特位。不幸的是，由于哈希碰撞导致多个元素会共享比特位导致了一个比特位可能关联了多个元素。&lt;/p&gt;
&lt;h2 id="_9"&gt;分析&lt;/h2&gt;
&lt;p&gt;前面计算误报率（FPP）的公式为了容易计算从而假设了哈希函数 &lt;code&gt;k&lt;/code&gt; 的随机是均匀分布的。&lt;/p&gt;
&lt;p&gt;换句话说，一旦将期望的 &lt;code&gt;n&lt;/code&gt; 个元素添加到数据结构中， &lt;code&gt;fpp&lt;/code&gt; 在 &lt;code&gt;PDSBloomFilter&lt;/code&gt; 初始化时指定的值应该解释为期望的 &lt;code&gt;fpp&lt;/code&gt; 的值。&lt;/p&gt;
&lt;p&gt;例如，对于一个刚刚创建依然保持为空的布隆过滤器的 &lt;code&gt;fpp&lt;/code&gt; 值为 0，如下图所见：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="/static/upload/trans-understanding-bloom-filter/empty-filter-fpp-curve.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;fpp&lt;/code&gt; 的值会随着不断的向过滤器中添加元素而增长，并随着布隆过滤器中的元素数量达到期望值而最终达到目标 &lt;code&gt;fpp&lt;/code&gt; ，我们通过如下填充布隆过滤器：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="nf"&gt;fullBloomFilter&lt;/span&gt;
    &lt;span class="err"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;gtExample&lt;/span&gt;&lt;span class="nf"&gt;&amp;gt;&lt;/span&gt;
    &lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="nv"&gt; bloom &lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;
    &lt;span class="nv"&gt;bloom&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt; &lt;span class="nf"&gt;emptyBloomFilter&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
    &lt;span class="m"&gt;1&lt;/span&gt; &lt;span class="nf"&gt;to:&lt;/span&gt; &lt;span class="nv"&gt;bloom&lt;/span&gt; &lt;span class="nf"&gt;targetElements&lt;/span&gt;
        &lt;span class="nf"&gt;do:&lt;/span&gt; [ &lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="nv"&gt;each&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="nv"&gt;bloom&lt;/span&gt; &lt;span class="nf"&gt;add:&lt;/span&gt; &lt;span class="nv"&gt;each&lt;/span&gt; &lt;span class="nf"&gt;asString&lt;/span&gt; &lt;span class="nf"&gt;asByteArray&lt;/span&gt; ]&lt;span class="p"&gt;.&lt;/span&gt;
    &lt;span class="o"&gt;^&lt;/span&gt; &lt;span class="nv"&gt;bloom&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img alt="" src="/static/upload/trans-understanding-bloom-filter/full-filter-fpp-curve.png"&gt;&lt;/p&gt;
&lt;p&gt;不过，你应该知道上面的 FPP 曲线是一个理论值并且实际观测到的 FPP 将会取决于特定的数据集和所使用的哈希函数。为了实验检查我们的实现的优点，我们进行了如下分析：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;随机生成一个包含邮件地址的列表并插入到布隆过滤器。&lt;/li&gt;
&lt;li&gt;随机生成一个包含邮件地址的列表不插入到该过滤器中。&lt;/li&gt;
&lt;li&gt;统计在该过滤器中搜索缺失地址的误报情况。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我们运行的实验值在该过滤器期望元素个数的 10 到 1.5 倍（步长 10）。对于每种实验的元素数量运行 10 次。该分析通过一个图像展示了该过滤器的如下指标：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;理论的 FPP 曲线（蓝色）。&lt;/li&gt;
&lt;li&gt;每次实验测量到的平均 FPP 值（灰色十字）。&lt;/li&gt;
&lt;li&gt;实际的 FPP 曲线（红色）&lt;/li&gt;
&lt;li&gt;和标准差（红色阴影）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例如，如下代码运行上面的实验分析并且通过一个图展示一个包含 100 个元素和 3% 的 FPP 的布隆过滤器结果：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="nc"&gt;PDSBloomFilterAnalysis&lt;/span&gt; &lt;span class="nf"&gt;openFor:&lt;/span&gt; (&lt;span class="nc"&gt;PDSBloomFilter&lt;/span&gt; &lt;span class="nf"&gt;new:&lt;/span&gt; &lt;span class="m"&gt;100&lt;/span&gt; &lt;span class="nf"&gt;fpp:&lt;/span&gt; &lt;span class="m"&gt;0.03&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img alt="" src="/static/upload/trans-understanding-bloom-filter/analysis-fpp.png"&gt;&lt;/p&gt;
&lt;h2 id="_10"&gt;压测&lt;/h2&gt;
&lt;p&gt;一个布隆过滤器每次操作只需要固定次数的探测（ &lt;code&gt;k&lt;/code&gt; ），所以在每次插入和查找的处理只需要 &lt;code&gt;O(k)&lt;/code&gt; 的时间复杂度，也就是常量级的。&lt;/p&gt;
&lt;p&gt;例如，如下代码将基于在前面被填充了 10 个元素的布隆过滤器上执行查找操作来运行一个微型压测并且展示每秒钟运行查找操作的次数：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="/static/upload/trans-understanding-bloom-filter/bloom-benchmark-little.png"&gt;&lt;/p&gt;
&lt;p&gt;由于时间复杂度是常量级的，那么一个前面添加了 100W 个元素的布隆过滤器的查找结果应该和上面类似：
&lt;img alt="" src="/static/upload/trans-understanding-bloom-filter/bloom-benchmark-million.png"&gt;&lt;/p&gt;
&lt;p&gt;一个基于 &lt;code&gt;Collection&lt;/code&gt; 数据结构的简单实现将是线性的 &lt;code&gt;O(n)&lt;/code&gt; 的时间复杂度，一个有序集合的最优情况将会是 &lt;code&gt;O(log n)&lt;/code&gt; 的时间复杂度。你可以通过观察下面压测使用一个长度为 &lt;code&gt;n&lt;/code&gt; 的 &lt;code&gt;OrderedCollection&lt;/code&gt; 集合的降级行为来检验：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="/static/upload/trans-understanding-bloom-filter/collection-benchmark-little.png"&gt;&lt;/p&gt;
&lt;p&gt;VS&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="/static/upload/trans-understanding-bloom-filter/collection-benchmark-million.png"&gt;&lt;/p&gt;
&lt;h2 id="_11"&gt;试玩&lt;/h2&gt;
&lt;p&gt;PharoPDS 提供了一个简单的工具让你可以探索和尝试布隆过滤器。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;PDSBloomFilterPlayground&lt;/code&gt; 允许你创建一个布隆过滤器尝试一些操作并且进行可视化。甚至你可以基于 UI 运行压测和调优。&lt;/p&gt;
&lt;p&gt;可以通过如下代码运行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="nc"&gt;PDSBloomFilterPlayground&lt;/span&gt; &lt;span class="nf"&gt;open&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img alt="" src="/static/upload/trans-understanding-bloom-filter/bloom-filter-playground.png"&gt;&lt;/p&gt;
&lt;h2 id="_12"&gt;引用&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;On Probabilistic Data Structures:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Burton H. Bloom. &lt;a href="http://crystal.uta.edu/~mcguigan/cse6350/papers/Bloom.pdf"&gt;Space/Time Trace-offs in Hash Coding with Allowable Errors&lt;/a&gt; (1970).&lt;/li&gt;
&lt;li&gt;Donald E. Knuth. &lt;a href="https://www-cs-faculty.stanford.edu/~knuth/taocp.html"&gt;The Art of Computer Programming&lt;/a&gt; Volume 3: Sorting and Searching.&lt;/li&gt;
&lt;li&gt;&lt;a href="http://llimllib.github.io/bloomfilter-tutorial/"&gt;Bloom Filters by Example&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Andrii Gakhov, &lt;a href="https://www.gakhov.com/books/pdsa.html"&gt;Probabilistic Data Structures and Algorithms for Big Data Applications&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;On Moldable Development:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Andrei Chis’s PhD, “Moldable Tools” (2016). Available at &lt;a href="http://scg.unibe.ch/archive/phd/chis-phd.pdf"&gt;http://scg.unibe.ch/archive/phd/chis-phd.pdf&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Andrei Chis, “Playing with Face Detection in Pharo” (2018). Available at &lt;a href="https://medium.com/@Chis_Andrei/playing-with-face-detection-in-pharo-e6dd297e0ca3"&gt;https://medium.com/@Chis_Andrei/playing-with-face-detection-in-pharo-e6dd297e0ca3&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Tudor Girba, “Moldable Development” (2018). Available at &lt;a href="https://www.youtube.com/watch?v=IcwHaF5aRTM"&gt;https://www.youtube.com/watch?v=IcwHaF5aRTM&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</content><category term="Tech"></category><category term="Bloom"></category><category term="Filter"></category><category term="布隆过滤器"></category><category term="Bloom Filter"></category></entry><entry><title>【译文】什么是幂等</title><link href="https://www.linuxzen.com/what-is-idempotence.html" rel="alternate"></link><published>2019-05-05T00:00:00+08:00</published><updated>2019-05-05T00:00:00+08:00</updated><author><name>cold</name></author><id>tag:www.linuxzen.com,2019-05-05:/what-is-idempotence.html</id><summary type="html">&lt;p&gt;原文：&lt;a href="https://lispcast.com/what-is-idempotence/"&gt;WHAT IS IDEMPOTENCE&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;（原文是一个视频的文字记录版，有兴趣的可以看原文和原文中的视频，本文只翻译文字并结合自己的一些理 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;原文：&lt;a href="https://lispcast.com/what-is-idempotence/"&gt;WHAT IS IDEMPOTENCE&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;（原文是一个视频的文字记录版，有兴趣的可以看原文和原文中的视频，本文只翻译文字并结合自己的一些理解做一些整理。）&lt;/p&gt;
&lt;h3 id="_1"&gt;引子&lt;/h3&gt;
&lt;p&gt;幂等意味着可以重复，也就是说你可以安全的重试一个操作不会产生任何问题。经典的例子是电梯按钮：你按两次并不会叫来两辆电梯。同时我们来探索为什么在一个 Email 服务中需要这个特性。&lt;/p&gt;
&lt;p&gt;什么是幂等？为什么幂等对于分布式编程非常有用？通过这篇文章，你将知道如何在你自己的系统中实现幂等。&lt;/p&gt;
&lt;p&gt;幂等之所以重要是因为它抓住了安全重试的本质。没有安全重试也就没有办法实现一个安全的分布式协议。&lt;/p&gt;
&lt;h3 id="_2"&gt;什么是幂等？&lt;/h3&gt;
&lt;p&gt;幂等的本质就是你可以请求两次（或多次），但是和请求一次的所产生的副作用一致。经典的例子是电梯按钮。假设你来到一组电梯面前按下按钮，按钮亮起并呼叫电梯。然后另一个人同样来到这组电梯面前，按钮已经点亮但他依然按下相同的按钮。&lt;/p&gt;
&lt;p&gt;我们都知道这样做不会产生任何效果（副作用），但是由于某些原因我们依然想这么做，仅仅为了以防万一。也许他是对的，也许一开始信号并没有传递给电梯。由于这样做没有任何坏处，所以为什么不呢？这就是我们想在我们的分布式系统中贯彻的理念。&lt;/p&gt;
&lt;p&gt;技术上讲，这是一个属于代数的概念。当我们讨论按下按钮时，我们对现实的世界产生了一个有效的副作用。而在代数中，幂等是纯函数和数学函数的属性。幂等意味着你将字符串中的字母转换成大写两次对其结果没有任何影响，因为第一次操作就可以了。技术上来说，如果将函数 $F$ 应用到一个值上，如 $F(x)$ ，与将 $F(x)$ 应用到 $F$ 是相同的（ $F(x)=F(F(x))$ ）。&lt;/p&gt;
&lt;p&gt;我们应用了两次函数 $F$ 和应用一次所产生的副作用是一致的，也就是说重复无关。我按下按钮，第二次按下不会产生任何副作用和问题。如果我应用两次函数，第二次不会产生任何副作用。第一次有副作用，那么接下来第二次、第三次、第四次等等都不会产生副作用。&lt;/p&gt;
&lt;h3 id="_3"&gt;为什么幂等很重要？&lt;/h3&gt;
&lt;p&gt;在一个分布式系统，特别是分布式系统，我们会面临消息通过一个不可靠的网络传输。基本上，如果你发送了一个消息，消息可能没有送达并且你无法感知。也就是说你无法确定消息是否到达。&lt;/p&gt;
&lt;p&gt;有时，你得到连接中断的消息，你会知道消息没有到达。但有时超时导致你无法获得反馈。是消息已经到达但是由于 ACK 超时没有收到反馈，还是消息压根就没有到达？其他系统崩溃？系统崩溃发生在消息发送之前还是之后？由于系统已经崩溃，你无法得知。&lt;/p&gt;
&lt;p&gt;Email 实际上十一个很好的例子，因为同一封邮件你不想发送两次。让我们假设我们有一个邮件服务并且通过它发送一个消息：“请将这封邮件发送给我的客户”。你没有得到任何反馈，你将会怎么做？发生了什么？你会尝试重新发送吗？如果邮件已经发送了呢？再发一次相同的邮件？如果不重新发送客户将无法收到收件。&lt;/p&gt;
&lt;p&gt;这是一个真实存在的商业问题。幂等将可以解决此问题：如果我重新发送邮件，但不会破坏任何事情（不会产生第二次副作用）。就像前面说的电梯按钮一样，我可以一直重复发送这封邮件。我可以重复发送一百次，但这封邮件只会被投递一次。&lt;/p&gt;
&lt;p&gt;幂等实现了请求次数和实际产生副作用的次数的解偶。我可以请求一百次，但是只产生一次副作用。这是有些时候你真正想实现的：通过限制的消息能够进行安全的重试。&lt;/p&gt;
&lt;p&gt;“我不知道这是否行得通，但是我将会再试一次。”这将是你系统中非常好的属性。&lt;/p&gt;
&lt;h3 id="_4"&gt;如何实现幂等？&lt;/h3&gt;
&lt;p&gt;假设基于邮件服务，最简单的方法是需要通过一些方法去识别一封邮件的唯一性（ID）。比如：“这是这封邮件的 ID，如果你使用同一个 ID 发送同一封邮件多次，仅投递一次。”&lt;/p&gt;
&lt;p&gt;邮件服务为了实现完备的幂等性将会记住所有发送过的邮件 ID。但是通常这是不切实际的。因为当数量达到上百万时你无法记住每一个 ID。&lt;/p&gt;
&lt;p&gt;由于可能会追溯到许多年以前，并且一个请求不可能需要以年记才能到达。所以实际上，你可能需要一个窗口，如：“我们只保留 3 天的 ID”。也就是说你可以通过相同的 ID 重复的发送三天以内的邮件，并且不会产生第二次投递。在实际场景中，你需要平衡内存的需求和你系统所实现的安全重试机制来探索实际的限制。&lt;/p&gt;
&lt;p&gt;注意，唯一性的识别（ID）非常重要。如果没有唯一性识别（ID）的概念，那么怎么实现同一个消息再次发送？如果想给一个人发送两封邮件，我需要能发送两封邮件给他。我需要一种方法标志两封邮件不相同。如果我想重试，我需要一种方法标志这封邮件和那封邮件是同一个。&lt;/p&gt;
&lt;p&gt;你的请求需要一些 ID。参照电梯按钮，可能 ID 就在电梯服务的电子系统内部，它知道我按的哪个按钮：是三楼向上还是四楼向下。按钮的 ID 可以首先让按钮亮起，并且保持到不再需要后再关闭。&lt;/p&gt;
&lt;p&gt;ID 可能用在多个地方。用在一个请求上：“我们需要电梯向上到三层因为我们知道那个按钮和它的意义”。也可以是：“我已经发送过了到三层电梯的信号，我不需要再次发送。”。&lt;/p&gt;
&lt;p&gt;一旦确定了 ID，你可以使用一个已经是幂等的数据结构的操作，比如集合（set）。如果你用一个数字集合存储每个邮件的唯一数字 ID。当邮件服务发送完邮件，通过将数字 ID 添加到集合用以记录。如果你添加到该集合两次，你实际上已经获得到幂等性。&lt;/p&gt;
&lt;p&gt;同电梯一样，如果你有一个按钮包含来字符串 ID，比如 &lt;code&gt;third-floor-up&lt;/code&gt; 、 &lt;code&gt;third-floor-down&lt;/code&gt; 、 &lt;code&gt;fourth-floor-up&lt;/code&gt; 、 &lt;code&gt;fourth-floor-down&lt;/code&gt; , 通过将这些 ID 存放到集合内表示对应的按钮被请求而激活。这也就意味着你可以按下多次，第二次将不会产生任何效果（副作用）。&lt;/p&gt;
&lt;p&gt;当然，现在没有考虑按下按钮将电梯送到某一层的实际的实现。但是和邮件相同，现在的确考虑了发送还是不发送邮件。&lt;/p&gt;
&lt;p&gt;要想得知你是否想要发送它其实很简单。在添加某一项 ID 到集合中之前，询问集合：“你是否包含这个 ID ？”。如果已经包含则结束操作，如果不包含则发送邮件并将 ID 添加到集合内。除了集合还有一些其他的数据结构是幂等的，比如哈希表。&lt;/p&gt;
&lt;p&gt;前面提到的将字符串中的字母转换为大写，这是一种幂等的操作。&lt;/p&gt;
&lt;h3 id="_5"&gt;总结&lt;/h3&gt;
&lt;p&gt;让我们来概括一下。幂等意味着重复无关。他是一种代数中函数和操作的属性，但是我们将之扩展到现实世界中的一些行为。在分布式操作系统中我们之所以需要它因为我们需要在分布式系统中安全的重试。幂等让我们从请求次数和请求完成解偶出来。你可以很容易通过一些数据结构和对应的操作来实现。为了实现幂等需要每一个消息都有一个 ID。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;忽略以下和主题无关的翻译：&lt;/p&gt;
&lt;p&gt;Do yourselves a favor and look for some services that need to happen exactly once. Could be something like sending an email. Could be writing a message to a log. Could be some user setting in your user-panel, and wrap them in something like a data structure that makes them idempotent.&lt;/p&gt;
&lt;p&gt;Do me a favor please and share this with friends. If you found it valuable, they might find it valuable, too. Also, if you found it valuable, you probably want to subscribe. That way you’ll get all of the other new episodes as they come out. You won’t miss that value that you have already discovered.&lt;/p&gt;
&lt;p&gt;I like to be in deep discussions with smart people. Please email me. I’m eric@lispcast.com or get in a discussion on Twitter. I try to use Twitter as a discussion medium. I’m @ericnormand with a D there.&lt;/p&gt;
&lt;p&gt;Also, you can find me on LinkedIn. I’m trying to get better at LinkedIn. It’s a little hard for me. If that’s where you like to connect, let’s connect and start having a conversation.&lt;/p&gt;
&lt;p&gt;All right. See you later.&lt;/p&gt;</content><category term="Tech"></category><category term="Idempotence"></category><category term="幂等"></category></entry></feed>