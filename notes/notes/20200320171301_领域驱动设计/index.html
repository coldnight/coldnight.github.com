<!DOCTYPE html>
<html lang="en">
<head>
  
    <title>《领域驱动设计》读书笔记 :: Taking Smart Notes With Org-mode</title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="tags: 正在读的书,读书笔记,DDD 前言和目录 好的软件需要控制复杂性，好的领域模型可以帮助控制复杂性。
什么样的项目需要 DDD？尝试型的小型项目应该不需要 DDD，但是一旦上了规模考虑后续迭代则需要 DDD。
本书组织方式：
领域建模 领域建模的过程就是消化知识的过程，这个过程应该贯穿整个开发过程，需要持续学习。
模型用来描绘人们所关注的实现或想法的某个方面，比如地图就是模型。
模型是一种简化，是对实现的解释：把与解决问题密切相关的方面抽象出来，而忽略无关的细节。
软件问题建模的区域就是软件的领域
物质世界的领域：机票预订程序涉及的飞机乘客。 无形的领域：会计程序的金融领域。 领域涉及知识信息超载的问题，模型这种知识对知识进行了选择性的简化和有意的结构化。
领域模型将领域专家头脑中的支持严格的组织且有选择的抽象，并不是尽可能建立一个符合“现实”的模型。
模型表示 关联 规定一个遍历方向：存在双向联结时（地址 -&amp;gt; 人 或 人 -&amp;gt; 地址）尽量只用一种，并避免互相关联 添加一个限定符，以便有效减少多重关联 消除不必要的关联 表示方式 领域模式 实践 MODEL-DRIVEN DESIGN 隔离领域：引入应用层 应用 LAYERED ARCHITECTURE 把领域层划分出来，通过应用层类来处理应用程序功能。应用层类是协调者，负责提问，领域层负责回答。
将 ENTITY 和 VALUE OBJECT 区分开 依次考虑对象是必须跟踪的 ENTITY 还是表示一个 VALUE OBJECT。
AGGREGATE 边界 识别模型中的 AGGREGATE 根和对应的边界。
选择 REPOSITORY 为 AGGREGATE 根对象建立 REPOSITORY。
场景走查 根据应用程序特性复核建模，进行场景走查，确保能够有效地解决应用问题。可以走查一些正常和异常业务场景进行复核。
对象创建 如果对象复杂则创建单独的 FACTORY 类进行对象创建，简单对象可以直接在 AGGREGATE 根上通过 FACTORY METHOD 进行创建。" />
<meta name="keywords" content="" />
<meta name="robots" content="noodp" />
<link rel="canonical" href="https://www.linuxzen.com/notes/notes/20200320171301_%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/" />




<link rel="stylesheet" href="https://www.linuxzen.com/notes/assets/style.css">






<link rel="apple-touch-icon" href="https://www.linuxzen.com/notes/img/apple-touch-icon-192x192.png">

  <link rel="shortcut icon" href="https://www.linuxzen.com/notes/img/favicon/orange.png">



<meta name="twitter:card" content="summary" />



<meta property="og:locale" content="en" />
<meta property="og:type" content="article" />
<meta property="og:title" content="《领域驱动设计》读书笔记">
<meta property="og:description" content="tags: 正在读的书,读书笔记,DDD 前言和目录 好的软件需要控制复杂性，好的领域模型可以帮助控制复杂性。
什么样的项目需要 DDD？尝试型的小型项目应该不需要 DDD，但是一旦上了规模考虑后续迭代则需要 DDD。
本书组织方式：
领域建模 领域建模的过程就是消化知识的过程，这个过程应该贯穿整个开发过程，需要持续学习。
模型用来描绘人们所关注的实现或想法的某个方面，比如地图就是模型。
模型是一种简化，是对实现的解释：把与解决问题密切相关的方面抽象出来，而忽略无关的细节。
软件问题建模的区域就是软件的领域
物质世界的领域：机票预订程序涉及的飞机乘客。 无形的领域：会计程序的金融领域。 领域涉及知识信息超载的问题，模型这种知识对知识进行了选择性的简化和有意的结构化。
领域模型将领域专家头脑中的支持严格的组织且有选择的抽象，并不是尽可能建立一个符合“现实”的模型。
模型表示 关联 规定一个遍历方向：存在双向联结时（地址 -&amp;gt; 人 或 人 -&amp;gt; 地址）尽量只用一种，并避免互相关联 添加一个限定符，以便有效减少多重关联 消除不必要的关联 表示方式 领域模式 实践 MODEL-DRIVEN DESIGN 隔离领域：引入应用层 应用 LAYERED ARCHITECTURE 把领域层划分出来，通过应用层类来处理应用程序功能。应用层类是协调者，负责提问，领域层负责回答。
将 ENTITY 和 VALUE OBJECT 区分开 依次考虑对象是必须跟踪的 ENTITY 还是表示一个 VALUE OBJECT。
AGGREGATE 边界 识别模型中的 AGGREGATE 根和对应的边界。
选择 REPOSITORY 为 AGGREGATE 根对象建立 REPOSITORY。
场景走查 根据应用程序特性复核建模，进行场景走查，确保能够有效地解决应用问题。可以走查一些正常和异常业务场景进行复核。
对象创建 如果对象复杂则创建单独的 FACTORY 类进行对象创建，简单对象可以直接在 AGGREGATE 根上通过 FACTORY METHOD 进行创建。" />
<meta property="og:url" content="https://www.linuxzen.com/notes/notes/20200320171301_%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/" />
<meta property="og:site_name" content="Taking Smart Notes With Org-mode" />

  
    <meta property="og:image" content="https://www.linuxzen.com/notes/img/favicon/orange.png">
  

<meta property="og:image:width" content="2048">
<meta property="og:image:height" content="1024">


  <meta property="article:published_time" content="2019-06-15 00:00:00 &#43;0800 &#43;0800" />












</head>
<body class="orange">


<div class="container center headings--one-size">

  <header class="header">
  <div class="header__inner">
    <div class="header__logo">
      <a href="https://www.linuxzen.com/notes/">
  <div class="logo">
    Terminal
  </div>
</a>

    </div>
    
      <div class="menu-trigger">menu</div>
    
  </div>
  
    <nav class="menu">
  <ul class="menu__inner menu__inner--desktop">
    
      
        
          <li><a href="/notes/projects/"> Projects in Progress</a></li>
        
      
        
          <li><a href="/notes/articles/">Articles</a></li>
        
      
        
          <li><a href="/notes/flashcards/">Flashcards</a></li>
        
      
        
          <li><a href="/notes/notes/">Notes</a></li>
        
      
        
          <li><a href="/notes/topics/">Topics</a></li>
        
      
      
    

    
  </ul>

  <ul class="menu__inner menu__inner--mobile">
    
      
        <li><a href="/notes/projects/"> Projects in Progress</a></li>
      
    
      
        <li><a href="/notes/articles/">Articles</a></li>
      
    
      
        <li><a href="/notes/flashcards/">Flashcards</a></li>
      
    
      
        <li><a href="/notes/notes/">Notes</a></li>
      
    
      
        <li><a href="/notes/topics/">Topics</a></li>
      
    
    
  </ul>
</nav>

  
</header>


  <div class="content">
    
<div class="post">
  <h1 class="post-title">
    <a href="https://www.linuxzen.com/notes/notes/20200320171301_%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/">《领域驱动设计》读书笔记</a></h1>
  <div class="post-meta">
    
      <span class="post-date">
        2019-06-15 
      </span>
    
    
    <span class="post-author">:: [Gray King]</span>
    
  </div>

  
  <span class="post-tags">
    
    #<a href="https://www.linuxzen.com/notes/tags/ddd/">ddd</a>&nbsp;
    
  </span>
  

  

  

  <div class="post-content"><div>
        <ul>
<li>tags: <a href="/notes/topics/20200307114122_%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">正在读的书</a>,<a href="/notes/notes/20211210181234-%E8%AF%BB%E8%BF%87%E7%9A%84%E4%B9%A6/">读书笔记</a>,<a href="/notes/notes/20210814071825-%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/">DDD</a></li>
</ul>
<h2 id="前言和目录">前言和目录<a href="#前言和目录" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>好的软件需要控制复杂性，好的领域模型可以帮助控制复杂性。</p>
<p>什么样的项目需要 DDD？尝试型的小型项目应该不需要 DDD，但是一旦上了规模考虑后续迭代则需要 DDD。</p>
<p>本书组织方式：</p>
<h2 id="领域建模">领域建模<a href="#领域建模" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>领域建模的过程就是消化知识的过程，这个过程应该贯穿整个开发过程，需要持续学习。</p>
<ul>
<li>
<p>模型用来描绘人们所关注的实现或想法的某个方面，比如地图就是模型。</p>
</li>
<li>
<p>模型是一种简化，是对实现的解释：把与解决问题密切相关的方面抽象出来，而忽略无关的细节。</p>
<p>软件问题建模的区域就是软件的领域</p>
<ul>
<li>物质世界的领域：机票预订程序涉及的飞机乘客。</li>
<li>无形的领域：会计程序的金融领域。</li>
</ul>
<p>领域涉及知识信息超载的问题，模型这种知识对知识进行了选择性的简化和有意的结构化。</p>
</li>
<li>
<p>领域模型将领域专家头脑中的支持严格的组织且有选择的抽象，并不是尽可能建立一个符合“现实”的模型。</p>
</li>
</ul>
<h3 id="模型表示">模型表示<a href="#模型表示" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<h4 id="关联">关联<a href="#关联" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h4>
<ol>
<li>规定一个遍历方向：存在双向联结时（地址 -&gt; 人 或 人 -&gt; 地址）尽量只用一种，并避免互相关联</li>
<li>添加一个限定符，以便有效减少多重关联</li>
<li>消除不必要的关联</li>
</ol>
<h4 id="表示方式">表示方式<a href="#表示方式" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h4>
<h2 id="领域模式--20210903080049-领域模式-dot-md"><a href="/notes/notes/20210903080049-%E9%A2%86%E5%9F%9F%E6%A8%A1%E5%BC%8F/">领域模式</a><a href="#领域模式--20210903080049-领域模式-dot-md" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<h2 id="实践-model-driven-design--20210903080049-领域模式-dot-md">实践 <a href="/notes/notes/20210903080049-%E9%A2%86%E5%9F%9F%E6%A8%A1%E5%BC%8F/#模式-model-driven-design">MODEL-DRIVEN DESIGN</a><a href="#实践-model-driven-design--20210903080049-领域模式-dot-md" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<h3 id="隔离领域-引入应用层">隔离领域：引入应用层<a href="#隔离领域-引入应用层" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>应用 <a href="/notes/notes/20210903080049-%E9%A2%86%E5%9F%9F%E6%A8%A1%E5%BC%8F/#模式-layered-architecture">LAYERED ARCHITECTURE</a> 把领域层划分出来，通过应用层类来处理应用程序功能。应用层类是协调者，负责提问，领域层负责回答。</p>
<h3 id="将-entity-和-value-object-区分开">将 ENTITY 和 VALUE OBJECT 区分开<a href="#将-entity-和-value-object-区分开" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>依次考虑对象是必须跟踪的 ENTITY 还是表示一个 VALUE OBJECT。</p>
<h3 id="aggregate-边界">AGGREGATE 边界<a href="#aggregate-边界" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>识别模型中的 AGGREGATE 根和对应的边界。</p>
<h3 id="选择-repository">选择 REPOSITORY<a href="#选择-repository" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>为 AGGREGATE 根对象建立 REPOSITORY。</p>
<h3 id="场景走查">场景走查<a href="#场景走查" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>根据应用程序特性复核建模，进行场景走查，确保能够有效地解决应用问题。可以走查一些正常和异常业务场景进行复核。</p>
<h3 id="对象创建">对象创建<a href="#对象创建" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>如果对象复杂则创建单独的 FACTORY 类进行对象创建，简单对象可以直接在 AGGREGATE 根上通过 FACTORY METHOD 进行创建。</p>
<h3 id="停一下-重构">停一下，重构<a href="#停一下-重构" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>建模和设计需要经常进行重构：利用新知识来改进模型和设计。</p>
<h3 id="module-划分">MODULE 划分<a href="#module-划分" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>应该按照对象的意义来划分，其他任何划分方式都是错误的，包括：</p>
<ul>
<li>按模式划分</li>
<li>按照对象生命周期划分</li>
</ul>
<h2 id="通过重构发现深层模型">通过重构发现深层模型<a href="#通过重构发现深层模型" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>重构不应该停留在代码细节层面，还应当在模型设计层面随着对知识吸收的加深对模型进行重构，发现深层模型。</p>
<p>深层模型能够穿过领域表象，清楚地表达出领域专家们的主要关注点以及相关的知识。</p>
<h3 id="深层模型-柔性设计">深层模型/柔性设计<a href="#深层模型-柔性设计" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>在不断重构的过程中，设计本身也需要支持重构所带来变化。设计自身的某些特性就可以使其易于修改和使用。
每次对模型和代码所进行的修改能够反映出对领域的新理解，不断的重构能给系统最需要修改的地方增添灵活性，
并能找到简单快捷的方式来实现普通的功能。</p>
<p>「戴久的手套在手指关节处变得柔软；而其他部分已然硬实，可起到保护的作用。」反复的修改能让我们越来越接近柔性设计。</p>
<p>柔性设计除了便于修改，还有助于改进模型本身。<a href="/notes/notes/20210903080049-%E9%A2%86%E5%9F%9F%E6%A8%A1%E5%BC%8F/#模式-model-driven-design">MODEL-DRIVEN DESIGN</a> 需要以下两个方面支持：</p>
<ol>
<li>深层模型使设计更具表现力；</li>
<li>同时，当设计的灵活性可以让开发人员进行实验，而设计又能清晰的表达出领域含义时，能够将开发人员的深层理解反馈到整个模型发现的过程中。</li>
</ol>
<p>这应该是构建系统的基础。</p>
<h3 id="发现过程">发现过程<a href="#发现过程" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>支持不断重构、借用别人已经建好的模式。</p>
<h3 id="突破">突破<a href="#突破" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<h4 id="重构创造机遇">重构创造机遇<a href="#重构创造机遇" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h4>
<h4 id="关注根本-不要强行突破">关注根本：不要强行突破<a href="#关注根本-不要强行突破" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h4>
<h3 id="概念挖掘">概念挖掘<a href="#概念挖掘" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<h4 id="倾听语言">倾听语言<a href="#倾听语言" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h4>
<p>倾听领域专家的语言，思考并表达，观察领域专家的表情，判断自己是否找到了正确的概念（对象）。</p>
<h4 id="检查不足之处">检查不足之处<a href="#检查不足之处" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h4>
<p>积极与领域专家沟通，寻找丢失的概念。（注意领域专家的表情）</p>
<h4 id="思考矛盾之处">思考矛盾之处<a href="#思考矛盾之处" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h4>
<p>矛盾可以合理存在，但是一定要仔细思考两种对立的看法是如何同时应用于同一个外部实现的，这会给我们带来启示。</p>
<h4 id="查阅书记">查阅书记<a href="#查阅书记" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h4>
<p>通过解释基本概念和传统思想的书籍来寻找概念。</p>
<h4 id="尝试-再尝试">尝试，再尝试<a href="#尝试-再尝试" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h4>
<h3 id="为隐式概念建模">为隐式概念建模<a href="#为隐式概念建模" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<h4 id="显式的约束">显式的约束<a href="#显式的约束" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h4>
<p>约束通常式隐含的，将它们显式的表现出来可以极大地提高设计质量。约束有时自然的存在于对象或方法中。</p>
<h4 id="将过程建模为领域对象">将过程建模为领域对象<a href="#将过程建模为领域对象" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h4>
<p>建模方式：</p>
<ul>
<li>通过 <a href="/notes/notes/20210903080049-%E9%A2%86%E5%9F%9F%E6%A8%A1%E5%BC%8F/#模式-service">模式：SERVICE</a> 显式表达。</li>
<li>通过 STRATEGY 表达选择过程：选择变成选择不同的对象，不同对象表示不同的 STRATEGY。</li>
</ul>

      </div></div>

  

  


   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   
      
   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   
      
   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   


<hr>

  <div class="bl-section">
    <h4>Links to this note</h4>
    <div class="backlinks">
      <ul>
       
          <li><a href="/notes/notes/20210903080049-%E9%A2%86%E5%9F%9F%E6%A8%A1%E5%BC%8F/">领域模式</a></li>
       
          <li><a href="/notes/notes/20210814071825-%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/">领域驱动设计</a></li>
       
     </ul>
    </div>
  </div>


</div>

  </div>

  
    <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright">
        <span>© 2022 Powered by <a href="http://gohugo.io">Hugo</a></span>
    
        <span>:: Theme made by <a href="https://twitter.com/panr">panr</a></span>
      </div>
  </div>
</footer>

<script src="https://www.linuxzen.com/notes/assets/main.js"></script>
<script src="https://www.linuxzen.com/notes/assets/prism.js"></script>




<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.css" integrity="sha384-RZU/ijkSsFbcmivfdRBQDtwuwVqK7GMOw6IMvKyeWL2K5UAlyp6WonmB8m7Jd0Hn" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.js" integrity="sha384-pK1WpvzWVBQiP0/GjnvRxV4mOb0oxFuyRxJlk6vVw146n3egcN5C925NCP7a7BY8" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/contrib/auto-render.min.js" integrity="sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl" crossorigin="anonymous"
    onload="renderMathInElement(document.body);"></script>


  
</div>

</body>
</html>
