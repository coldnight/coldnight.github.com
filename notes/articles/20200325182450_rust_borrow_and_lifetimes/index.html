<!DOCTYPE html>
<html lang="en">
<head>
  
    <title>Rust Borrow and Lifetimes :: Taking Smart Notes With Org-mode</title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="tags: Rust,Translate,Rust Wrapper Types  原文链接：Rust Borrow and Lifetimes。
Rust 是一门处于往 1.0 活跃开发的新语言（译注：1.0 早已发布，目前最新稳定版本 1.42）。 我必须再写一篇关于我为什么觉得 Rust 牛逼的新博客，但是今天我将关注在它的借用（borrow） 和生命周期（lifetimes）系统，这也是常常让包括我在内的 Rust 新手陷入困境的地方。这篇文章假设 你基本了解 Rust，如果还没推荐你先阅读指南和指针指南。
资源所有权和借用 Rust 通过一个难缠的（sophisticated）借用系统在不用 GC 的情况下达到内存安全。对于任何资源 （栈内存、堆内存、文件句柄等），他们都对应一个唯一的所有者（owner）在需要的情况下处理资源回收。 你可以通过 &amp;amp; 或者 &amp;amp;mut 创建一个新的绑定指向该资源，这被称之为借用或可变借用。编译器确保 所有的所有者（owners）和借用者（borrowers）行为正确。
拷贝和转移（Copy and move） 在我们开始进入借用系统之前，我们需要知道 Rust 如何处理拷贝和转移。这个 StackOverflow 答案非常值得一读。 基本上，在赋值和函数调用上：
 如果值是可拷贝的（copyable）（仅涉及原始（primitive）类型，不涉及如内存或文件句柄的资源），编译器默认进行拷贝。 其他情况，编译器转移（moves）所有权（ownership）并使原来的绑定无效。  简而言之，POD（Plan Old Data） =&amp;gt; 拷贝，Non-POD（线性类型（linear types））=&amp;gt; 转移。
以下是一些额外的注释供你参考：
 Rust 拷贝像 C。每一个按值（by-value）使用一个值都是字节拷贝（通过 memcpy 浅拷贝），而不是语义上的拷贝或克隆。 如果想要让一个 POD 结构体变成不可拷贝的，你可以使用一个 NoCopy 标记，或者实现 Drop 特性（trait）。  转移之后，所有权就转移到了下一个所有者那。" />
<meta name="keywords" content="" />
<meta name="robots" content="noodp" />
<link rel="canonical" href="https://www.linuxzen.com/notes/articles/20200325182450_rust_borrow_and_lifetimes/" />




<link rel="stylesheet" href="https://www.linuxzen.com/notes/assets/style.css">






<link rel="apple-touch-icon" href="https://www.linuxzen.com/notes/img/apple-touch-icon-192x192.png">

  <link rel="shortcut icon" href="https://www.linuxzen.com/notes/img/favicon/orange.png">



<meta name="twitter:card" content="summary" />



<meta property="og:locale" content="en" />
<meta property="og:type" content="article" />
<meta property="og:title" content="Rust Borrow and Lifetimes">
<meta property="og:description" content="tags: Rust,Translate,Rust Wrapper Types  原文链接：Rust Borrow and Lifetimes。
Rust 是一门处于往 1.0 活跃开发的新语言（译注：1.0 早已发布，目前最新稳定版本 1.42）。 我必须再写一篇关于我为什么觉得 Rust 牛逼的新博客，但是今天我将关注在它的借用（borrow） 和生命周期（lifetimes）系统，这也是常常让包括我在内的 Rust 新手陷入困境的地方。这篇文章假设 你基本了解 Rust，如果还没推荐你先阅读指南和指针指南。
资源所有权和借用 Rust 通过一个难缠的（sophisticated）借用系统在不用 GC 的情况下达到内存安全。对于任何资源 （栈内存、堆内存、文件句柄等），他们都对应一个唯一的所有者（owner）在需要的情况下处理资源回收。 你可以通过 &amp;amp; 或者 &amp;amp;mut 创建一个新的绑定指向该资源，这被称之为借用或可变借用。编译器确保 所有的所有者（owners）和借用者（borrowers）行为正确。
拷贝和转移（Copy and move） 在我们开始进入借用系统之前，我们需要知道 Rust 如何处理拷贝和转移。这个 StackOverflow 答案非常值得一读。 基本上，在赋值和函数调用上：
 如果值是可拷贝的（copyable）（仅涉及原始（primitive）类型，不涉及如内存或文件句柄的资源），编译器默认进行拷贝。 其他情况，编译器转移（moves）所有权（ownership）并使原来的绑定无效。  简而言之，POD（Plan Old Data） =&amp;gt; 拷贝，Non-POD（线性类型（linear types））=&amp;gt; 转移。
以下是一些额外的注释供你参考：
 Rust 拷贝像 C。每一个按值（by-value）使用一个值都是字节拷贝（通过 memcpy 浅拷贝），而不是语义上的拷贝或克隆。 如果想要让一个 POD 结构体变成不可拷贝的，你可以使用一个 NoCopy 标记，或者实现 Drop 特性（trait）。  转移之后，所有权就转移到了下一个所有者那。" />
<meta property="og:url" content="https://www.linuxzen.com/notes/articles/20200325182450_rust_borrow_and_lifetimes/" />
<meta property="og:site_name" content="Taking Smart Notes With Org-mode" />

  
    <meta property="og:image" content="https://www.linuxzen.com/notes/img/favicon/orange.png">
  

<meta property="og:image:width" content="2048">
<meta property="og:image:height" content="1024">


  <meta property="article:published_time" content="2020-03-25 00:00:00 &#43;0800 &#43;0800" />












</head>
<body class="orange">


<div class="container center headings--one-size">

  <header class="header">
  <div class="header__inner">
    <div class="header__logo">
      <a href="https://www.linuxzen.com/notes/">
  <div class="logo">
    Terminal
  </div>
</a>

    </div>
    
      <div class="menu-trigger">menu</div>
    
  </div>
  
    <nav class="menu">
  <ul class="menu__inner menu__inner--desktop">
    
      
        
          <li><a href="/notes/projects/"> Projects in Progress</a></li>
        
      
        
          <li><a href="/notes/articles/">Articles</a></li>
        
      
        
          <li><a href="/notes/flashcards/">Flashcards</a></li>
        
      
        
          <li><a href="/notes/notes/">Notes</a></li>
        
      
        
          <li><a href="/notes/topics/">Topics</a></li>
        
      
      
    

    
  </ul>

  <ul class="menu__inner menu__inner--mobile">
    
      
        <li><a href="/notes/projects/"> Projects in Progress</a></li>
      
    
      
        <li><a href="/notes/articles/">Articles</a></li>
      
    
      
        <li><a href="/notes/flashcards/">Flashcards</a></li>
      
    
      
        <li><a href="/notes/notes/">Notes</a></li>
      
    
      
        <li><a href="/notes/topics/">Topics</a></li>
      
    
    
  </ul>
</nav>

  
</header>


  <div class="content">
    
<div class="post">
  <h1 class="post-title">
    <a href="https://www.linuxzen.com/notes/articles/20200325182450_rust_borrow_and_lifetimes/">Rust Borrow and Lifetimes</a></h1>
  <div class="post-meta">
    
      <span class="post-date">
        2020-03-25 
      </span>
    
    
    <span class="post-author">:: [Gray King]</span>
    
  </div>

  

  

  

  <div class="post-content"><div>
        <ul>
<li>tags: <a href="/notes/topics/20200307191429_rust/">Rust</a>,<a href="/notes/topics/20200309112105_translate/">Translate</a>,<a href="/notes/notes/20200325165657_rust_wrapper_types/">Rust Wrapper Types</a></li>
</ul>
<p>原文链接：<a href="http://arthurtw.github.io/2014/11/30/rust-borrow-lifetimes.html">Rust Borrow and Lifetimes</a>。</p>
<p>Rust 是一门处于往 1.0 活跃开发的新语言（译注：1.0 早已发布，目前最新稳定版本 <a href="https://github.com/rust-lang/rust/releases/tag/1.42.0">1.42</a>）。
我必须再写一篇关于我为什么觉得 Rust 牛逼的新博客，但是今天我将关注在它的借用（borrow）
和生命周期（lifetimes）系统，这也是常常让包括我在内的 Rust 新手陷入困境的地方。这篇文章假设
你基本了解 Rust，如果还没推荐你先阅读<a href="http://doc.rust-lang.org/guide.html">指南</a>和<a href="http://doc.rust-lang.org/guide-pointers.html">指针指南</a>。</p>
<h2 id="资源所有权和借用">资源所有权和借用<a href="#资源所有权和借用" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>Rust 通过一个难缠的（sophisticated）借用系统在不用 GC 的情况下达到内存安全。对于任何资源
（栈内存、堆内存、文件句柄等），他们都对应一个唯一的所有者（owner）在需要的情况下处理资源回收。
你可以通过 <code>&amp;</code> 或者 <code>&amp;mut</code> 创建一个新的绑定指向该资源，这被称之为借用或可变借用。编译器确保
所有的所有者（owners）和借用者（borrowers）行为正确。</p>
<h2 id="拷贝和转移-copy-and-move">拷贝和转移（Copy and move）<a href="#拷贝和转移-copy-and-move" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>在我们开始进入借用系统之前，我们需要知道 Rust 如何处理拷贝和转移。这个 <a href="https://stackoverflow.com/questions/24253344/is-it-possible-to-make-a-type-only-movable-and-not-copyable/24253573#24253573">StackOverflow 答案</a>非常值得一读。
基本上，在赋值和函数调用上：</p>
<ol>
<li>如果值是可拷贝的（copyable）（仅涉及原始（primitive）类型，不涉及如内存或文件句柄的资源），编译器默认进行拷贝。</li>
<li>其他情况，编译器转移（moves）所有权（ownership）并使原来的绑定无效。</li>
</ol>
<p>简而言之，POD（Plan Old Data） =&gt; 拷贝，Non-POD（线性类型（linear types））=&gt; 转移。</p>
<p>以下是一些额外的注释供你参考：</p>
<ul>
<li>Rust 拷贝像 C。每一个按值（by-value）使用一个值都是字节拷贝（通过 <code>memcpy</code> 浅拷贝），而不是语义上的拷贝或克隆。</li>
<li>如果想要让一个 POD 结构体变成不可拷贝的，你可以使用一个 <a href="http://doc.rust-lang.org/std/kinds/marker/struct.NoCopy.html">NoCopy</a> 标记，或者实现 <a href="http://doc.rust-lang.org/std/ops/trait.Drop.html">Drop</a> 特性（trait）。</li>
</ul>
<p>转移之后，所有权就转移到了下一个所有者那。</p>
<h2 id="资源回收">资源回收<a href="#资源回收" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>Rust 会在任何资源的所有权消失后立刻释放该资源，就这些，当：</p>
<ol>
<li>所有者超出作用域，或</li>
<li>正在持有的所有者改变绑定（原始绑定变成 void）。</li>
</ol>
<h2 id="所有者和借用者的权限-privileges-和限制">所有者和借用者的权限（privileges）和限制<a href="#所有者和借用者的权限-privileges-和限制" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>这一节基于 <a href="http://doc.rust-lang.org/guide.html">Rust Guide</a> 在权限（privileges）一部分提到拷贝和转移。</p>
<p>所有者有一些权限。它可以：</p>
<ol>
<li>控制资源回收。</li>
<li>借出资源，不可变的（可多次借用）或可变的（只能独占），和</li>
<li>交出所有权（通过转移）</li>
</ol>
<p>同时所有者也存在一些限制：</p>
<ol>
<li>
<p>不可变借用期间，所有者不能</p>
<p>a. 改变资源，或者</p>
<p>b. 以可变的方式借出资源。</p>
</li>
<li>
<p>可变借用期间所有者不能</p>
<p>a. 访问该资源，或者</p>
<p>b. 再次借出该资源。</p>
</li>
</ol>
<p>借用者同时也有一些权限。除了访问或者更改借用的资源外，借用者也可以进一步借出（share the borrow）：</p>
<ol>
<li>不可变借用者可以借出（拷贝）不可变借用（译注：再次以不可变借用借出）</li>
<li>可变借用者可以交出（转移）可变借用。（可变引用默认使用转移。）</li>
</ol>
<h2 id="代码示例">代码示例<a href="#代码示例" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>关于借用我们已经聊的够多了，让我们一起来看一些代码吧（你可以通过 <a href="https://play.rust-lang.org">https://play.rust-lang.org</a> 运行这些 Rust 代码。）
在下面所有的例子中，我们将使用不可拷贝的 <code>struct Foo</code> ，因为它包含了一个装箱（boxed）（堆分配）值。
使用不可拷贝资源可以限制相关操作，让我们更好的学习。</p>
<p>对于每一个代码示例，我们还提供了一个“作用域图表”（scope chart）来展示所有者和借用者的作用域。
图表第一行的大括号和代码中的大括号一一对应。</p>
<h3 id="所有者在可变借用期间不能访问资源">所有者在可变借用期间不能访问资源<a href="#所有者在可变借用期间不能访问资源" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>如果我们将代码中的 <code>println!</code> 解除注释，代码将不能编译：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Foo</span> {
	f: Box<span style="color:#f92672">&lt;</span>int<span style="color:#f92672">&gt;</span>,
}

<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> a <span style="color:#f92672">=</span> Foo { f: <span style="color:#a6e22e">box</span> <span style="color:#ae81ff">0</span> };
	<span style="color:#75715e">// mutable borrow
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">let</span> x <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> a;
	<span style="color:#75715e">// error: cannot borrow `a.f` as immutable because `a` is also borrowed as mutable
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// println!(&#34;{}&#34;, a.f);
</span><span style="color:#75715e"></span>}
</code></pre></div><pre tabindex="0"><code class="language-nil" data-lang="nil">		   { a x * }
   owner a   |_____|
borrower x     |___| x = &amp;mut a
access a.f       |   error
</code></pre><p>这违反了所有者限制 #2(a)。如果我们将 <code>let x = &amp;mut a;</code> 在一个嵌套的代码块里：借用
在 <code>println!</code> 之前结束，这段代码将能正常工作：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> a <span style="color:#f92672">=</span> Foo { f: <span style="color:#a6e22e">box</span> <span style="color:#ae81ff">0</span> };
	{
		<span style="color:#75715e">// mutable borrow
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">let</span> x <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> a;
		<span style="color:#75715e">// mutable borrow ends here
</span><span style="color:#75715e"></span>	}
	println!(<span style="color:#e6db74">&#34;{}&#34;</span>, a.f);
}
</code></pre></div><pre tabindex="0"><code class="language-nil" data-lang="nil">		   { a { x } * }
   owner a   |_________|
borrower x       |_|     x = &amp;mut a
access a.f           |   OK
</code></pre><h3 id="借用者可以转移可变借用到一个新的借用者">借用者可以转移可变借用到一个新的借用者<a href="#借用者可以转移可变借用到一个新的借用者" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>这段代码展示借用者的权限 #2: 可变借用 <code>x</code> 可以将所有权转移可变借用到一个新的借用者 <code>y</code> 。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> a <span style="color:#f92672">=</span> Foo { f: <span style="color:#a6e22e">box</span> <span style="color:#ae81ff">0</span> };
	<span style="color:#75715e">// mutable borrow
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">let</span> x <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> a;
	<span style="color:#75715e">// move the mutable borrow to new borrower y
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">let</span> y <span style="color:#f92672">=</span> x;
	<span style="color:#75715e">// error: use of moved value: `x.f`
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// println!(&#34;{}&#34;, x.f);
</span><span style="color:#75715e"></span>}
</code></pre></div><pre tabindex="0"><code class="language-nil" data-lang="nil">		   { a x y * }
   owner a   |_______|
borrower x     |_|     x = &amp;mut a
borrower y       |___| y = x
access x.f         |   error
</code></pre><p>转移之后，原始的借用者 <code>x</code> 不再能访问借用的资源。</p>
<h2 id="借用作用域-borrow-scope">借用作用域（Borrow scope）<a href="#借用作用域-borrow-scope" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>如果我们开始传递引用（ <code>&amp;</code> 和 <code>&amp;mut</code>）事情就开始变得有趣，同时也是 Rust 新手们开始困惑的地方。</p>
<h3 id="生命周期-lifetime">生命周期（Lifetime）<a href="#生命周期-lifetime" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>在整个借用过程中，知道借用者的借用什么时候开始和结束非常重要。在<a href="http://doc.rust-lang.org/guide-lifetimes.html">生命周期指南</a>中是这样定义生命周期的：</p>
<blockquote>
<p>A lifetime is a static approximation of the span of execution during which the pointer is valid: it always corresponds to some expression or block within the program.</p>
</blockquote>
<!-- raw HTML omitted -->
<blockquote>
<p>生命周期是指针有效范围的静态近似值：它始终对应程序中的某些表达式或代码块。</p>
</blockquote>
<p>然而，我更喜欢使用 <strong>借用作用域（borrow scope）</strong> 这个术语去描述借用生效的作用域。请注意它不同于上面生命周期的定义。
（我第一次见到这个术语是在一个 Rust <a href="https://github.com/rust-lang/rfcs/pull/431">RFC 讨论</a> 中，尽管我的定义可能会有所不同。）我会在稍后给出我为什么避免使用生命周期的原因。
现在我们先把生命周期放在一边。</p>
<h3 id="and-borrow">&amp; = borrow<a href="#and-borrow" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>一些关于借用的事情：</p>
<p>首先，只需要记住 <code>&amp;</code> = 借用， <code>&amp;mut</code> = 可变借用。任何地方你看到一个 <code>&amp;</code> ，那就是一个借用。</p>
<p>其次，当一个 <code>&amp;</code> 出现在任何结构体中（在它的字段中）或者函数_闭包（返回值或者捕获的引用），结构体_函数/闭包就是一个借用者，
并且应用所有的借用规则。</p>
<p>再次，对于每一个借用，都存在一个所有者和一个或多个借用者。</p>
<h3 id="扩展借用作用域">扩展借用作用域<a href="#扩展借用作用域" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>一些关于借用作用域的事情：</p>
<p>首先，一个借用作用域：</p>
<ul>
<li>是一个借用生效的范围，并且</li>
<li>不一定是借用者的词法作用域，因为借用者可以扩展借用作用域（参见下面）。</li>
</ul>
<p>其次，借用者在赋值或者函数调用中可以通过拷贝（不可变借用）或者转移（可变借用）扩展借用作用域。
接收者（receiver）（可以是新的绑定、结构体、函数或者闭包）变成新的借用者。</p>
<p>再次，借用作用域是所有借用者作用域的并集，并且被借用的资源必须在整个借用作用域里有效。</p>
<h3 id="借用公式">借用公式<a href="#借用公式" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>根据最后一点，我们得到一个借用公式：</p>
<blockquote>
<p>资源作用域 &gt;= 借用作用域 = 所有借用者作用域的并集。</p>
</blockquote>
<h3 id="代码示例">代码示例<a href="#代码示例" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>让我们看一些扩展作用域的代码示例。结构体 <code>struct Foo</code> 和前面的一样：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> a <span style="color:#f92672">=</span> Foo { f: <span style="color:#a6e22e">box</span> <span style="color:#ae81ff">0</span> };
	<span style="color:#66d9ef">let</span> y: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">Foo</span>;
	<span style="color:#66d9ef">if</span> <span style="color:#66d9ef">false</span> {
		<span style="color:#75715e">// borrow
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">let</span> x <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>a;
		<span style="color:#75715e">// share the borrow with new borrower y, hence extend the borrow scope
</span><span style="color:#75715e"></span>		y <span style="color:#f92672">=</span> x;
	}
	<span style="color:#75715e">// error: cannot assign to `a.f` because it is borrowed
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// a.f = box 1;
</span><span style="color:#75715e"></span>}
</code></pre></div><pre tabindex="0"><code class="language-nil" data-lang="nil">			 { a { x y } * }
  resource a   |___________|
  borrower x       |___|     x = &amp;a
  borrower y         |_____| y = x
borrow scope       |=======|
  mutate a.f             |   error
</code></pre><p>即使借用发生在 <code>if</code> 代码块之内并且借用者 <code>x</code> 在 <code>if</code> 代码块之后超出作用域，它已经通过赋值 <code>y=x;</code> 扩展了借用作用域，
所以存在两个借用者： <code>x</code> 和 <code>y</code> 。根据借用公式：借用作用域是借用者 <code>x</code> 和借用者 <code>y</code> 作用域的并集：
范围开始第一次借用于 <code>let x = &amp;a;</code> 直到 <code>main</code> 代码块的结尾。（注意绑定 <code>y</code> 在 <code>y=x;</code> 之前不是借用者。）</p>
<p>你可能注意到了由于条件永远是 false <code>if</code> 代码块永远不会执行，但是编译器始终拒绝资源所有者 <code>a</code> 去访问
它的资源。这是因为所有的借用检查发生在编译期，这样程序运行时就不需要做任何事情。</p>
<h2 id="借用多个资源">借用多个资源<a href="#借用多个资源" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>目前为止我们只关注借用单个资源。借用者可以借用多个资源吗？当然！比如一个函数可以接受两个引用然后
基于一些情况返回其中一个，e.g. 其中字段值比较大的那一个。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">max</span>(x: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">Foo</span>, y: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">Foo</span>) -&gt; <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">Foo</span>
</code></pre></div><p><code>max</code> 函数返回一个 <code>&amp;</code> 指针，因此它是一个借用者。返回的结果可以是输入参数的任意一个，所以它借用了
两鞥额资源。</p>
<h3 id="命名借用作用域-named-borrow-scope">命名借用作用域（Named borrow scope）<a href="#命名借用作用域-named-borrow-scope" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>当存在多个 <code>&amp;</code> 指针作为输入，我们需要使用 <strong>命名生命周期（named lifetimes）</strong> 指定它们之间的关系，
参见 <a href="http://doc.rust-lang.org/guide-lifetimes.html#named-lifetimes">Lifetimes Guide</a>。但现在，让我们叫它们 <strong>命名借用作用域（named borrow scopes）</strong> 。</p>
<p>上面的代码没有使用 <strong>命名生命周期</strong> 指定它们之间的关系是不会通过编译器的，i.e. 哪些借用者 <strong>分组（grouped）</strong>
到哪个借用作用域。下面的实现是合法的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">max</span><span style="color:#f92672">&lt;&#39;</span><span style="color:#a6e22e">a</span><span style="color:#f92672">&gt;</span>(x: <span style="color:#66d9ef">&amp;</span><span style="color:#f92672">&#39;</span><span style="color:#a6e22e">a</span> <span style="color:#a6e22e">Foo</span>, y: <span style="color:#66d9ef">&amp;</span><span style="color:#f92672">&#39;</span><span style="color:#a6e22e">a</span> <span style="color:#a6e22e">Foo</span>) -&gt; <span style="color:#66d9ef">&amp;</span><span style="color:#f92672">&#39;</span><span style="color:#a6e22e">a</span> <span style="color:#a6e22e">Foo</span> {
	<span style="color:#66d9ef">if</span> x.f <span style="color:#f92672">&gt;</span> y.f { x } <span style="color:#66d9ef">else</span> { y }
}
</code></pre></div><pre tabindex="0"><code class="language-nil" data-lang="nil">(All resources and borrowers are grouped in borrow scope 'a.)
				  max( {   } )
	resource *x &lt;--------------&gt;
	resource *y &lt;--------------&gt;
borrow scope 'a &lt;==============&gt;
	 borrower x        |___|
	 borrower y        |___|
   return value          |___|   pass to the caller
</code></pre><p>在这个函数中，我们有一个借用作用域 <code>'a</code> 和三个借用者：两个输入参数和函数返回结果。
前面提到的借用公式依然生效，但是现在每个被借用的资源必须满足公式。参见下面的例子：</p>
<h3 id="代码示例">代码示例<a href="#代码示例" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>在接下来的代码中，我们来使用上面的 <code>max</code> 函数在 <code>a</code> 和 <code>b</code> 之间选择一个更大 <code>Foo</code> ：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#66d9ef">let</span> a <span style="color:#f92672">=</span> Foo { f: <span style="color:#a6e22e">box</span> <span style="color:#ae81ff">1</span> };
	<span style="color:#66d9ef">let</span> y: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">Foo</span>;
	<span style="color:#66d9ef">if</span> <span style="color:#66d9ef">false</span> {
		<span style="color:#66d9ef">let</span> b <span style="color:#f92672">=</span> Foo { f: <span style="color:#a6e22e">box</span> <span style="color:#ae81ff">0</span> };
		<span style="color:#66d9ef">let</span> x <span style="color:#f92672">=</span> max(<span style="color:#f92672">&amp;</span>a, <span style="color:#f92672">&amp;</span>b);
		<span style="color:#75715e">// error: `b` does not live long enough
</span><span style="color:#75715e"></span>		<span style="color:#75715e">// y = x;
</span><span style="color:#75715e"></span>	}
}
</code></pre></div><pre tabindex="0"><code class="language-nil" data-lang="nil">			  { a { b x (  ) y } }
   resource a   |________________| pass
   resource b       |__________|   fail
 borrow scope         |==========|
temp borrower            |_|       &amp;a
temp borrower            |_|       &amp;b
   borrower x         |________|   x = max(&amp;a, &amp;b)
   borrower y                |___| y = x
</code></pre><p>直到 <code>let x = max(&amp;a, &amp;b)</code> 都一些正常，因为 <code>&amp;a</code> 和 <code>&amp;b</code> 都是尽在表达式中有效的临时引用，
并且第三个借用 <code>x</code> 借用了两个资源（不管最终是 <code>a</code> 或 <code>b</code> ，对于借用检查器而言它都借用了）直到 <code>if</code>
块结束，所以借用作用域是从 <code>let x = max(&amp;a, &amp;b);</code> 到 <code>if</code> 块结尾。两个资源 <code>a</code> 和 <code>b</code> 在整个借用作用域
都有效,因此满足借用公式。</p>
<p>现在如果我们解除最后一个赋值 <code>y = x;</code> 的注释， <code>y</code> 变成第四个借用者，然后借用作用域被扩展到 <code>main</code>
块的结尾，导致资源 <code>b</code> 不能满足公式。</p>
<h2 id="结构体作为借用者">结构体作为借用者<a href="#结构体作为借用者" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>除了函数和闭包之外，一个结构体也可以通过其字段存储多个引用来借用多个资源。我们通过下面的一些例子
来看看借用公式如何生效的。我们来使用 <code>Link</code> 结构体来保存一个引用（不可变借用）：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Link</span><span style="color:#f92672">&lt;&#39;</span><span style="color:#a6e22e">a</span><span style="color:#f92672">&gt;</span> {
  link: <span style="color:#66d9ef">&amp;</span><span style="color:#f92672">&#39;</span><span style="color:#a6e22e">a</span> <span style="color:#a6e22e">Foo</span>,
}
</code></pre></div><h3 id="结构体借用多个资源">结构体借用多个资源<a href="#结构体借用多个资源" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>即使只有一个字段，结构体 <code>Link</code> 也可以借用多个资源：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#66d9ef">let</span> a <span style="color:#f92672">=</span> Foo { f: <span style="color:#a6e22e">box</span> <span style="color:#ae81ff">0</span> };
	<span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> x <span style="color:#f92672">=</span> Link { link: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">a</span> };
	<span style="color:#66d9ef">if</span> <span style="color:#66d9ef">false</span> {
		<span style="color:#66d9ef">let</span> b <span style="color:#f92672">=</span> Foo { f: <span style="color:#a6e22e">box</span> <span style="color:#ae81ff">1</span> };
		<span style="color:#75715e">// error: `b` does not live long enough
</span><span style="color:#75715e"></span>		<span style="color:#75715e">// x.link = &amp;b;
</span><span style="color:#75715e"></span>	}
}
</code></pre></div><pre tabindex="0"><code class="language-nil" data-lang="nil">			 { a x { b * } }
  resource a   |___________| pass
  resource b         |___|   fail
borrow scope     |=========|
  borrower x     |_________| x.link = &amp;a
  borrower x           |___| x.link = &amp;b
</code></pre><p>在上面例子中，借用者 <code>x</code> 从所有者 <code>a</code> 借用资源，借用作用域到 <code>main</code> 块的结尾。So far so good。
如果我们解除最后一个赋值 <code>x.link = &amp;b;</code> 的注释， <code>x</code> 也尝试从所有者 <code>b</code> 借用资源，这会让资源 <code>b</code>
不能满足借用公式。</p>
<h3 id="没有返回值的函数扩展借用作用域">没有返回值的函数扩展借用作用域<a href="#没有返回值的函数扩展借用作用域" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>一个没有返回值的函数同样也可以通过输出参数能扩展借用作用域。例如，这个函数 <code>store_foo</code> 接受一个
<code>Link</code> 的可变引用，然后存储一个引用（不可变借用）到 <code>Foo</code> 里：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">store_foo</span><span style="color:#f92672">&lt;</span><span style="color:#e6db74">&#39;a&#39;</span><span style="color:#f92672">&gt;</span>(x: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> Link<span style="color:#f92672">&lt;&#39;</span><span style="color:#a6e22e">a</span><span style="color:#f92672">&gt;</span>, y: <span style="color:#66d9ef">&amp;</span><span style="color:#f92672">&#39;</span><span style="color:#a6e22e">a</span> <span style="color:#a6e22e">Foo</span>) {
  x.link <span style="color:#f92672">=</span> y;
}
</code></pre></div><p>在接下来的代码中，被 <code>a</code> 所有的资源是被借用资源； <code>Link</code> 结构体被借用者 <code>x</code> 可变的引用着（i.e. <code>*x</code> 是借用者）；
借用作用域直到 <code>main</code> 块的结尾。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#66d9ef">let</span> a <span style="color:#f92672">=</span> Foo { f: <span style="color:#a6e22e">box</span> <span style="color:#ae81ff">0</span> };
	<span style="color:#66d9ef">let</span> x <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> Link { link: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">a</span> };
	<span style="color:#66d9ef">if</span> <span style="color:#66d9ef">false</span> {
		<span style="color:#66d9ef">let</span> b <span style="color:#f92672">=</span> Foo { f: <span style="color:#a6e22e">box</span> <span style="color:#ae81ff">1</span> };
		<span style="color:#75715e">// store_foo(x, &amp;b);
</span><span style="color:#75715e"></span>	}
}
</code></pre></div><pre tabindex="0"><code class="language-nil" data-lang="nil">			 { a x { b * } }
  resource a   |___________| pass
  resource b         |___|   fail
borrow scope     |=========|
 borrower *x     |_________| x.link = &amp;a
 borrower *x           |___| x.link = &amp;b
</code></pre><p>如果我们解除最后一个函数调用 <code>store_foo(x, &amp;b);</code> ,这个函数将会尝试将 <code>&amp;b</code> 存储到 <code>x.link</code> ，
将资源 <code>b</code> 作为另外一个被借用的资源，由于 <code>b</code> 的作用域没有覆盖整个借用作用域，导致不满足借用公式。</p>
<h3 id="多个借用作用域">多个借用作用域<a href="#多个借用作用域" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>一个函数中可以存在多个借用作用域。例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">superstore_foo</span><span style="color:#f92672">&lt;&#39;</span><span style="color:#a6e22e">a</span>, <span style="color:#f92672">&#39;</span><span style="color:#a6e22e">b</span><span style="color:#f92672">&gt;</span>(x: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> Link<span style="color:#f92672">&lt;&#39;</span><span style="color:#a6e22e">a</span><span style="color:#f92672">&gt;</span>, y: <span style="color:#66d9ef">&amp;</span><span style="color:#f92672">&#39;</span><span style="color:#a6e22e">a</span> <span style="color:#a6e22e">Foo</span>,
						  x2: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> Link<span style="color:#f92672">&lt;&#39;</span><span style="color:#a6e22e">b</span><span style="color:#f92672">&gt;</span>, y2: <span style="color:#66d9ef">&amp;</span><span style="color:#f92672">&#39;</span><span style="color:#a6e22e">b</span> <span style="color:#a6e22e">Foo</span>) {
	x.link <span style="color:#f92672">=</span> y;
	x2.link <span style="color:#f92672">=</span> y2;
}
</code></pre></div><p>这个的函数（可能不是特别有用）中，涉及两个不同的借用作用域。每个借用作用域都有它们自己的作用域公式要满足。</p>
<h2 id="为什么生命周期会造成困惑">为什么生命周期会造成困惑<a href="#为什么生命周期会造成困惑" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>最后，我想解释一下为什么我认为 Rust 借用系统使用 <strong>生命周期</strong> 术语会造成困惑（同时避免在这片博文中使用它）。</p>
<p>当我们讨论借用时会涉及到不同类型的“生命周期”：</p>
<p>A. 资源所有者的生命周期（或者 被所有/被借用 资源
B. 被借用的生命周期，i.e. 从开始借用到最后返还
C. 每一个独立的借用者或被借用的指针的生命周期</p>
<p>当有人说“生命周期”，它可以指上面的任何一个。如果涉及多个资源和借用者就会变的更加困惑。
比如，在函数或者结构体生命中一个“命名的生命周期”指哪个？是 A、B 或者 C？</p>
<p>在我们的前一个 <code>max</code> 函数中：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">max</span><span style="color:#f92672">&lt;&#39;</span><span style="color:#a6e22e">a</span><span style="color:#f92672">&gt;</span>(x: <span style="color:#66d9ef">&amp;</span><span style="color:#f92672">&#39;</span><span style="color:#a6e22e">a</span> <span style="color:#a6e22e">Foo</span>, y: <span style="color:#66d9ef">&amp;</span><span style="color:#f92672">&#39;</span><span style="color:#a6e22e">a</span> <span style="color:#a6e22e">Foo</span>) -&gt; <span style="color:#66d9ef">&amp;</span><span style="color:#f92672">&#39;</span><span style="color:#a6e22e">a</span> <span style="color:#a6e22e">Foo</span> {
	<span style="color:#66d9ef">if</span> x.f <span style="color:#f92672">&gt;</span> y.f { x } <span style="color:#66d9ef">else</span> { y }
}
</code></pre></div><p>生命周期 <code>'a</code> 的意义是什么？它不应该是 A，因为涉及两个资源并且他们有不同的生命周期。也不可能是 C，
因为有三个借用者： <code>x</code> 、 <code>y</code> 和函数的返回值，并且他们也都有不同的生命周期。它是 B 吗？可能。
但是整个借用作用域并不是一个具体的对象，它怎么能有一个“生命周期”呢？称它为生命周期就会造成困惑。</p>
<p>另一种说法是它意味着对被借用资源的最小生命周期要求。一定程度上是有道理的，
但是我们怎么称呼最小生命周期要求“生命周期”？</p>
<p>所有权/借用概念自身已经够复杂了。我会说：对术语“生命周期”的困惑对学习这个概念造成了更多的莫名其妙。</p>
<p>P.S. 使用上面定义的 A、B 和 C，借用公式变成：</p>
<blockquote>
<p>A &gt;= B = C_1,UC_2U&hellip;UC_n</p>
</blockquote>
<h2 id="学习-rust-是值得的">学习 Rust 是值得的！<a href="#学习-rust-是值得的" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>尽管借用和所有权可能让你花一些时间来掌握（to grok），但是是一个非常有趣的学习。Rust 尝试不用 GC
来实现内存安全，并且目前来看做的非常好。一些人说他们通过学习 Haskell 改变了他们编程的方式。
我认为Rust 同样也值得你学习。</p>
<p>希望这篇博文能提供一些帮助。</p>

      </div></div>

  

  


   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   
      
   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   


<hr>

  <div class="bl-section">
    <h4>Links to this note</h4>
    <div class="backlinks">
      <ul>
       
          <li><a href="/notes/notes/20200629180413-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/">生命周期</a></li>
       
     </ul>
    </div>
  </div>


</div>

  </div>

  
    <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright">
        <span>© 2022 Powered by <a href="http://gohugo.io">Hugo</a></span>
    
        <span>:: Theme made by <a href="https://twitter.com/panr">panr</a></span>
      </div>
  </div>
</footer>

<script src="https://www.linuxzen.com/notes/assets/main.js"></script>
<script src="https://www.linuxzen.com/notes/assets/prism.js"></script>




<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.css" integrity="sha384-RZU/ijkSsFbcmivfdRBQDtwuwVqK7GMOw6IMvKyeWL2K5UAlyp6WonmB8m7Jd0Hn" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.js" integrity="sha384-pK1WpvzWVBQiP0/GjnvRxV4mOb0oxFuyRxJlk6vVw146n3egcN5C925NCP7a7BY8" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/contrib/auto-render.min.js" integrity="sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl" crossorigin="anonymous"
    onload="renderMathInElement(document.body);"></script>


  
</div>

</body>
</html>
