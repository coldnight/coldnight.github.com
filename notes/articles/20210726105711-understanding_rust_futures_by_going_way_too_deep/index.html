<!DOCTYPE html>
<html lang="zh-cn">
<title>Understanding Rust futures by going way too deep | Taking Smart Notes With Org-mode</title>
<meta charset="utf-8">
<meta name="generator" content="Hugo 0.83.1" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="https://www.linuxzen.com/notes/css/index.css">
<link rel="stylesheet" href="https://www.linuxzen.com/notes/css/classes.css">
<link rel="canonical" href="https://www.linuxzen.com/notes/articles/20210726105711-understanding_rust_futures_by_going_way_too_deep/">
<link rel="alternate" type="application/rss+xml" href="" title="Taking Smart Notes With Org-mode">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css" integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js" integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js" integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous" onload="renderMathInElement(document.body);"></script>


<body>

<header class="icons">
  
    <a href="https://www.linuxzen.com/notes/">Taking Smart Notes With Org-mode</a>
  
  
    <nav>
    
      <a href="/notes/articles/notes/" >
        
           Topics
        
      </a>
    
      <a href="/notes/articles/" >
        
          Articles
        
      </a>
    
      <a href="/notes/notes/" >
        
          Notes
        
      </a>
    
    </nav>
  
  
</header>

<article>
  <header>
    <h1>Understanding Rust futures by going way too deep</h1>
    <time datetime="2021-07-26T10:57:00&#43;08:00">July 26, 2021</time>
  </header>
  <p>原文链接：<a href="https://fasterthanli.me/articles/understanding-rust-futures-by-going-way-too-deep">Understanding Rust futures by going way too deep</a>。</p>
<p>译者注：原文大量的引入了有趣的对话，迫于排版问题这里不进行翻译，必要的对话通过引用块来解释。</p>
<h2 id="深入理解-rust-future">深入理解 Rust future</h2>
<p>用 Rust future！就是这么简单！直到我们发现并非如此。所以我们先探索简单的部分，然后继续探索困难部分而不是等它慢慢靠近我们。</p>
<h2 id="起步">起步</h2>
<blockquote>
<p>Choo choo here comes the easy part 🚂💨</p>
</blockquote>
<p>我们创建一个新的项目：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">$ cargo new waytoodeep
     Created binary <span style="color:#f92672">(</span>application<span style="color:#f92672">)</span> <span style="color:#e6db74">`</span>waytoodeep<span style="color:#e6db74">`</span> package
</code></pre></div><p>我们需要安装 <code>cargo-edit</code> 如果之前没有安装过的话，接下来就可以直接 <code>cargo add</code> ：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">$ cargo install cargo-edit
    Updating crates.io index
  Downloaded cargo-edit v0.7.0
  Downloaded <span style="color:#ae81ff">1</span> crate <span style="color:#f92672">(</span>57.6 KB<span style="color:#f92672">)</span> in 0.47s
     Ignored package <span style="color:#e6db74">`</span>cargo-edit v0.7.0<span style="color:#e6db74">`</span> is already installed, use --force to override
</code></pre></div><blockquote>
<p>因为 <code>cargo-edit</code> 真的很方便，所以你可能已经安装过它。部分读者会感到困惑是因为像
<code>cargo new</code>, <code>cargo build</code>, <code>cargo test</code>, <code>cargo run</code> 等子命令都内置在 cargo 中，
但是 <code>cargo add</code> 没有。</p>
<p>实际上，有一大堆像这样的包，如 <a href="https://lib.rs/crates/cargo-hack">cargo-hack</a>,<a href="https://lib.rs/crates/cargo-udeps">cargo-udeps</a>,<a href="https://lib.rs/crates/cargo-expand">cargo-expand</a>&hellip;<a href="https://lib.rs/keywords/cargo">等等</a>。</p>
</blockquote>
<p>然后我们需要选择一个「异步运行时」（async runtime），因为这些 future 对象不会轮询（poll）自己。。。
我们毫无理由的选择 tokio，唯一的原因是：过去几个月我一直在用它。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">$ cargo add tokio@1.9.0 --features full
    Updating <span style="color:#e6db74">&#39;https://github.com/rust-lang/crates.io-index&#39;</span> index
      Adding tokio v1.9.0 to dependencies with features: <span style="color:#f92672">[</span><span style="color:#e6db74">&#34;full&#34;</span><span style="color:#f92672">]</span>
</code></pre></div><p>然后我们修改 <code>main</code> 函数使用 tokio 默认执行器（executor）（ <code>cargo new</code> 为我们生成了一个 <code>main</code> 函数，但是这里并不能满足我们的需求）：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#75715e">// in `src/main.rs`
</span><span style="color:#75715e"></span>
<span style="color:#75715e">#[tokio::main]</span>
<span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;Hello from a (so far completely unnecessary) async runtime&#34;</span>);
}
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">$ cargo run                                                                                                                                                                                          3s 209ms
   Compiling waytoodeep v0.1.0 <span style="color:#f92672">(</span>/Users/wh/codes/rust/waytoodeep<span style="color:#f92672">)</span>
    Finished dev <span style="color:#f92672">[</span>unoptimized + debuginfo<span style="color:#f92672">]</span> target<span style="color:#f92672">(</span>s<span style="color:#f92672">)</span> in 3.47s
     Running <span style="color:#e6db74">`</span>target/debug/waytoodeep<span style="color:#e6db74">`</span>
Hello from a <span style="color:#f92672">(</span>so far completely unnecessary<span style="color:#f92672">)</span> async runtime
</code></pre></div><p>酷！</p>
<p>接下来让我们添加其他一些我喜欢在我的项目中使用的好东西。</p>
<p>首先，对于错误处理 - 我们编写程序就需要处理一堆不同库里不同的类型，如果能通过一个类型统一它们就会非常整洁。</p>
<p><a href="https://lib.rs/crates/eyre">eyre</a> 可以赋予我们这些（就像 <code>anyhow</code> ）！</p>
<p>并且因为我喜欢漂亮的颜色我将使用 <a href="https://lib.rs/crates/color-eyre">color-eyre</a>。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">$ cargo add color-eyre@0.5.11
    Updating <span style="color:#e6db74">&#39;https://github.com/rust-lang/crates.io-index&#39;</span> index
      Adding color-eyre v0.5.11 to dependencies
</code></pre></div><p>现在我们需要安装 <code>color-eyre</code> 作为默认的崩溃（panic）处理器，我悄悄修改了一些环境变量来默认输出 bracktraces。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">use</span> color_eyre::Report;

<span style="color:#75715e">#[tokio::main]</span>
<span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() -&gt; Result<span style="color:#f92672">&lt;</span>(), Report<span style="color:#f92672">&gt;</span> {
    setup()<span style="color:#f92672">?</span>;

    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;Hello from a (so far completely unnecessary) async runtime&#34;</span>);

    Ok(())
}

<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">setup</span>() -&gt; Result<span style="color:#f92672">&lt;</span>(), Report<span style="color:#f92672">&gt;</span> {
    <span style="color:#66d9ef">if</span> std::env::var(<span style="color:#e6db74">&#34;RUST_LIB_BACKTRACE&#34;</span>).is_err() {
        std::env::set_var(<span style="color:#e6db74">&#34;RUST_LIB_BACKTRACE&#34;</span>, <span style="color:#e6db74">&#34;1&#34;</span>)
    }
    color_eyre::install()<span style="color:#f92672">?</span>;

    Ok(())
}
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">$ cargo run
    Finished dev <span style="color:#f92672">[</span>unoptimized + debuginfo<span style="color:#f92672">]</span> target<span style="color:#f92672">(</span>s<span style="color:#f92672">)</span> in 0.02s
     Running <span style="color:#e6db74">`</span>target/debug/waytoodeep<span style="color:#e6db74">`</span>
Hello from a <span style="color:#f92672">(</span>so far completely unnecessary<span style="color:#f92672">)</span> async runtime
</code></pre></div><p>很好！现在如果我们某处出现了一个错误，我们将看到完整的堆栈跟踪，就像下面这样：
<img src="https://fasterthanli.me/content/articles/understanding-rust-futures-by-going-way-too-deep/assets/color-eyre.78931d5fc80841f6.webp" alt=""></p>
<p>最后，因为我喜欢结构化日志，让我们添加 <a href="https://lib.rs/crates/tracing">tracing</a> 然后通过漂亮的颜色打印它们，让我们添加 <a href="https://lib.rs/crates/tracing-subscriber">tracing-subscriber</a>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">$ cargo add tracing@0.1.26 tracing-subscriber@0.2.19
    Updating <span style="color:#e6db74">&#39;https://github.com/rust-lang/crates.io-index&#39;</span> index
      Adding tracing v0.1.26 to dependencies
      Adding tracing-subscriber v0.2.19 to dependencies
</code></pre></div><p>我们已经有一个 <code>setup</code> 函数，所以直接在那里安装 <code>tracing-subscriber</code>.. 然后我们将 <code>println!</code> 改成 <code>info!</code> ！
然后，为了演示如何设置让我们再次修改一些环境变量：对所有包（crates）默认 <code>info</code> 日志级别。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">use</span> color_eyre::Report;
<span style="color:#66d9ef">use</span> tracing::info;
<span style="color:#66d9ef">use</span> tracing_subscriber::EnvFilter;

<span style="color:#75715e">#[tokio::main]</span>
<span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() -&gt; Result<span style="color:#f92672">&lt;</span>(), Report<span style="color:#f92672">&gt;</span> {
    setup()<span style="color:#f92672">?</span>;

    info<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;Hello from a comfy nest we&#39;ve made for ourselves&#34;</span>);

    Ok(())
}

<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">setup</span>() -&gt; Result<span style="color:#f92672">&lt;</span>(), Report<span style="color:#f92672">&gt;</span> {
    <span style="color:#66d9ef">if</span> std::env::var(<span style="color:#e6db74">&#34;RUST_LIB_BACKTRACE&#34;</span>).is_err() {
        std::env::set_var(<span style="color:#e6db74">&#34;RUST_LIB_BACKTRACE&#34;</span>, <span style="color:#e6db74">&#34;1&#34;</span>)
    }
    color_eyre::install()<span style="color:#f92672">?</span>;

    <span style="color:#66d9ef">if</span> std::env::var(<span style="color:#e6db74">&#34;RUST_LOG&#34;</span>).is_err() {
        std::env::set_var(<span style="color:#e6db74">&#34;RUST_LOG&#34;</span>, <span style="color:#e6db74">&#34;info&#34;</span>)
    }
    tracing_subscriber::fmt::fmt()
        .with_env_filter(EnvFilter::from_default_env())
        .init();

    Ok(())
}
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">$ cargo run
    Finished dev <span style="color:#f92672">[</span>unoptimized + debuginfo<span style="color:#f92672">]</span> target<span style="color:#f92672">(</span>s<span style="color:#f92672">)</span> in 0.02s
     Running <span style="color:#e6db74">`</span>target/debug/waytoodeep<span style="color:#e6db74">`</span>
Jul <span style="color:#ae81ff">25</span> 17:03:46.993  INFO waytoodeep: Hello from a comfy nest we<span style="color:#960050;background-color:#1e0010">&#39;</span>ve made <span style="color:#66d9ef">for</span> ourselves
</code></pre></div><p>好了，我们准备好做一些有用的事情了。</p>
<h3 id="做一些有用的事情">做一些有用的事情</h3>
<p>当决定在咖啡间隙阅读哪一篇文章的时候，人们通常同时打开几个网站，然后读最先加载出来的那一篇。</p>
<p>事实如此。你可以引用我的话，毕竟谁会去验证呢？毕竟这听起来需要很多工作。</p>
<p>所以让我们来编写一个程序做相同的事情。</p>
<p>让我们引入 <a href="https://lib.rs/crates/reqwest">reqwest</a> &ndash; 尽管我不喜欢它的 API，但它会很好的完成接下来的工作。</p>
<p>同时，因为 <a href="https://www.openssl.org/news/vulnerabilities.html">screw OpenSSL</a> 我们将标记 reqwest 使用 <a href="https://lib.rs/crates/rustls">rustls</a>：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">$ cargo add reqwest@0.11.4 --no-default-features --features rustls-tls
    Updating <span style="color:#e6db74">&#39;https://github.com/rust-lang/crates.io-index&#39;</span> index
      Adding reqwest v0.11.4 to dependencies with features: <span style="color:#f92672">[</span><span style="color:#e6db74">&#34;rustls-tls&#34;</span><span style="color:#f92672">]</span>
</code></pre></div><p>我们准备好发送一个请求！</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">use</span> color_eyre::Report;
<span style="color:#66d9ef">use</span> tracing::info;
<span style="color:#66d9ef">use</span> tracing_subscriber::EnvFilter;
<span style="color:#66d9ef">use</span> reqwest::Client;

<span style="color:#75715e">#[tokio::main]</span>
<span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() -&gt; Result<span style="color:#f92672">&lt;</span>(), Report<span style="color:#f92672">&gt;</span> {
    setup()<span style="color:#f92672">?</span>;

    info<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;Hello from a comfy nest we&#39;ve made for ourselves&#34;</span>);

    <span style="color:#66d9ef">let</span> client <span style="color:#f92672">=</span> Client::new();
    <span style="color:#66d9ef">let</span> url <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;https://fasterthanli.me&#34;</span>;
    <span style="color:#75715e">// this will turn non-200 HTTP status codes into rust errors,
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// so the first `?` propagates &#34;we had a connection problem&#34; and
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// the second `?` propagates &#34;we had a chat with the server and they
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// were not pleased&#34;
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> res <span style="color:#f92672">=</span> client.get(url).send().<span style="color:#66d9ef">await</span><span style="color:#f92672">?</span>.error_for_status()<span style="color:#f92672">?</span>;
    info<span style="color:#f92672">!</span>(<span style="color:#f92672">%</span>url, content_type <span style="color:#f92672">=</span> <span style="color:#f92672">?</span>res.headers().get(<span style="color:#e6db74">&#34;content-type&#34;</span>), <span style="color:#e6db74">&#34;Got a response!&#34;</span>);


    Ok(())
}

<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">setup</span>() -&gt; Result<span style="color:#f92672">&lt;</span>(), Report<span style="color:#f92672">&gt;</span> {
    <span style="color:#66d9ef">if</span> std::env::var(<span style="color:#e6db74">&#34;RUST_LIB_BACKTRACE&#34;</span>).is_err() {
        std::env::set_var(<span style="color:#e6db74">&#34;RUST_LIB_BACKTRACE&#34;</span>, <span style="color:#e6db74">&#34;1&#34;</span>)
    }
    color_eyre::install()<span style="color:#f92672">?</span>;

    <span style="color:#66d9ef">if</span> std::env::var(<span style="color:#e6db74">&#34;RUST_LOG&#34;</span>).is_err() {
        std::env::set_var(<span style="color:#e6db74">&#34;RUST_LOG&#34;</span>, <span style="color:#e6db74">&#34;info&#34;</span>)
    }
    tracing_subscriber::fmt::fmt()
        .with_env_filter(EnvFilter::from_default_env())
        .init();

    Ok(())
}
</code></pre></div><p>出发了！</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">cargo run                                                                                                                                                                                          3s 662ms
   Compiling waytoodeep v0.1.0 <span style="color:#f92672">(</span>/Users/wh/codes/rust/waytoodeep<span style="color:#f92672">)</span>
    Finished dev <span style="color:#f92672">[</span>unoptimized + debuginfo<span style="color:#f92672">]</span> target<span style="color:#f92672">(</span>s<span style="color:#f92672">)</span> in 7.16s
     Running <span style="color:#e6db74">`</span>target/debug/waytoodeep<span style="color:#e6db74">`</span>
Jul <span style="color:#ae81ff">26</span> 16:50:57.778  INFO waytoodeep: Hello from a comfy nest we<span style="color:#960050;background-color:#1e0010">&#39;</span>ve made <span style="color:#66d9ef">for</span> ourselves
Jul <span style="color:#ae81ff">26</span> 16:50:59.090  INFO waytoodeep: Got a response! url<span style="color:#f92672">=</span>https://fasterthanli.me content_type<span style="color:#f92672">=</span>Some<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;text/html; charset=utf-8&#34;</span><span style="color:#f92672">)</span>
</code></pre></div><p>这就是我所说的「结构化日志」。嗯，其中的一部分。让我们看下这行代码：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust">info<span style="color:#f92672">!</span>(<span style="color:#f92672">%</span>url, content_type <span style="color:#f92672">=</span> <span style="color:#f92672">?</span>res.headers().get(<span style="color:#e6db74">&#34;content-type&#34;</span>), <span style="color:#e6db74">&#34;Got a response!&#34;</span>);
</code></pre></div><p>我们输出来一个消息： <code>Got a response!</code> ，一个名为 <code>url</code> 的标签：值为变量 <code>url</code> 的 <a href="https://doc.rust-lang.org/stable/std/fmt/trait.Display.html">Display</a> 格式，
一个名为 <code>content_type</code> 的标签：值为表达式的 <a href="https://doc.rust-lang.org/stable/std/fmt/trait.Debug.html">Debug</a> 格式。</p>
<p>就是这么简单！ <code>name = %value</code> 输出 <code>Display</code> ， <code>name = ?value</code> 输出 <code>Debug</code> 。</p>
<p>当然，还有非常棒的跨度（spans），重点是你可以将它们发送到 APM（Appliation Performance Monitoring），比如 Datadog 或者 Honeycomb 等，但是这不是一篇关于跟踪的文章。</p>
<p>为了举例说明，如果我们安装一个 JSON 的 tracing subscriber，我们将获得如下内容：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">$ cargo run
   Compiling waytoodeep v0.1.0 <span style="color:#f92672">(</span>/home/amos/ftl/waytoodeep<span style="color:#f92672">)</span>
    Finished dev <span style="color:#f92672">[</span>unoptimized + debuginfo<span style="color:#f92672">]</span> target<span style="color:#f92672">(</span>s<span style="color:#f92672">)</span> in 3.09s
     Running <span style="color:#e6db74">`</span>target/debug/waytoodeep<span style="color:#e6db74">`</span>
<span style="color:#f92672">{</span><span style="color:#e6db74">&#34;timestamp&#34;</span>:<span style="color:#e6db74">&#34;Jul 25 17:17:21.531&#34;</span>,<span style="color:#e6db74">&#34;level&#34;</span>:<span style="color:#e6db74">&#34;INFO&#34;</span>,<span style="color:#e6db74">&#34;fields&#34;</span>:<span style="color:#f92672">{</span><span style="color:#e6db74">&#34;message&#34;</span>:<span style="color:#e6db74">&#34;Hello from a comfy nest we&#39;ve made for ourselves&#34;</span><span style="color:#f92672">}</span>,<span style="color:#e6db74">&#34;target&#34;</span>:<span style="color:#e6db74">&#34;waytoodeep&#34;</span><span style="color:#f92672">}</span>
<span style="color:#f92672">{</span><span style="color:#e6db74">&#34;timestamp&#34;</span>:<span style="color:#e6db74">&#34;Jul 25 17:17:21.709&#34;</span>,<span style="color:#e6db74">&#34;level&#34;</span>:<span style="color:#e6db74">&#34;INFO&#34;</span>,<span style="color:#e6db74">&#34;fields&#34;</span>:<span style="color:#f92672">{</span><span style="color:#e6db74">&#34;message&#34;</span>:<span style="color:#e6db74">&#34;Got a response!&#34;</span>,<span style="color:#e6db74">&#34;url&#34;</span>:<span style="color:#e6db74">&#34;https://fasterthanli.me&#34;</span>,<span style="color:#e6db74">&#34;content_type&#34;</span>:<span style="color:#e6db74">&#34;Some(\&#34;text/html; charset=utf-8\&#34;)&#34;</span><span style="color:#f92672">}</span>,<span style="color:#e6db74">&#34;target&#34;</span>:<span style="color:#e6db74">&#34;waytoodeep&#34;</span><span style="color:#f92672">}</span>
</code></pre></div><p>这应该足以激起你的兴趣。</p>
<h3 id="同时获取两个地址">同时获取两个地址</h3>
<p>现在让我们获取两个地址：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">const</span> URL_1: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;https://fasterthanli.me/articles/whats-in-the-box&#34;</span>;
<span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">const</span> URL_2: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;https://fasterthanli.me/series/advent-of-code-2020/part-13&#34;</span>;
</code></pre></div><p>&hellip;&hellip;所以这是一个公平的比较。 这两篇文章都托管在我自己的网站上，绝对不是为了推广，而是为了使获取时间具有可比性，并且任一都有可能先加载完成（并且会随着时间的推移随机变化）。</p>
<p>我们将创建一个函数来获取内容：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">fetch_thing</span>(client: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">Client</span>, url: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>) -&gt; Result<span style="color:#f92672">&lt;</span>(), Report<span style="color:#f92672">&gt;</span> {
    <span style="color:#66d9ef">let</span> res <span style="color:#f92672">=</span> client.get(url).send().<span style="color:#66d9ef">await</span><span style="color:#f92672">?</span>.error_for_status()<span style="color:#f92672">?</span>;
    info<span style="color:#f92672">!</span>(<span style="color:#f92672">%</span>url, content_type <span style="color:#f92672">=</span> <span style="color:#f92672">?</span>res.headers().get(<span style="color:#e6db74">&#34;content-type&#34;</span>), <span style="color:#e6db74">&#34;Got a response!&#34;</span>);
    Ok(())
}
</code></pre></div><p>并使用它：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#75715e">#[tokio::main]</span>
<span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() -&gt; Result<span style="color:#f92672">&lt;</span>(), Report<span style="color:#f92672">&gt;</span> {
    setup()<span style="color:#f92672">?</span>;

    info<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;Hello from a comfy nest we&#39;ve made for ourselves&#34;</span>);

    <span style="color:#66d9ef">let</span> client <span style="color:#f92672">=</span> Client::new();
    fetch_thing(<span style="color:#f92672">&amp;</span>client, URL_1);
    fetch_thing(<span style="color:#f92672">&amp;</span>client, URL_2);

    Ok(())
}
</code></pre></div><p>然后运行它:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#75715e">$</span> cargo run
   Compiling waytoodeep v0.<span style="color:#ae81ff">1.0</span> (<span style="color:#f92672">/</span>home<span style="color:#f92672">/</span>amos<span style="color:#f92672">/</span>ftl<span style="color:#f92672">/</span>waytoodeep)
warning: <span style="color:#a6e22e">unused</span> implementer of <span style="color:#960050;background-color:#1e0010">`</span>Future<span style="color:#960050;background-color:#1e0010">`</span> that must be used
  <span style="color:#f92672">-</span>-&gt; <span style="color:#a6e22e">src</span><span style="color:#f92672">/</span>main.rs:<span style="color:#ae81ff">15</span>:<span style="color:#ae81ff">5</span>
   <span style="color:#f92672">|</span>
<span style="color:#ae81ff">15</span> <span style="color:#f92672">|</span>     fetch_thing(<span style="color:#f92672">&amp;</span>client, URL_1);
   <span style="color:#f92672">|</span>     <span style="color:#f92672">^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span>
   <span style="color:#f92672">|</span>
   <span style="color:#f92672">=</span> note: <span style="color:#960050;background-color:#1e0010">`</span><span style="color:#75715e">#[warn(unused_must_use)]</span><span style="color:#960050;background-color:#1e0010">`</span> on by default
   <span style="color:#f92672">=</span> note: <span style="color:#a6e22e">futures</span> <span style="color:#66d9ef">do</span> nothing unless you <span style="color:#960050;background-color:#1e0010">`</span>.<span style="color:#66d9ef">await</span><span style="color:#960050;background-color:#1e0010">`</span> or poll them

warning: <span style="color:#a6e22e">unused</span> implementer of <span style="color:#960050;background-color:#1e0010">`</span>Future<span style="color:#960050;background-color:#1e0010">`</span> that must be used
  <span style="color:#f92672">-</span>-&gt; <span style="color:#a6e22e">src</span><span style="color:#f92672">/</span>main.rs:<span style="color:#ae81ff">16</span>:<span style="color:#ae81ff">5</span>
   <span style="color:#f92672">|</span>
<span style="color:#ae81ff">16</span> <span style="color:#f92672">|</span>     fetch_thing(<span style="color:#f92672">&amp;</span>client, URL_2);
   <span style="color:#f92672">|</span>     <span style="color:#f92672">^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span>
   <span style="color:#f92672">|</span>
   <span style="color:#f92672">=</span> note: <span style="color:#a6e22e">futures</span> <span style="color:#66d9ef">do</span> nothing unless you <span style="color:#960050;background-color:#1e0010">`</span>.<span style="color:#66d9ef">await</span><span style="color:#960050;background-color:#1e0010">`</span> or poll them

warning: <span style="color:#ae81ff">2</span> warnings emitted

    Finished dev [unoptimized <span style="color:#f92672">+</span> debuginfo] target(s) <span style="color:#66d9ef">in</span> <span style="color:#ae81ff">3.01</span>s
     Running <span style="color:#960050;background-color:#1e0010">`</span>target<span style="color:#f92672">/</span>debug<span style="color:#f92672">/</span>waytoodeep<span style="color:#960050;background-color:#1e0010">`</span>
Jul <span style="color:#ae81ff">25</span> <span style="color:#ae81ff">17</span>:<span style="color:#ae81ff">26</span>:<span style="color:#ae81ff">31.571</span>  INFO waytoodeep: <span style="color:#a6e22e">Hello</span> from a comfy nest we<span style="color:#a6e22e">&#39;ve</span> made <span style="color:#66d9ef">for</span> ourselves
</code></pre></div><p>奇怪的是，没有任何事情发生。</p>
<blockquote>
<p>黄黄的波浪线和恼人的 Rust 警告已经给出了提示。</p>
</blockquote>
<p>让我们来修复它：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust">fetch_thing(<span style="color:#f92672">&amp;</span>client, URL_1).<span style="color:#66d9ef">await</span><span style="color:#f92672">?</span>;
fetch_thing(<span style="color:#f92672">&amp;</span>client, URL_2).<span style="color:#66d9ef">await</span><span style="color:#f92672">?</span>;
</code></pre></div><pre><code class="language-nil" data-lang="nil">$ cargo run
   Compiling waytoodeep v0.1.0 (/home/amos/ftl/waytoodeep)
    Finished dev [unoptimized + debuginfo] target(s) in 3.17s
     Running `target/debug/waytoodeep`
Jul 25 17:27:29.768  INFO waytoodeep: Hello from a comfy nest we've made for ourselves
Jul 25 17:27:29.891  INFO waytoodeep: Got a response! url=https://fasterthanli.me/articles/whats-in-the-box content_type=Some(&quot;text/html; charset=utf-8&quot;)
Jul 25 17:27:29.974  INFO waytoodeep: Got a response! url=https://fasterthanli.me/series/advent-of-code-2020/part-13 content_type=Some(&quot;text/html; charset=utf-8&quot;)
</code></pre><p>所以，第零课：future 对象不做任何事情直到它们被轮询（polled）。</p>
<p>这是因为 future 对象几乎就是状态。让我们来创建一个：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#75715e">// in `src/main.rs`
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">mod</span> dumb;
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#75715e">// in `src/dumb.rs`
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">use</span> std::{
    future::Future,
    pin::Pin,
    task::{Context, Poll},
};

<span style="color:#66d9ef">use</span> tracing::info;

<span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">DumbFuture</span> {}

<span style="color:#66d9ef">impl</span> Future <span style="color:#66d9ef">for</span> DumbFuture {
    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Output</span> <span style="color:#f92672">=</span> ();

    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">poll</span>(self: <span style="color:#a6e22e">Pin</span><span style="color:#f92672">&lt;&amp;</span><span style="color:#66d9ef">mut</span> Self<span style="color:#f92672">&gt;</span>, _cx: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> Context<span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;_</span><span style="color:#f92672">&gt;</span>) -&gt; <span style="color:#a6e22e">Poll</span><span style="color:#f92672">&lt;</span>Self::Output<span style="color:#f92672">&gt;</span> {
        info<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;Hello from a dumb future!&#34;</span>);
        Poll::Ready(())
    }
}
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#75715e">// back in `src/main.rs`
</span><span style="color:#75715e"></span>
<span style="color:#75715e">#[tokio::main]</span>
<span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() -&gt; Result<span style="color:#f92672">&lt;</span>(), Report<span style="color:#f92672">&gt;</span> {
    setup()<span style="color:#f92672">?</span>;

    <span style="color:#66d9ef">let</span> fut <span style="color:#f92672">=</span> dumb::DumbFuture {};

    Ok(())
}
</code></pre></div><p>以上！我们几乎就完成来除了我们没有 <code>.await</code> 。</p>
<p>运行它除了打印报警不会有任何效果：</p>
<pre><code class="language-nil" data-lang="nil">$ cargo run
   Compiling waytoodeep v0.1.0 (/home/amos/ftl/waytoodeep)
warning: unused variable: `fut`
  --&gt; src/main.rs:14:9
   |
14 |     let fut = dumb::DumbFuture {};
   |         ^^^ help: if this is intentional, prefix it with an underscore: `_fut`
   |
   = note: `#[warn(unused_variables)]` on by default

warning: 1 warning emitted

    Finished dev [unoptimized + debuginfo] target(s) in 2.11s
     Running `target/debug/waytoodeep`
</code></pre><p>因为怎么可能？我们字面上仅仅构建了一个结构体。一个零大小的结构体。</p>
<p>如果我们调用它的 <code>.await</code> 。。 然后当我们要求运行时运行它的事件循环直到 future 对象被轮询（polled）并且最终返回 <code>Poll::Ready</code> （我们的代码立即返回）：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#75715e">#[tokio::main]</span>
<span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() -&gt; Result<span style="color:#f92672">&lt;</span>(), Report<span style="color:#f92672">&gt;</span> {
    setup()<span style="color:#f92672">?</span>;

    info<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;Building that dumb future...&#34;</span>);
    <span style="color:#66d9ef">let</span> fut <span style="color:#f92672">=</span> dumb::DumbFuture {};
    info<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;Awaiting that dumb future...&#34;</span>);
    fut.<span style="color:#66d9ef">await</span>;
    info<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;Done awaiting that dumb future&#34;</span>);

    Ok(())
}

</code></pre></div><pre><code class="language-nil" data-lang="nil">$ cargo run
   Compiling waytoodeep v0.1.0 (/home/amos/ftl/waytoodeep)
    Finished dev [unoptimized + debuginfo] target(s) in 2.34s
     Running `target/debug/waytoodeep`
Jul 25 17:37:09.261  INFO waytoodeep: Building that dumb future...
Jul 25 17:37:09.261  INFO waytoodeep: Awaiting that dumb future...
Jul 25 17:37:09.261  INFO waytoodeep::dumb: Hello from a dumb future!
Jul 25 17:37:09.262  INFO waytoodeep: Done awaiting that dumb future
</code></pre><p>这里有一些略微的区别与 ECMAScript 的 <code>promise</code> ：即使它们压根没有被 await 其中包含的工作依然会被执行。</p>
<p>但是 Rust 的 future 对象仅仅是无聊的状态机，如果你故意制造麻烦就可以理解这个机制：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#75715e">// in `src/dumb.rs`
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">impl</span> Future <span style="color:#66d9ef">for</span> DumbFuture {
    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Output</span> <span style="color:#f92672">=</span> ();

    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">poll</span>(self: <span style="color:#a6e22e">Pin</span><span style="color:#f92672">&lt;&amp;</span><span style="color:#66d9ef">mut</span> Self<span style="color:#f92672">&gt;</span>, _cx: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> Context<span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;_</span><span style="color:#f92672">&gt;</span>) -&gt; <span style="color:#a6e22e">Poll</span><span style="color:#f92672">&lt;</span>Self::Output<span style="color:#f92672">&gt;</span> {
        panic<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;Oh heck no&#34;</span>);
    }
}
</code></pre></div><pre><code class="language-nil" data-lang="nil">$ RUST_BACKTRACE=1 cargo run
   Compiling waytoodeep v0.1.0 (/home/amos/ftl/waytoodeep)
    Finished dev [unoptimized + debuginfo] target(s) in 2.28s
     Running `target/debug/waytoodeep`
Jul 25 17:41:18.956  INFO waytoodeep: Building that dumb future...
Jul 25 17:41:18.956  INFO waytoodeep: Awaiting that dumb future...
The application panicked (crashed).
Message:  Oh heck no
Location: src/dumb.rs:14

  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ BACKTRACE ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
                                ⋮ 6 frames hidden ⋮
   7: &lt;waytoodeep::dumb::DumbFuture as core::future::future::Future&gt;::poll::h4a44780628f4c5f0
      at /home/amos/ftl/waytoodeep/src/dumb.rs:14
   8: waytoodeep::main::{{closure}}::h36de5a1f1f2a5c5b
      at /home/amos/ftl/waytoodeep/src/main.rs:17
   9: &lt;core::future::from_generator::GenFuture&lt;T&gt; as core::future::future::Future&gt;::poll::h20a96e082c7a581e
      at /home/amos/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/future/mod.rs:80
  10: tokio::park::thread::CachedParkThread::block_on::{{closure}}::hdf98cb3c7fdf3de4
      at /home/amos/.cargo/registry/src/github.com-1ecc6299db9ec823/tokio-1.9.0/src/park/thread.rs:263
  11: tokio::coop::with_budget::{{closure}}::h6a86a24a246e220f
      at /home/amos/.cargo/registry/src/github.com-1ecc6299db9ec823/tokio-1.9.0/src/coop.rs:106
  12: std::thread::local::LocalKey&lt;T&gt;::try_with::h2ce0ac27c85965b6
      at /home/amos/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/thread/local.rs:376
  13: std::thread::local::LocalKey&lt;T&gt;::with::hc449f38c9f65fb53
      at /home/amos/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/thread/local.rs:352
  14: tokio::coop::with_budget::h5db157bd1e95e0e8
      at /home/amos/.cargo/registry/src/github.com-1ecc6299db9ec823/tokio-1.9.0/src/coop.rs:99
  15: tokio::coop::budget::h7b57383f1255ac24
      at /home/amos/.cargo/registry/src/github.com-1ecc6299db9ec823/tokio-1.9.0/src/coop.rs:76
  16: tokio::park::thread::CachedParkThread::block_on::hece399485213b91c
      at /home/amos/.cargo/registry/src/github.com-1ecc6299db9ec823/tokio-1.9.0/src/park/thread.rs:263
  17: tokio::runtime::enter::Enter::block_on::h89e9882e539e82d3
      at /home/amos/.cargo/registry/src/github.com-1ecc6299db9ec823/tokio-1.9.0/src/runtime/enter.rs:151
  18: tokio::runtime::thread_pool::ThreadPool::block_on::h1a0186470c00ba70
      at /home/amos/.cargo/registry/src/github.com-1ecc6299db9ec823/tokio-1.9.0/src/runtime/thread_pool/mod.rs:71
  19: tokio::runtime::Runtime::block_on::h7c21d6989b86d606
      at /home/amos/.cargo/registry/src/github.com-1ecc6299db9ec823/tokio-1.9.0/src/runtime/mod.rs:452
  20: waytoodeep::main::hb4dd5ffd46a5c032
      at /home/amos/ftl/waytoodeep/src/main.rs:20
  21: core::ops::function::FnOnce::call_once::hc1fcc87431f77d25
      at /home/amos/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ops/function.rs:227
                                ⋮ 11 frames hidden ⋮

Run with COLORBT_SHOW_HIDDEN=1 environment variable to disable frame filtering.
Run with RUST_BACKTRACE=full to include source snippets.
</code></pre><p>上面堆栈跟踪如果加上颜色效果会更好，所以我希望你在本地做了相同的尝试，即使如此我们依然可以看到我们真正的 main 函数在 20 帧，然后往上，我们可以看到 <code>Runtime::block_on</code>  、一个线程池的东西、一些挂起（parked）的线程、thread-local（其他 TLS）、一个 <strong><strong>生成的</strong></strong> future（帧 9 和 8，也就是我们的 <code>async fn main</code> 的最终结果），最后是我们的 <code>DumbFuture</code> poll 方法（帧 7）。</p>
<p>帧 6 到 1 就是 <a href="https://doc.rust-lang.org/stable/std/panic/index.html">panic</a> 机制，再次完全超出本文讨论的范围。</p>
<p>但是请站起来，亲爱的观众，用你的手臂绕过这个装置，以确保没有障眼法，没有隐藏的线，没有。。。</p>
<p>。。。我要说的是对于异步堆栈跟踪没有“特殊处理”（special handling）。当然，这里我们崩溃了，但是仅仅是 Rust，操作系统甚至不知道我几乎避免了一场灾难。</p>
<p>但是我们可以制造更大的混乱，如果我们愿意使用 <code>unsafe</code> ：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">impl</span> Future <span style="color:#66d9ef">for</span> DumbFuture {
    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Output</span> <span style="color:#f92672">=</span> ();

    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">poll</span>(self: <span style="color:#a6e22e">Pin</span><span style="color:#f92672">&lt;&amp;</span><span style="color:#66d9ef">mut</span> Self<span style="color:#f92672">&gt;</span>, _cx: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> Context<span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;_</span><span style="color:#f92672">&gt;</span>) -&gt; <span style="color:#a6e22e">Poll</span><span style="color:#f92672">&lt;</span>Self::Output<span style="color:#f92672">&gt;</span> {
        <span style="color:#66d9ef">unsafe</span> {
            <span style="color:#f92672">*</span>(<span style="color:#ae81ff">0xF00D</span> <span style="color:#66d9ef">as</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">mut</span> <span style="color:#66d9ef">u64</span>) <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x0</span>;
        }
        unreachable<span style="color:#f92672">!</span>(); <span style="color:#75715e">// pinky promise
</span><span style="color:#75715e"></span>    }
}
</code></pre></div><p>然后就不会有一些列的崩溃处理来拯救我们：</p>
<pre><code class="language-nil" data-lang="nil">$ RUST_BACKTRACE=1 cargo run
   Compiling waytoodeep v0.1.0 (/home/amos/ftl/waytoodeep)
    Finished dev [unoptimized + debuginfo] target(s) in 2.18s
     Running `target/debug/waytoodeep`
Jul 25 17:46:53.926  INFO waytoodeep: Building that dumb future...
Jul 25 17:46:53.926  INFO waytoodeep: Awaiting that dumb future...
zsh: segmentation fault (core dumped)  RUST_BACKTRACE=1 cargo run
</code></pre><p>但是 GDB 可以：</p>
<pre><code class="language-nil" data-lang="nil">$ cargo build &amp;&amp; gdb --quiet --args ./target/debug/waytoodeep
    Finished dev [unoptimized + debuginfo] target(s) in 0.04s
Reading symbols from ./target/debug/waytoodeep...
warning: Missing auto-load script at offset 0 in section .debug_gdb_scripts
of file /home/amos/ftl/waytoodeep/target/debug/waytoodeep.
Use `info auto-load python-scripts [REGEXP]' to list them.
(gdb) r
Starting program: /home/amos/ftl/waytoodeep/target/debug/waytoodeep
[Thread debugging using libthread_db enabled]
Using host libthread_db library &quot;/lib/x86_64-linux-gnu/libthread_db.so.1&quot;.
[New Thread 0x7ffff7c28700 (LWP 129418)]
[New Thread 0x7ffff7a27700 (LWP 129419)]
[New Thread 0x7ffff7826700 (LWP 129420)]
[New Thread 0x7ffff7625700 (LWP 129421)]
[New Thread 0x7ffff7424700 (LWP 129422)]
[New Thread 0x7ffff7223700 (LWP 129423)]
[New Thread 0x7ffff7022700 (LWP 129424)]
[New Thread 0x7ffff6e1e700 (LWP 129425)]
[New Thread 0x7ffff6c1a700 (LWP 129426)]
[New Thread 0x7ffff6a16700 (LWP 129427)]
[New Thread 0x7ffff6812700 (LWP 129428)]
[New Thread 0x7ffff660e700 (LWP 129429)]
[New Thread 0x7ffff640a700 (LWP 129430)]
[New Thread 0x7ffff6206700 (LWP 129431)]
[New Thread 0x7ffff6002700 (LWP 129432)]
Jul 25 17:47:13.278  INFO waytoodeep: Building that dumb future...
Jul 25 17:47:13.279  INFO waytoodeep: Awaiting that dumb future...

Thread 1 &quot;waytoodeep&quot; received signal SIGSEGV, Segmentation fault.
&lt;waytoodeep::dumb::DumbFuture as core::future::future::Future&gt;::poll (self=..., _cx=0x7fffffffd690) at src/dumb.rs:15
15                  *(0xF00D as *mut u64) = 0x0;
(gdb) bt
#0  &lt;waytoodeep::dumb::DumbFuture as core::future::future::Future&gt;::poll (self=..., _cx=0x7fffffffd690) at src/dumb.rs:15
#1  0x00005555555ab3a3 in waytoodeep::main::{{closure}} () at src/main.rs:17
#2  0x00005555555adb29 in &lt;core::future::from_generator::GenFuture&lt;T&gt; as core::future::future::Future&gt;::poll (self=..., cx=0x7fffffffd690)
    at /home/amos/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/future/mod.rs:80
#3  0x00005555555adaa0 in tokio::park::thread::CachedParkThread::block_on::{{closure}} ()
    at /home/amos/.cargo/registry/src/github.com-1ecc6299db9ec823/tokio-1.9.0/src/park/thread.rs:263
#4  0x00005555555b1742 in tokio::coop::with_budget::{{closure}} (cell=0x7ffff7c2c412)
    at /home/amos/.cargo/registry/src/github.com-1ecc6299db9ec823/tokio-1.9.0/src/coop.rs:106
#5  0x00005555555a9f58 in std::thread::local::LocalKey&lt;T&gt;::try_with (self=0x555555925fc0, f=...)
    at /home/amos/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/thread/local.rs:376
#6  0x00005555555a9e3d in std::thread::local::LocalKey&lt;T&gt;::with (self=0x555555925fc0, f=...)
    at /home/amos/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/thread/local.rs:352
#7  0x00005555555ad7c8 in tokio::coop::with_budget (budget=..., f=...)
    at /home/amos/.cargo/registry/src/github.com-1ecc6299db9ec823/tokio-1.9.0/src/coop.rs:99
#8  tokio::coop::budget (f=...) at /home/amos/.cargo/registry/src/github.com-1ecc6299db9ec823/tokio-1.9.0/src/coop.rs:76
#9  tokio::park::thread::CachedParkThread::block_on (self=0x7fffffffd7a0, f=...)
    at /home/amos/.cargo/registry/src/github.com-1ecc6299db9ec823/tokio-1.9.0/src/park/thread.rs:263
#10 0x00005555555abcc9 in tokio::runtime::enter::Enter::block_on (self=0x7fffffffd7f0, f=...)
    at /home/amos/.cargo/registry/src/github.com-1ecc6299db9ec823/tokio-1.9.0/src/runtime/enter.rs:151
#11 0x00005555555acf2e in tokio::runtime::thread_pool::ThreadPool::block_on (self=0x7fffffffd908, future=...)
    at /home/amos/.cargo/registry/src/github.com-1ecc6299db9ec823/tokio-1.9.0/src/runtime/thread_pool/mod.rs:71
#12 0x00005555555b0dfd in tokio::runtime::Runtime::block_on (self=0x7fffffffd900, future=...)
    at /home/amos/.cargo/registry/src/github.com-1ecc6299db9ec823/tokio-1.9.0/src/runtime/mod.rs:452
#13 0x00005555555aa807 in waytoodeep::main () at src/main.rs:20
(gdb)
</code></pre><p>我们再次丢失了高亮颜色，这里可以看一下：
<img src="https://fasterthanli.me/content/articles/understanding-rust-futures-by-going-way-too-deep/assets/gdb-colors.b45af429c46a37d9.webp" alt=""></p>
<blockquote>
<p>译注：我在本地环境并没有通过 GDB 复现带高亮的堆栈跟踪，反而是通过 LLDB 可以看到高亮的堆栈跟踪。</p>
</blockquote>
<p>是不是很漂亮？</p>
<p>现在让我们回到正常有用的代码，移除所有关于自己实现的 future 代码： <code>src/dumb.rs</code> 和 <code>mod dumb</code> 。并使用一个获取 future 替代：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#75715e">#[tokio::main]</span>
<span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() -&gt; Result<span style="color:#f92672">&lt;</span>(), Report<span style="color:#f92672">&gt;</span> {
    setup()<span style="color:#f92672">?</span>;

    info<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;Building that fetch future...&#34;</span>);
    <span style="color:#66d9ef">let</span> client <span style="color:#f92672">=</span> Client::new();
    <span style="color:#66d9ef">let</span> fut <span style="color:#f92672">=</span> fetch_thing(<span style="color:#f92672">&amp;</span>client, URL_1);
    info<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;Awaiting that fetch future...&#34;</span>);
    fut.<span style="color:#66d9ef">await</span><span style="color:#f92672">?</span>;
    info<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;Done awaiting that fetch future&#34;</span>);

    Ok(())
}
</code></pre></div><pre><code class="language-nil" data-lang="nil">$ RUST_BACKTRACE=1 cargo run
   Compiling waytoodeep v0.1.0 (/home/amos/ftl/waytoodeep)
    Finished dev [unoptimized + debuginfo] target(s) in 2.99s
     Running `target/debug/waytoodeep`
Jul 25 17:51:49.281  INFO waytoodeep: Building that fetch future...
Jul 25 17:51:49.282  INFO waytoodeep: Awaiting that fetch future...
Jul 25 17:51:49.437  INFO waytoodeep: Got a response! url=https://fasterthanli.me/articles/whats-in-the-box content_type=Some(&quot;text/html; charset=utf-8&quot;)
Jul 25 17:51:49.438  INFO waytoodeep: Done awaiting that fetch future
</code></pre><p>有两种方式考虑我们的函数，一个是语法糖层：也就是 <code>async fn</code> ：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">fetch_thing</span>(client: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">Client</span>, url: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>) -&gt; Result<span style="color:#f92672">&lt;</span>(), Report<span style="color:#f92672">&gt;</span> {
    <span style="color:#66d9ef">let</span> res <span style="color:#f92672">=</span> client.get(url).send().<span style="color:#66d9ef">await</span><span style="color:#f92672">?</span>.error_for_status()<span style="color:#f92672">?</span>;
    info<span style="color:#f92672">!</span>(<span style="color:#f92672">%</span>url, content_type <span style="color:#f92672">=</span> <span style="color:#f92672">?</span>res.headers().get(<span style="color:#e6db74">&#34;content-type&#34;</span>), <span style="color:#e6db74">&#34;Got a response!&#34;</span>);
    Ok(())
}
</code></pre></div><p>然后是核心实现层：一个普通的 <code>fn</code> 仅用来返回一个 future 对象：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">use</span> std::future::Future;

<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">fetch_thing</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;a</span><span style="color:#f92672">&gt;</span>(
    client: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">&#39;a</span> Client,
    url: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">&#39;a</span> <span style="color:#66d9ef">str</span>,
) -&gt; <span style="color:#a6e22e">impl</span> Future<span style="color:#f92672">&lt;</span>Output <span style="color:#f92672">=</span> Result<span style="color:#f92672">&lt;</span>(), Report<span style="color:#f92672">&gt;&gt;</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">&#39;a</span> {
    <span style="color:#66d9ef">async</span> <span style="color:#66d9ef">move</span> {
        <span style="color:#66d9ef">let</span> res <span style="color:#f92672">=</span> client.get(url).send().<span style="color:#66d9ef">await</span><span style="color:#f92672">?</span>.error_for_status()<span style="color:#f92672">?</span>;
        info<span style="color:#f92672">!</span>(<span style="color:#f92672">%</span>url, content_type <span style="color:#f92672">=</span> <span style="color:#f92672">?</span>res.headers().get(<span style="color:#e6db74">&#34;content-type&#34;</span>), <span style="color:#e6db74">&#34;Got a response!&#34;</span>);
        Ok(())
    }
}
</code></pre></div><p>由于借用 <code>client</code> 和 <code>url</code> ，所以 <code>Future</code> 对象的存活时间不能超过两者，这也是为什么我会将上面两个生命周期命名为 <code>'a</code> ，
并且返回的值也是任意实现了 <code>Future</code> （通过 <code>Output</code> ）同时生命周期也是 <code>'a</code> 。</p>
<p>整个 <code>async move {}</code> 快也仅仅是“构建状态” &ndash; 等于一个实现了 <code>Future</code> 的类型。</p>
<p>我们只是无法命名它。</p>
<p>我们只能尽量获取它的描述：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">type_name_of</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>(_: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">T</span>) -&gt; <span style="color:#66d9ef">&amp;</span>&#39;static <span style="color:#66d9ef">str</span> {
    std::any::type_name::<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>()
}

<span style="color:#75715e">// in main
</span><span style="color:#75715e"></span>
<span style="color:#75715e">#[tokio::main]</span>
<span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() -&gt; Result<span style="color:#f92672">&lt;</span>(), Report<span style="color:#f92672">&gt;</span> {
    setup()<span style="color:#f92672">?</span>;

    info<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;Building that fetch future...&#34;</span>);
    <span style="color:#66d9ef">let</span> client <span style="color:#f92672">=</span> Client::new();
    <span style="color:#66d9ef">let</span> fut <span style="color:#f92672">=</span> fetch_thing(<span style="color:#f92672">&amp;</span>client, URL_1);
    info<span style="color:#f92672">!</span>(
        type_name <span style="color:#f92672">=</span> type_name_of(<span style="color:#f92672">&amp;</span>fut),
        <span style="color:#e6db74">&#34;That fetch future has a type..&#34;</span>
    );
    info<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;Awaiting that fetch future...&#34;</span>);
    fut.<span style="color:#66d9ef">await</span><span style="color:#f92672">?</span>;
    info<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;Done awaiting that fetch future&#34;</span>);

    Ok(())
}
</code></pre></div><pre><code class="language-nil" data-lang="nil">$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.05s
     Running `target/debug/waytoodeep`
Jul 25 18:00:39.774  INFO waytoodeep: Building that fetch future...
Jul 25 18:00:39.775  INFO waytoodeep: That fetch future has a type.. type_name=&quot;core::future::from_generator::GenFuture&lt;waytoodeep::fetch_thing::{{closure}}&gt;&quot;
Jul 25 18:00:39.775  INFO waytoodeep: Awaiting that fetch future...
Jul 25 18:00:39.882  INFO waytoodeep: Got a response! url=https://fasterthanli.me/articles/whats-in-the-box content_type=Some(&quot;text/html; charset=utf-8&quot;)
Jul 25 18:00:39.882  INFO waytoodeep: Done awaiting that fetch future
</code></pre><p>。。。但是等等，由于我们使用了 <code>async</code> 语法所以它是一个编译器生成的类型。某种意义上我们无法命名它也就意味这我们无法绑定这个对象，或者编写一个函数仅仅接受该类型。</p>
<p>为了让我们自己相信 future 对象在我们真正轮询它之前它不会做任何工作，我们可以打开 <code>reqwest</code> 的调试日志：</p>
<pre><code class="language-nil" data-lang="nil">$ RUST_LOG=info,reqwest=debug cargo run
   Compiling waytoodeep v0.1.0 (/home/amos/ftl/waytoodeep)
    Finished dev [unoptimized + debuginfo] target(s) in 3.07s
     Running `target/debug/waytoodeep`
Jul 25 18:05:07.384  INFO waytoodeep: Building that fetch future...
Jul 25 18:05:07.385  INFO waytoodeep: That fetch future has a type.. type_name=&quot;core::future::from_generator::GenFuture&lt;waytoodeep::fetch_thing::{{closure}}&gt;&quot;
Jul 25 18:05:07.385  INFO waytoodeep: Awaiting that fetch future...
Jul 25 18:05:07.385 DEBUG reqwest::connect: starting new connection: https://fasterthanli.me/
Jul 25 18:05:07.503 DEBUG reqwest::async_impl::client: response '200 OK' for https://fasterthanli.me/articles/whats-in-the-box
Jul 25 18:05:07.503  INFO waytoodeep: Got a response! url=https://fasterthanli.me/articles/whats-in-the-box content_type=Some(&quot;text/html; charset=utf-8&quot;)
Jul 25 18:05:07.503  INFO waytoodeep: Done awaiting that fetch future
</code></pre><p>甚至对于每一个包（crate），我们都可以通过监听 <a href="https://lib.rs/crates/hyper">hyper</a> 和 <a href="https://lib.rs/crates/h2">h2</a> 来观察：</p>
<pre><code class="language-nil" data-lang="nil">$ RUST_LOG=debug cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.04s
     Running `target/debug/waytoodeep`
Jul 25 18:05:59.973  INFO waytoodeep: Building that fetch future...
Jul 25 18:05:59.973  INFO waytoodeep: That fetch future has a type.. type_name=&quot;core::future::from_generator::GenFuture&lt;waytoodeep::fetch_thing::{{closure}}&gt;&quot;
Jul 25 18:05:59.973  INFO waytoodeep: Awaiting that fetch future...
Jul 25 18:05:59.974 DEBUG reqwest::connect: starting new connection: https://fasterthanli.me/
Jul 25 18:05:59.974 DEBUG hyper::client::connect::dns: resolving host=&quot;fasterthanli.me&quot;
Jul 25 18:05:59.989 DEBUG hyper::client::connect::http: connecting to 172.67.196.144:443
Jul 25 18:06:00.000 DEBUG hyper::client::connect::http: connected to 172.67.196.144:443
Jul 25 18:06:00.000 DEBUG rustls::client::hs: No cached session for DNSNameRef(&quot;fasterthanli.me&quot;)
Jul 25 18:06:00.000 DEBUG rustls::client::hs: Not resuming any session
Jul 25 18:06:00.016 DEBUG rustls::client::hs: Using ciphersuite TLS13_CHACHA20_POLY1305_SHA256
Jul 25 18:06:00.016 DEBUG rustls::client::tls13: Not resuming
Jul 25 18:06:00.017 DEBUG rustls::client::tls13: TLS1.3 encrypted extensions: [ServerNameAck, Protocols([PayloadU8([104, 50])])]
Jul 25 18:06:00.017 DEBUG rustls::client::hs: ALPN protocol is Some(b&quot;h2&quot;)
Jul 25 18:06:00.018 DEBUG h2::client: binding client connection
Jul 25 18:06:00.018 DEBUG h2::client: client connection bound
Jul 25 18:06:00.018 DEBUG h2::codec::framed_write: send frame=Settings { flags: (0x0), enable_push: 0, initial_window_size: 2097152, max_frame_size: 16384 }
Jul 25 18:06:00.019 DEBUG Connection{peer=Client}: h2::codec::framed_write: send frame=WindowUpdate { stream_id: StreamId(0), size_increment: 5177345 }
Jul 25 18:06:00.019 DEBUG hyper::client::pool: pooling idle connection for (&quot;https&quot;, fasterthanli.me)
Jul 25 18:06:00.020 DEBUG Connection{peer=Client}: h2::codec::framed_write: send frame=Headers { stream_id: StreamId(1), flags: (0x5: END_HEADERS | END_STREAM) }
Jul 25 18:06:00.029 DEBUG Connection{peer=Client}: rustls::client::tls13: Ticket saved
Jul 25 18:06:00.029 DEBUG Connection{peer=Client}: rustls::client::tls13: Ticket saved
Jul 25 18:06:00.029 DEBUG Connection{peer=Client}: h2::codec::framed_read: received frame=Settings { flags: (0x0), max_concurrent_streams: 256, initial_window_size: 65536, max_frame_size: 16777215 }
Jul 25 18:06:00.030 DEBUG Connection{peer=Client}: h2::codec::framed_write: send frame=Settings { flags: (0x1: ACK) }
Jul 25 18:06:00.030 DEBUG Connection{peer=Client}: h2::codec::framed_read: received frame=WindowUpdate { stream_id: StreamId(0), size_increment: 2147418112 }
Jul 25 18:06:00.041 DEBUG Connection{peer=Client}: h2::codec::framed_read: received frame=Settings { flags: (0x1: ACK) }
Jul 25 18:06:00.041 DEBUG Connection{peer=Client}: h2::proto::settings: received settings ACK; applying Settings { flags: (0x0), enable_push: 0, initial_window_size: 2097152, max_frame_size: 16384 }
Jul 25 18:06:00.120 DEBUG Connection{peer=Client}: h2::codec::framed_read: received frame=Headers { stream_id: StreamId(1), flags: (0x4: END_HEADERS) }
Jul 25 18:06:00.120 DEBUG Connection{peer=Client}: h2::codec::framed_read: received frame=Data { stream_id: StreamId(1) }
Jul 25 18:06:00.121 DEBUG reqwest::async_impl::client: response '200 OK' for https://fasterthanli.me/articles/whats-in-the-box
Jul 25 18:06:00.121  INFO waytoodeep: Got a response! url=https://fasterthanli.me/articles/whats-in-the-box content_type=Some(&quot;text/html; charset=utf-8&quot;)
Jul 25 18:06:00.121  INFO waytoodeep: Done awaiting that fetch future
Jul 25 18:06:00.121 DEBUG Connection{peer=Client}: h2::codec::framed_read: received frame=Data { stream_id: StreamId(1) }
Jul 25 18:06:00.122 DEBUG Connection{peer=Client}: h2::codec::framed_write: send frame=Reset { stream_id: StreamId(1), error_code: CANCEL }
Jul 25 18:06:00.122 DEBUG Connection{peer=Client}: h2::codec::framed_write: send frame=GoAway { error_code: NO_ERROR, last_stream_id: StreamId(0) }
Jul 25 18:06:00.122 DEBUG Connection{peer=Client}: h2::proto::connection: Connection::poll; connection error error=NO_ERROR
Jul 25 18:06:00.122 DEBUG Connection{peer=Client}: rustls::session: Sending warning alert CloseNotify
</code></pre><blockquote>
<p>上面出现了 rustls，并且使用了 TLS 1.3，作者做过<a href="https://www.youtube.com/watch?v=YHIiVsFybLA">一期视频</a>介绍过 TLS 1.3。</p>
</blockquote>
<p>这些应该足够说服你，除非你值相信内核所说的，所以让我们看看调用堆栈只为了更加确定。</p>
<p>我们在 <code>await</code> future 对象之前增加一秒钟的休眠：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">use</span> tokio::time::sleep;
<span style="color:#66d9ef">use</span> std::time::Duration;

<span style="color:#75715e">#[tokio::main]</span>
<span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() -&gt; Result<span style="color:#f92672">&lt;</span>(), Report<span style="color:#f92672">&gt;</span> {
    setup()<span style="color:#f92672">?</span>;

    info<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;Building that fetch future...&#34;</span>);
    <span style="color:#66d9ef">let</span> client <span style="color:#f92672">=</span> Client::new();
    <span style="color:#66d9ef">let</span> fut <span style="color:#f92672">=</span> fetch_thing(<span style="color:#f92672">&amp;</span>client, URL_1);
    info<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;Sleeping for a bit...&#34;</span>);
    sleep(Duration::from_secs(<span style="color:#ae81ff">1</span>)).<span style="color:#66d9ef">await</span>;
    info<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;Awaiting that fetch future...&#34;</span>);
    fut.<span style="color:#66d9ef">await</span><span style="color:#f92672">?</span>;
    info<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;Done awaiting that fetch future&#34;</span>);

    Ok(())
}
</code></pre></div><pre><code class="language-nil" data-lang="nil">$ cargo build &amp;&amp; strace -e 'connect' ./target/debug/waytoodeep
   Compiling waytoodeep v0.1.0 (/home/amos/ftl/waytoodeep)
    Finished dev [unoptimized + debuginfo] target(s) in 3.13s
Jul 25 18:09:36.595  INFO waytoodeep: Building that fetch future...
Jul 25 18:09:36.596  INFO waytoodeep: Sleeping for a bit...
Jul 25 18:09:37.599  INFO waytoodeep: Awaiting that fetch future...
connect(9, {sa_family=AF_INET, sin_port=htons(443), sin_addr=inet_addr(&quot;104.21.92.169&quot;)}, 16) = -1 EINPROGRESS (Operation now in progress)
Jul 25 18:09:37.720  INFO waytoodeep: Got a response! url=https://fasterthanli.me/articles/whats-in-the-box content_type=Some(&quot;text/html; charset=utf-8&quot;)
Jul 25 18:09:37.721  INFO waytoodeep: Done awaiting that fetch future
+++ exited with 0 +++
</code></pre><p>再次强调，附上会让显著提高上面信息的可读性，如果不让我选择它们的话我是非常喜欢高亮的。我本地看起来是这样的：
<img src="https://fasterthanli.me/content/articles/understanding-rust-futures-by-going-way-too-deep/assets/strace-colors.a4163f4bda179c2b.webp" alt="">
由于 <code>tracing-subscriber</code> 默认格式会输出时间戳，可以看到程序休眠了1分钟（外加3毫秒），而且只有我们真正调用 <code>await</code> 时我们的程序才会开始连接到托管文章的 CDN 节点。</p>
<p>好了！让我们再次尝试拉取两篇文章：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#75715e">#[tokio::main]</span>
<span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() -&gt; Result<span style="color:#f92672">&lt;</span>(), Report<span style="color:#f92672">&gt;</span> {
    setup()<span style="color:#f92672">?</span>;

    <span style="color:#66d9ef">let</span> client <span style="color:#f92672">=</span> Client::new();

    <span style="color:#66d9ef">let</span> fut1 <span style="color:#f92672">=</span> fetch_thing(<span style="color:#f92672">&amp;</span>client, URL_1);
    <span style="color:#66d9ef">let</span> fut2 <span style="color:#f92672">=</span> fetch_thing(<span style="color:#f92672">&amp;</span>client, URL_2);

    fut1.<span style="color:#66d9ef">await</span><span style="color:#f92672">?</span>;
    fut2.<span style="color:#66d9ef">await</span><span style="color:#f92672">?</span>;

    Ok(())
}
</code></pre></div><p>再次检查日志：</p>
<pre><code class="language-nil" data-lang="nil">$ RUST_LOG=info,reqwest=debug cargo run --quiet
Jul 25 18:31:47.396 DEBUG reqwest::connect: starting new connection: https://fasterthanli.me/
Jul 25 18:31:47.536 DEBUG reqwest::async_impl::client: response '200 OK' for https://fasterthanli.me/articles/whats-in-the-box
Jul 25 18:31:47.537  INFO waytoodeep: Got a response! url=https://fasterthanli.me/articles/whats-in-the-box content_type=Some(&quot;text/html; charset=utf-8&quot;)
Jul 25 18:31:47.627 DEBUG reqwest::async_impl::client: response '200 OK' for https://fasterthanli.me/series/advent-of-code-2020/part-13
Jul 25 18:31:47.627  INFO waytoodeep: Got a response! url=https://fasterthanli.me/series/advent-of-code-2020/part-13 content_type=Some(&quot;text/html; charset=utf-8&quot;)
</code></pre><p>非常有趣。从这里可以看到， <code>reqwest</code> 为两个请求复用了相同的连接。我会这么说是因我只看到了一行 <code>reqwest::connect</code> 日志。</p>
<p>让我们快速通过 <code>strace</code> 检查一下：</p>
<pre><code class="language-nil" data-lang="nil">$ cargo build --quiet &amp;&amp; strace -e 'connect' ./target/debug/waytoodeep &gt; /dev/null
connect(9, {sa_family=AF_INET, sin_port=htons(443), sin_addr=inet_addr(&quot;172.67.196.144&quot;)}, 16) = -1 EINPROGRESS (Operation now in progress)
+++ exited with 0 +++
</code></pre><p>现在足够明确了，只有一次连接。</p>
<p>但是，第一个请求完成后才开始了第二个请求。第一个耗费了 <code>536-396 = 140</code> 毫秒，但是第二个耗费了 <code>627-537 = 90</code> 毫秒！</p>
<blockquote>
<p>Emmm，现在我们运行构建的是 debug 版本不是吗？</p>
</blockquote>
<p>这是真的。我确信我们面临的是 IO 密集型，而不是 CPU 密集型。</p>
<p>debug 版本的构建绝对有一些额外的开销，但是我怀疑这里它不会太影响延迟。无论如何，让我们检查一下：
（注意 &ndash;release）</p>
<pre><code class="language-nil" data-lang="nil">$ RUST_LOG=info,reqwest=debug cargo run --quiet --release
Jul 25 18:34:59.211 DEBUG reqwest::connect: starting new connection: https://fasterthanli.me/
Jul 25 18:34:59.343 DEBUG reqwest::async_impl::client: response '200 OK' for https://fasterthanli.me/articles/whats-in-the-box
Jul 25 18:34:59.343  INFO waytoodeep: Got a response! url=https://fasterthanli.me/articles/whats-in-the-box content_type=Some(&quot;text/html; charset=utf-8&quot;)
Jul 25 18:34:59.427 DEBUG reqwest::async_impl::client: response '200 OK' for https://fasterthanli.me/series/advent-of-code-2020/part-13
Jul 25 18:34:59.427  INFO waytoodeep: Got a response! url=https://fasterthanli.me/series/advent-of-code-2020/part-13 content_type=Some(&quot;text/html; charset=utf-8&quot;)
</code></pre><p>我们计算一下延迟 <code>343-211 = 132ms</code> ， <code>427-343 = 84ms</code> 。</p>
<p>几毫秒的差异可能的解释是邻居打开了一个 YouTube 视频导致无线电波爆发，从而导致冲突（802.11 没有空中流量控制，全民自由（free-for-all））和重传。</p>
<p>或者另外一百万个原因。这也是我们不继续分析下的原因。</p>
<p>让我们回到文章的主题。</p>
<h3 id="等待第一个完成">等待第一个完成</h3>
<p>是的！等待第一个完成。所以我们如何让程序同时请求两个？</p>
<p>其实有一大堆方式！</p>
<p>例如，我们可以在一个执行器上执行（ <code>spawn</code> ）这些 future 对象，然后休眠一秒钟。1 秒钟足够了吧？</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#75715e">#[tokio::main]</span>
<span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() -&gt; Result<span style="color:#f92672">&lt;</span>(), Report<span style="color:#f92672">&gt;</span> {
    setup()<span style="color:#f92672">?</span>;

    <span style="color:#66d9ef">let</span> client <span style="color:#f92672">=</span> Client::new();

    <span style="color:#66d9ef">let</span> fut1 <span style="color:#f92672">=</span> fetch_thing(<span style="color:#f92672">&amp;</span>client, URL_1);
    tokio::spawn(fut1);
    <span style="color:#66d9ef">let</span> fut2 <span style="color:#f92672">=</span> fetch_thing(<span style="color:#f92672">&amp;</span>client, URL_2);
    tokio::spawn(fut2);

    tokio::time::sleep(Duration::from_secs(<span style="color:#ae81ff">1</span>)).<span style="color:#66d9ef">await</span>;

    Ok(())
}
</code></pre></div><pre><code class="language-nil" data-lang="nil">$ RUST_LOG=info,reqwest=debug cargo run --quiet --release
error[E0597]: `client` does not live long enough
  --&gt; src/main.rs:17:28
   |
17 |     let fut1 = fetch_thing(&amp;client, URL_1);
   |                ------------^^^^^^^--------
   |                |           |
   |                |           borrowed value does not live long enough
   |                argument requires that `client` is borrowed for `'static`
...
25 | }
   | - `client` dropped here while still borrowed

error: aborting due to previous error

For more information about this error, try `rustc --explain E0597`.
error: could not compile `waytoodeep`

To learn more, run the command again with --verbose.
</code></pre><p>额，除非我们不可以。不可以是因为。。。</p>
<blockquote>
<p>我们将「future 对象交给执行器执行」并将 future 对象转交给执行器，对吧？我们转移了它和它的内容的所有权。</p>
<p>然后即使我们不对其进行 <code>await</code> ，future 对象因为是「执行器需要做」的一部分依然会被执行，所以即使我们从 <code>main</code> 返回 future 对象也会被轮询（polled）。</p>
<p>但是如果我们从 <code>main</code> 返回，则整个程序都会退出。</p>
<p>这里也可以是任何函数（这里是 <code>main</code> ）。重要的是如果函数返回了但是 future 对象借用了部分数据将无法通过借用检查器。</p>
</blockquote>
<p>这让我很高兴，因为这意味着我们不会意外访问到一些被释放的资源：<a href="https://cve.mitre.org/cgi-bin/cvekey.cgi?keyword=use+after+free">UAF</a>。</p>
<p>这里我们的例子没有完成。</p>
<p>所以。。。我们需要解决这个问题。如果 <code>fetch_thing</code> 返回的 future 对象是 <code>'static</code> 的呢？或者它不借用任何东西？</p>
<p>程序现在看起来如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">use</span> std::future::Future;

<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">fetch_thing</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;a</span><span style="color:#f92672">&gt;</span>(
    client: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">&#39;a</span> Client,
    url: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">&#39;a</span> <span style="color:#66d9ef">str</span>,
) -&gt; <span style="color:#a6e22e">impl</span> Future<span style="color:#f92672">&lt;</span>Output <span style="color:#f92672">=</span> Result<span style="color:#f92672">&lt;</span>(), Report<span style="color:#f92672">&gt;&gt;</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">&#39;a</span> {
    <span style="color:#66d9ef">async</span> <span style="color:#66d9ef">move</span> {
        <span style="color:#66d9ef">let</span> res <span style="color:#f92672">=</span> client.get(url).send().<span style="color:#66d9ef">await</span><span style="color:#f92672">?</span>.error_for_status()<span style="color:#f92672">?</span>;
        info<span style="color:#f92672">!</span>(<span style="color:#f92672">%</span>url, content_type <span style="color:#f92672">=</span> <span style="color:#f92672">?</span>res.headers().get(<span style="color:#e6db74">&#34;content-type&#34;</span>), <span style="color:#e6db74">&#34;Got a response!&#34;</span>);
        Ok(())
    }
}
</code></pre></div><p>好吧，之前我们用了 <code>async fn</code> ，但是为了更加深入的理解，我们不得不放弃漂亮的语法。</p>
<p>但是幸运的是，这正是我们想要的：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">fetch_thing</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;a</span><span style="color:#f92672">&gt;</span>(
    client: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">&#39;a</span> Client,
    url: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">&#39;a</span> <span style="color:#66d9ef">str</span>,
<span style="color:#75715e">//                                                 👇
</span><span style="color:#75715e"></span>) -&gt; <span style="color:#a6e22e">impl</span> Future<span style="color:#f92672">&lt;</span>Output <span style="color:#f92672">=</span> Result<span style="color:#f92672">&lt;</span>(), Report<span style="color:#f92672">&gt;&gt;</span> <span style="color:#f92672">+</span> &#39;static {}
</code></pre></div><p>但是我们借用了 <code>client</code> 和 <code>url</code> 我们必须避免这个问题。</p>
<p>因为 <code>url</code> 本身就是常量，所以很容易解决：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">const</span> URL_1: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;https://fasterthanli.me/articles/whats-in-the-box&#34;</span>;
<span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">const</span> URL_2: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;https://fasterthanli.me/series/advent-of-code-2020/part-13&#34;</span>;
</code></pre></div><p>它们本身就是 <code>'static</code> 。所以我们只需要调整需要 <code>'static</code> 就行:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">fetch_thing</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;a</span><span style="color:#f92672">&gt;</span>(
    client: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">&#39;a</span> Client,
    <span style="color:#75715e">//       👇
</span><span style="color:#75715e"></span>    url: <span style="color:#66d9ef">&amp;</span>&#39;static <span style="color:#66d9ef">str</span>,
) -&gt; <span style="color:#a6e22e">impl</span> Future<span style="color:#f92672">&lt;</span>Output <span style="color:#f92672">=</span> Result<span style="color:#f92672">&lt;</span>(), Report<span style="color:#f92672">&gt;&gt;</span> <span style="color:#f92672">+</span> &#39;static {}
</code></pre></div><p>非常好！解决了一个生命周期，还剩下一个。</p>
<p>我们可以要求 <code>client</code> 的生命周期为 <code>'static</code> 。由于它是一个  <code>Client</code> 的引用，意味着 <code>Cleint</code> 本身也需要是 <code>'static</code> 生命周期。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">fetch_thing</span>(
    <span style="color:#75715e">//         👇
</span><span style="color:#75715e"></span>    client: <span style="color:#66d9ef">&amp;</span>&#39;static Client,
    url: <span style="color:#66d9ef">&amp;</span>&#39;static <span style="color:#66d9ef">str</span>,
) -&gt; <span style="color:#a6e22e">impl</span> Future<span style="color:#f92672">&lt;</span>Output <span style="color:#f92672">=</span> Result<span style="color:#f92672">&lt;</span>(), Report<span style="color:#f92672">&gt;&gt;</span> <span style="color:#f92672">+</span> &#39;static {}
</code></pre></div><p>由于它被 <code>main</code> 所有，额，我们可以，可以。。。可以泄漏它：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#75715e">#[tokio::main]</span>
<span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() -&gt; Result<span style="color:#f92672">&lt;</span>(), Report<span style="color:#f92672">&gt;</span> {
    setup()<span style="color:#f92672">?</span>;

    <span style="color:#66d9ef">let</span> client <span style="color:#f92672">=</span> Client::new();
    <span style="color:#66d9ef">let</span> leaked_client <span style="color:#f92672">=</span> Box::leak(Box::new(client));

    <span style="color:#66d9ef">let</span> fut1 <span style="color:#f92672">=</span> fetch_thing(leaked_client, URL_1);
    <span style="color:#66d9ef">let</span> fut2 <span style="color:#f92672">=</span> fetch_thing(leaked_client, URL_2);

    tokio::spawn(fut1);
    tokio::spawn(fut2);

    tokio::time::sleep(Duration::from_secs(<span style="color:#ae81ff">1</span>)).<span style="color:#66d9ef">await</span>;

    Ok(())
}
</code></pre></div><p>完美！没有生命周期的问题了。</p>
<p>仅仅将所有东西泄漏就行。看到没？你不需要 C！</p>
<pre><code class="language-nil" data-lang="nil">$ RUST_LOG=info,reqwest=debug cargo run --quiet --release
Jul 25 18:54:53.614 DEBUG reqwest::connect: starting new connection: https://fasterthanli.me/
Jul 25 18:54:53.614 DEBUG reqwest::connect: starting new connection: https://fasterthanli.me/
Jul 25 18:54:53.708 DEBUG reqwest::async_impl::client: response '200 OK' for https://fasterthanli.me/articles/whats-in-the-box
Jul 25 18:54:53.708  INFO waytoodeep: Got a response! url=https://fasterthanli.me/articles/whats-in-the-box content_type=Some(&quot;text/html; charset=utf-8&quot;)
Jul 25 18:54:53.733 DEBUG reqwest::async_impl::client: response '200 OK' for https://fasterthanli.me/series/advent-of-code-2020/part-13
Jul 25 18:54:53.733  INFO waytoodeep: Got a response! url=https://fasterthanli.me/series/advent-of-code-2020/part-13 content_type=Some(&quot;text/html; charset=utf-8&quot;)
</code></pre><p>非～～常有趣！</p>
<p>我们的两个请求肯定是并发的发出去了，我们之所以知道是因为从我的笔记本上请求我的网站大概耗时 80ms 到 140ms 之间，但是在日志中我们看到两个响应之间只有 ~25ms 的间隔。</p>
<p>我们还可以看到 <code>reqwest</code> 有连接池机制：同时创建了两个连接。可能是因为我们开始第二个连接的时候第一个请求的连接还没有建立完成。</p>
<p>也就意味着我们通过 <code>strace</code> 可以看到：</p>
<pre><code class="language-nil" data-lang="nil">$ cargo build --quiet --release &amp;&amp; strace -e 'connect' ./target/release/waytoodeep
Jul 25 18:58:16.425  INFO waytoodeep: Got a response! url=https://fasterthanli.me/articles/whats-in-the-box content_type=Some(&quot;text/html; charset=utf-8&quot;)
Jul 25 18:58:16.443  INFO waytoodeep: Got a response! url=https://fasterthanli.me/series/advent-of-code-2020/part-13 content_type=Some(&quot;text/html; charset=utf-8&quot;)
+++ exited with 0 +++
</code></pre><p>。。。两个 <code>connect</code> 调用！如我所料！</p>
<blockquote>
<p>谬论：一个 <code>connect</code> 调用都没看到？因为 Rust 构建 HTTP/2 请求的时候甚至都需要建立 TCP 连接。真是革命性的！</p>
</blockquote>
<p>这当然不是真的。可能在其他线程执行了？也许 <code>strace</code> 默认仅跟踪了主线程？</p>
<p>啊，对了， <code>-f</code> 可以跟踪所有「子进程」，就像大家知道的那样 Linux 线程仅仅是披了件风衣的进程（或者其他方式）。所以，让我们看一下：</p>
<pre><code class="language-nil" data-lang="nil">$ cargo build --quiet --release &amp;&amp; strace -f -e 'connect' ./target/release/waytoodeep
strace: Process 154612 attached
strace: Process 154613 attached
strace: Process 154614 attached
strace: Process 154615 attached
strace: Process 154616 attached
strace: Process 154617 attached
strace: Process 154618 attached
strace: Process 154619 attached
strace: Process 154620 attached
strace: Process 154621 attached
strace: Process 154622 attached
strace: Process 154623 attached
strace: Process 154624 attached
strace: Process 154625 attached
strace: Process 154626 attached
strace: Process 154627 attached
strace: Process 154628 attached
[pid 154627] connect(9, {sa_family=AF_UNIX, sun_path=&quot;/var/run/nscd/socket&quot;}, 110) = -1 ENOENT (No such file or directory)
[pid 154628] connect(10, {sa_family=AF_UNIX, sun_path=&quot;/var/run/nscd/socket&quot;}, 110) = -1 ENOENT (No such file or directory)
[pid 154627] connect(9, {sa_family=AF_UNIX, sun_path=&quot;/var/run/nscd/socket&quot;}, 110) = -1 ENOENT (No such file or directory)
[pid 154628] connect(9, {sa_family=AF_INET, sin_port=htons(53), sin_addr=inet_addr(&quot;127.0.0.53&quot;)}, 16) = 0
[pid 154627] connect(10, {sa_family=AF_INET, sin_port=htons(53), sin_addr=inet_addr(&quot;127.0.0.53&quot;)}, 16) = 0
[pid 154627] connect(9, {sa_family=AF_INET6, sin6_port=htons(0), sin6_flowinfo=htonl(0), inet_pton(AF_INET6, &quot;2606:4700:3034::6815:5ca9&quot;, &amp;sin6_addr), sin6_scope_id=0}, 28) = -1 ENETUNREACH (Network is unreachable)
[pid 154627] connect(9, {sa_family=AF_UNSPEC, sa_data=&quot;\0\0\0\0\0\0\0\0\0\0\0\0\0\0&quot;}, 16) = 0
[pid 154627] connect(9, {sa_family=AF_INET6, sin6_port=htons(0), sin6_flowinfo=htonl(0), inet_pton(AF_INET6, &quot;2606:4700:3031::ac43:c490&quot;, &amp;sin6_addr), sin6_scope_id=0}, 28) = -1 ENETUNREACH (Network is unreachable)
[pid 154627] connect(9, {sa_family=AF_UNSPEC, sa_data=&quot;\0\0\0\0\0\0\0\0\0\0\0\0\0\0&quot;}, 16) = 0
[pid 154627] connect(9, {sa_family=AF_INET, sin_port=htons(0), sin_addr=inet_addr(&quot;104.21.92.169&quot;)}, 16) = 0
[pid 154627] connect(9, {sa_family=AF_UNSPEC, sa_data=&quot;\0\0\0\0\0\0\0\0\0\0\0\0\0\0&quot;}, 16) = 0
[pid 154627] connect(9, {sa_family=AF_INET, sin_port=htons(0), sin_addr=inet_addr(&quot;172.67.196.144&quot;)}, 16) = 0
[pid 154628] connect(10, {sa_family=AF_INET6, sin6_port=htons(0), sin6_flowinfo=htonl(0), inet_pton(AF_INET6, &quot;2606:4700:3034::6815:5ca9&quot;, &amp;sin6_addr), sin6_scope_id=0}, 28) = -1 ENETUNREACH (Network is unreachable)
[pid 154628] connect(10, {sa_family=AF_UNSPEC, sa_data=&quot;\0\0\0\0\0\0\0\0\0\0\0\0\0\0&quot;}, 16) = 0
[pid 154628] connect(10, {sa_family=AF_INET6, sin6_port=htons(0), sin6_flowinfo=htonl(0), inet_pton(AF_INET6, &quot;2606:4700:3031::ac43:c490&quot;, &amp;sin6_addr), sin6_scope_id=0}, 28) = -1 ENETUNREACH (Network is unreachable)
[pid 154628] connect(10, {sa_family=AF_UNSPEC, sa_data=&quot;\0\0\0\0\0\0\0\0\0\0\0\0\0\0&quot;}, 16) = 0
[pid 154628] connect(10, {sa_family=AF_INET, sin_port=htons(0), sin_addr=inet_addr(&quot;104.21.92.169&quot;)}, 16) = 0
[pid 154628] connect(10, {sa_family=AF_UNSPEC, sa_data=&quot;\0\0\0\0\0\0\0\0\0\0\0\0\0\0&quot;}, 16) = 0
[pid 154628] connect(10, {sa_family=AF_INET, sin_port=htons(0), sin_addr=inet_addr(&quot;172.67.196.144&quot;)}, 16) = 0
[pid 154625] connect(9, {sa_family=AF_INET, sin_port=htons(443), sin_addr=inet_addr(&quot;104.21.92.169&quot;)}, 16) = -1 EINPROGRESS (Operation now in progress)
[pid 154626] connect(10, {sa_family=AF_INET, sin_port=htons(443), sin_addr=inet_addr(&quot;104.21.92.169&quot;)}, 16) = -1 EINPROGRESS (Operation now in progress)
Jul 25 19:00:53.862  INFO waytoodeep: Got a response! url=https://fasterthanli.me/articles/whats-in-the-box content_type=Some(&quot;text/html; charset=utf-8&quot;)
Jul 25 19:00:53.880  INFO waytoodeep: Got a response! url=https://fasterthanli.me/series/advent-of-code-2020/part-13 content_type=Some(&quot;text/html; charset=utf-8&quot;)
[pid 154628] +++ exited with 0 +++
[pid 154627] +++ exited with 0 +++
[pid 154618] +++ exited with 0 +++
[pid 154614] +++ exited with 0 +++
[pid 154612] +++ exited with 0 +++
[pid 154619] +++ exited with 0 +++
[pid 154617] +++ exited with 0 +++
[pid 154613] +++ exited with 0 +++
[pid 154615] +++ exited with 0 +++
[pid 154623] +++ exited with 0 +++
[pid 154616] +++ exited with 0 +++
[pid 154624] +++ exited with 0 +++
[pid 154621] +++ exited with 0 +++
[pid 154622] +++ exited with 0 +++
[pid 154626] +++ exited with 0 +++
[pid 154620] +++ exited with 0 +++
[pid 154625] +++ exited with 0 +++
+++ exited with 0 +++shell
</code></pre><p>哇哦，一大堆 <code>connect</code> 。</p>
<p>所以程序首先尝试连接 <a href="https://jameshfisher.com/2018/02/05/dont-use-nscd/">nscd</a> 因为显然我们依然生活在 90 年代：</p>
<pre><code class="language-nil" data-lang="nil">[pid 154627] connect(9, {sa_family=AF_UNIX, sun_path=&quot;/var/run/nscd/socket&quot;}, 110) = -1 ENOENT (No such file or directory)
</code></pre><p>。。。幸好我的系统没有它，所以它继续通过 <code>/etc/resolv.conf</code> 查询 DNS：</p>
<pre><code class="language-nil" data-lang="nil">[pid 154628] connect(9, {sa_family=AF_INET, sin_port=htons(53), sin_addr=inet_addr(&quot;127.0.0.53&quot;)}, 16) = 0
</code></pre><p>然后最终获得一些 <a href="https://www.cloudflare.com/ips/">Cloudflare 的 IP 地址</a>，如 <code>172.67.196.144</code> 和 <code>104.21.92.169</code> 。还有一些 IPv6 相关的，由于我禁用了 IPv6 所以并没有工作：</p>
<pre><code class="language-nil" data-lang="nil">[pid 154627] connect(9, {sa_family=AF_INET6, sin6_port=htons(0), sin6_flowinfo=htonl(0), inet_pton(AF_INET6, &quot;2606:4700:3034::6815:5ca9&quot;, &amp;sin6_addr), sin6_scope_id=0}, 28) = -1 ENETUNREACH (Network is unreachable)
</code></pre><p>然后终于程序决定使用 IPv4 的地址 <code>104.21.92.169</code> 去构建请求，同时我们能看到这些都是非阻塞的（non-blocking）连接，因为 <code>connect</code> 返回 <code>-1</code> 而不是 <code>0</code> 表示「正在连接、正在连接、稍后回来检查」。</p>
<pre><code class="language-nil" data-lang="nil">[pid 154625] connect(9, {sa_family=AF_INET, sin_port=htons(443), sin_addr=inet_addr(&quot;104.21.92.169&quot;)}, 16) = -1 EINPROGRESS (Operation now in progress)
[pid 154626] connect(10, {sa_family=AF_INET, sin_port=htons(443), sin_addr=inet_addr(&quot;104.21.92.169&quot;)}, 16) = -1 EINPROGRESS (Operation now in progress)
</code></pre><p>好了！所以忽略 <a href="https://isitdns.com/">DNS</a> 的话我们看到了两个连接。</p>
<p>同时我们看到了一些线程。</p>
<p>这就是 Rust 异步的工作方式？我们只是用了一些线程？这也就是它能在「后台运行」的原因？</p>
<p>在我们回答这些问题前，让我们先调整我们的代码真正的去等待 future 完成，而不是随意的休眠 1 秒钟。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#75715e">#[tokio::main]</span>
<span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() -&gt; Result<span style="color:#f92672">&lt;</span>(), Report<span style="color:#f92672">&gt;</span> {
    setup()<span style="color:#f92672">?</span>;

    <span style="color:#66d9ef">let</span> client <span style="color:#f92672">=</span> Client::new();
    <span style="color:#66d9ef">let</span> leaked_client <span style="color:#f92672">=</span> Box::leak(Box::new(client));

    <span style="color:#66d9ef">let</span> fut1 <span style="color:#f92672">=</span> fetch_thing(leaked_client, URL_1);
    <span style="color:#66d9ef">let</span> fut2 <span style="color:#f92672">=</span> fetch_thing(leaked_client, URL_2);

    <span style="color:#66d9ef">let</span> handle1 <span style="color:#f92672">=</span> tokio::spawn(fut1);
    <span style="color:#66d9ef">let</span> handle2 <span style="color:#f92672">=</span> tokio::spawn(fut2);

    handle1.<span style="color:#66d9ef">await</span>.unwrap()<span style="color:#f92672">?</span>;
    handle2.<span style="color:#66d9ef">await</span>.unwrap()<span style="color:#f92672">?</span>;

    Ok(())
}
</code></pre></div><p>等等，我们这不又回到原点吗？等待第一个请求完成，然后才开始第二个请求。</p>
<p>当然不是！我们运行几次就可以看到：</p>
<pre><code class="language-nil" data-lang="nil">$ RUST_LOG=info cargo run --quiet --release
Jul 25 19:11:07.934  INFO waytoodeep: Got a response! url=https://fasterthanli.me/articles/whats-in-the-box content_type=Some(&quot;text/html; charset=utf-8&quot;)
Jul 25 19:11:07.958  INFO waytoodeep: Got a response! url=https://fasterthanli.me/series/advent-of-code-2020/part-13 content_type=Some(&quot;text/html; charset=utf-8&quot;)
$ RUST_LOG=info cargo run --quiet --release
Jul 25 19:11:08.676  INFO waytoodeep: Got a response! url=https://fasterthanli.me/articles/whats-in-the-box content_type=Some(&quot;text/html; charset=utf-8&quot;)
Jul 25 19:11:08.680  INFO waytoodeep: Got a response! url=https://fasterthanli.me/series/advent-of-code-2020/part-13 content_type=Some(&quot;text/html; charset=utf-8&quot;)
$ RUST_LOG=info cargo run --quiet --release
Jul 25 19:11:09.325  INFO waytoodeep: Got a response! url=https://fasterthanli.me/articles/whats-in-the-box content_type=Some(&quot;text/html; charset=utf-8&quot;)
Jul 25 19:11:09.338  INFO waytoodeep: Got a response! url=https://fasterthanli.me/series/advent-of-code-2020/part-13 content_type=Some(&quot;text/html; charset=utf-8&quot;)
$ RUST_LOG=info cargo run --quiet --release
Jul 25 19:11:10.134  INFO waytoodeep: Got a response! url=https://fasterthanli.me/series/advent-of-code-2020/part-13 content_type=Some(&quot;text/html; charset=utf-8&quot;)
Jul 25 19:11:10.144  INFO waytoodeep: Got a response! url=https://fasterthanli.me/articles/whats-in-the-box content_type=Some(&quot;text/html; charset=utf-8&quot;)
</code></pre><p>。。。 “whats-in-the-box” 大部分情况下都胜出了（它确实先开始），但是“advent-of-code-2020”也首先完成了几次。这也是我们希望看到的。</p>
<blockquote>
<p>谬论：也就是说因为有线程请求被并行（parallel）的执行了。</p>
</blockquote>
<p>不是的。但是不要相信我，让我们继续深入。</p>
<h3 id="不是因为线程">不是因为线程</h3>
<p>让我们通过 GDB 运行我们的小程序，大部分原因是我还没有对 LLDB 形成肌肉记忆（我相信那唾手可得）。</p>
<pre><code class="language-nil" data-lang="nil">$ cargo build --quiet &amp;&amp; gdb --quiet --args ./target/debug/waytoodeep
Reading symbols from ./target/debug/waytoodeep...
warning: Missing auto-load script at offset 0 in section .debug_gdb_scripts
of file /home/amos/ftl/waytoodeep/target/debug/waytoodeep.
Use `info auto-load python-scripts [REGEXP]' to list them.
(gdb)
</code></pre><p>一切就绪！</p>
<p>在我们开始之前先设置一下断点。我说了断点？应该是捕捉点（catchpoint）。我不知道参与构造 HTTP/2 请求的所有函数名，但是我知道 <code>connect</code> 对应的系统调用（syscall），这也是我们需要打断点的地方，或者捕捉（catch）。</p>
<pre><code class="language-nil" data-lang="nil">(gdb) catch syscall connect
Catchpoint 1 (syscall 'connect' [42])
</code></pre><p>现在我们开始！</p>
<pre><code class="language-nil" data-lang="nil">$ Starting program: /home/amos/ftl/waytoodeep/target/debug/waytoodeep
[Thread debugging using libthread_db enabled]
Using host libthread_db library &quot;/lib/x86_64-linux-gnu/libthread_db.so.1&quot;.
[New Thread 0x7ffff7c28700 (LWP 158945)]
[New Thread 0x7ffff7a27700 (LWP 158946)]
[New Thread 0x7fffef826700 (LWP 158947)]
[New Thread 0x7ffff7826700 (LWP 158948)]
[New Thread 0x7ffff7625700 (LWP 158949)]
[New Thread 0x7ffff7424700 (LWP 158950)]
[New Thread 0x7ffff7223700 (LWP 158951)]
[New Thread 0x7ffff701f700 (LWP 158952)]
[New Thread 0x7ffff6e1e700 (LWP 158953)]
[New Thread 0x7ffff6c1a700 (LWP 158954)]
[New Thread 0x7ffff6a16700 (LWP 158955)]
[New Thread 0x7ffff680f700 (LWP 158956)]
[New Thread 0x7ffff660e700 (LWP 158957)]
[New Thread 0x7ffff640a700 (LWP 158958)]
[New Thread 0x7ffff6206700 (LWP 158959)]
[New Thread 0x7ffff5f4b700 (LWP 158960)]
[New Thread 0x7ffff5d4a700 (LWP 158961)]
[Switching to Thread 0x7ffff5f4b700 (LWP 158960)]

Thread 17 &quot;tokio-runtime-w&quot; hit Catchpoint 1 (call to syscall connect), 0x00007ffff7d5033b in __libc_connect (fd=fd@entry=9, addr=..., addr@entry=...,
    len=len@entry=110) at ../sysdeps/unix/sysv/linux/connect.c:26
26      ../sysdeps/unix/sysv/linux/connect.c: No such file or directory.
(gdb)
</code></pre><p>不错不错，真快！我们停在了名为 <code>tokio-runtime-w</code> 的 <code>Thread 17</code> 中，因为我猜其他所有字母都被使用了。</p>
<blockquote>
<p><code>w</code> 意味这 <code>worker</code> ，如果你不是第一天用 Unix 就会知道什么这么简写。</p>
</blockquote>
<p>好的， <code>Thread 17</code> ，那么其他线程在做什么呢？</p>
<pre><code class="language-nil" data-lang="nil">(gdb) info threads
  Id   Target Id                                            Frame
  1    Thread 0x7ffff7c2c6c0 (LWP 158941) &quot;waytoodeep&quot;      syscall () at ../sysdeps/unix/sysv/linux/x86_64/syscall.S:38
  2    Thread 0x7ffff7c28700 (LWP 158945) &quot;tokio-runtime-w&quot; syscall () at ../sysdeps/unix/sysv/linux/x86_64/syscall.S:38
  3    Thread 0x7ffff7a27700 (LWP 158946) &quot;tokio-runtime-w&quot; 0x00007ffff7d4f5ce in epoll_wait (epfd=3, events=0x555556338b60, maxevents=1024, timeout=-1)
    at ../sysdeps/unix/sysv/linux/epoll_wait.c:30
  4    Thread 0x7fffef826700 (LWP 158947) &quot;tokio-runtime-w&quot; syscall () at ../sysdeps/unix/sysv/linux/x86_64/syscall.S:38
  5    Thread 0x7ffff7826700 (LWP 158948) &quot;tokio-runtime-w&quot; syscall () at ../sysdeps/unix/sysv/linux/x86_64/syscall.S:38
  6    Thread 0x7ffff7625700 (LWP 158949) &quot;tokio-runtime-w&quot; syscall () at ../sysdeps/unix/sysv/linux/x86_64/syscall.S:38
  7    Thread 0x7ffff7424700 (LWP 158950) &quot;tokio-runtime-w&quot; syscall () at ../sysdeps/unix/sysv/linux/x86_64/syscall.S:38
  8    Thread 0x7ffff7223700 (LWP 158951) &quot;tokio-runtime-w&quot; syscall () at ../sysdeps/unix/sysv/linux/x86_64/syscall.S:38
  9    Thread 0x7ffff701f700 (LWP 158952) &quot;tokio-runtime-w&quot; syscall () at ../sysdeps/unix/sysv/linux/x86_64/syscall.S:38
  10   Thread 0x7ffff6e1e700 (LWP 158953) &quot;tokio-runtime-w&quot; syscall () at ../sysdeps/unix/sysv/linux/x86_64/syscall.S:38
  11   Thread 0x7ffff6c1a700 (LWP 158954) &quot;tokio-runtime-w&quot; syscall () at ../sysdeps/unix/sysv/linux/x86_64/syscall.S:38
  12   Thread 0x7ffff6a16700 (LWP 158955) &quot;tokio-runtime-w&quot; syscall () at ../sysdeps/unix/sysv/linux/x86_64/syscall.S:38
  13   Thread 0x7ffff680f700 (LWP 158956) &quot;tokio-runtime-w&quot; syscall () at ../sysdeps/unix/sysv/linux/x86_64/syscall.S:38
  14   Thread 0x7ffff660e700 (LWP 158957) &quot;tokio-runtime-w&quot; syscall () at ../sysdeps/unix/sysv/linux/x86_64/syscall.S:38
  15   Thread 0x7ffff640a700 (LWP 158958) &quot;tokio-runtime-w&quot; syscall () at ../sysdeps/unix/sysv/linux/x86_64/syscall.S:38
  16   Thread 0x7ffff6206700 (LWP 158959) &quot;tokio-runtime-w&quot; syscall () at ../sysdeps/unix/sysv/linux/x86_64/syscall.S:38
 *17   Thread 0x7ffff5f4b700 (LWP 158960) &quot;tokio-runtime-w&quot; 0x00007ffff7d5033b in __libc_connect (fd=fd@entry=9, addr=..., addr@entry=..., len=len@entry=110)
    at ../sysdeps/unix/sysv/linux/connect.c:26
  18   Thread 0x7ffff5d4a700 (LWP 158961) &quot;tokio-runtime-w&quot; 0x00007ffff7d48a46 in __GI___mmap64 (offset=0, fd=-1, flags=16418, prot=0, len=134217728, addr=0x0)
    at ../sysdeps/unix/sysv/linux/mmap64.c:59
</code></pre><p>额。</p>
<p>我们可以获得更多的栈帧？</p>
<pre><code class="language-nil" data-lang="nil">(gdb) thread apply all backtrace 2

Thread 18 (Thread 0x7ffff5d4a700 (LWP 158961)):
#0  0x00007ffff7d48a46 in __GI___mmap64 (offset=0, fd=-1, flags=16418, prot=0, len=134217728, addr=0x0) at ../sysdeps/unix/sysv/linux/mmap64.c:59
#1  __GI___mmap64 (addr=addr@entry=0x0, len=len@entry=134217728, prot=prot@entry=0, flags=flags@entry=16418, fd=fd@entry=-1, offset=offset@entry=0) at ../sysdeps/unix/sysv/linux/mmap64.c:47
(More stack frames follow...)

Thread 17 (Thread 0x7ffff5f4b700 (LWP 158960)):
#0  0x00007ffff7d5033b in __libc_connect (fd=fd@entry=9, addr=..., addr@entry=..., len=len@entry=110) at ../sysdeps/unix/sysv/linux/connect.c:26
#1  0x00007ffff7d8b713 in open_socket (type=type@entry=GETFDHST, key=key@entry=0x7ffff7de5ccb &quot;hosts&quot;, keylen=keylen@entry=6) at nscd_helper.c:185
(More stack frames follow...)

Thread 16 (Thread 0x7ffff6206700 (LWP 158959)):
#0  syscall () at ../sysdeps/unix/sysv/linux/x86_64/syscall.S:38
#1  0x0000555555b9f1d1 in parking_lot_core::thread_parker::imp::ThreadParker::futex_wait (self=0x7ffff6206498, ts=...) at /home/amos/.cargo/registry/src/github.com-1ecc6299db9ec823/parking_lot_core-0.8.3/src/thread_parker/linux.rs:112
(More stack frames follow...)

Thread 15 (Thread 0x7ffff640a700 (LWP 158958)):
#0  syscall () at ../sysdeps/unix/sysv/linux/x86_64/syscall.S:38
#1  0x0000555555b9f1d1 in parking_lot_core::thread_parker::imp::ThreadParker::futex_wait (self=0x7ffff640a498, ts=...) at /home/amos/.cargo/registry/src/github.com-1ecc6299db9ec823/parking_lot_core-0.8.3/src/thread_parker/linux.rs:112
(More stack frames follow...)

Thread 14 (Thread 0x7ffff660e700 (LWP 158957)):
#0  syscall () at ../sysdeps/unix/sysv/linux/x86_64/syscall.S:38
#1  0x0000555555b9f1d1 in parking_lot_core::thread_parker::imp::ThreadParker::futex_wait (self=0x7ffff660e498, ts=...) at /home/amos/.cargo/registry/src/github.com-1ecc6299db9ec823/parking_lot_core-0.8.3/src/thread_parker/linux.rs:112
(More stack frames follow...)

Thread 13 (Thread 0x7ffff680f700 (LWP 158956)):
#0  syscall () at ../sysdeps/unix/sysv/linux/x86_64/syscall.S:38
#1  0x0000555555b9f1d1 in parking_lot_core::thread_parker::imp::ThreadParker::futex_wait (self=0x7ffff680f498, ts=...) at /home/amos/.cargo/registry/src/github.com-1ecc6299db9ec823/parking_lot_core-0.8.3/src/thread_parker/linux.rs:112
(More stack frames follow...)
</code></pre><p>额。大部分都是挂起的。也就是空闲的。更准确的是它们在等待工作。</p>
<p>我们也可以通过 htop 查看这些所有线程，我知道我们已经看到了，但是我仅仅是觉得 htop 很棒。感谢 <a href="https://twitter.com/hisham%5Fhm">Hisham</a>！
<img src="https://fasterthanli.me/content/articles/understanding-rust-futures-by-going-way-too-deep/assets/htop-colors.571c5effbff8a0b3.webp" alt="">
所以，我们注意到一些线程，同时也有一些 CPU 核心。可能是一个 CPU 核心一个线程？
<img src="https://fasterthanli.me/content/articles/understanding-rust-futures-by-going-way-too-deep/assets/worker-threads.64dbe39e33ccfc4f.webp" alt="">
是的。然后还有一些阻塞的线程，正如我们从上面 <code>strace</code> 输出看到的那样， 它会进行一些阻塞的 <code>connect</code> 调用去查询 DNS（实际是 glibc 在执行），
所以它通过运行在工作线程之外避免阻塞其他任务。</p>
<blockquote>
<p>所以多个线程，这就是为什么一次可以运行多个请求的原因？</p>
</blockquote>
<p>实际上文档上表明这是一个单线程的执行器，我也不能确定，所以让我们试一下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#75715e">//                           👇
</span><span style="color:#75715e"></span><span style="color:#75715e">#[tokio::main(flavor = </span><span style="color:#e6db74">&#34;current_thread&#34;</span><span style="color:#75715e">)]</span>
<span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() -&gt; Result<span style="color:#f92672">&lt;</span>(), Report<span style="color:#f92672">&gt;</span> {
        <span style="color:#75715e">// (same as before)
</span><span style="color:#75715e"></span>}
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">$ RUST_LOG<span style="color:#f92672">=</span>info cargo run --quiet --release
Jul <span style="color:#ae81ff">25</span> 19:50:15.977  INFO waytoodeep: Got a response! url<span style="color:#f92672">=</span>https://fasterthanli.me/articles/whats-in-the-box content_type<span style="color:#f92672">=</span>Some<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;text/html; charset=utf-8&#34;</span><span style="color:#f92672">)</span>
Jul <span style="color:#ae81ff">25</span> 19:50:15.994  INFO waytoodeep: Got a response! url<span style="color:#f92672">=</span>https://fasterthanli.me/series/advent-of-code-2020/part-13 content_type<span style="color:#f92672">=</span>Some<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;text/html; charset=utf-8&#34;</span><span style="color:#f92672">)</span>
</code></pre></div><p>两个响应间隔 <code>17ms</code> ，这个时间不够构造一个完整的请求，所以请求并行（parallel）的执行了。如果你依然坚持它内部使用了线程，让我们进一步确认我们只有一个线程：
<img src="https://fasterthanli.me/content/articles/understanding-rust-futures-by-going-way-too-deep/assets/current-thread.cd7b619ed644899b.webp" alt="">
确实有多个线程，但是这些都是阻塞线程。仅仅是 DNS 查询。可以通过 htop 看到已经没有无数（15）的工作线程了：
<img src="https://fasterthanli.me/content/articles/understanding-rust-futures-by-going-way-too-deep/assets/htop-current-thread.fe28174abc5d15fa.webp" alt="">
（顺便说一下 15 个工作线程的原因，这是因为我预留了一个 CPU 核心没有分配给虚拟机，这样即使虚拟机全速运行也不会导致宿主机停止响应）。</p>
<p>如果我们将 DNS 查询排除在外，我们就可以看到实际上仅仅使用了一个线程，我们将继续下去，以防你依然存疑！</p>
<h3 id="插曲-让我们避免泄漏内存">插曲：让我们避免泄漏内存</h3>
<p>但是在那之前：正在泄漏 reqwest 的 <code>Client</code> 让我很不爽。</p>
<p>为了避免，我们可以创建一个原子引用计数（atomically-reference-counted），这样它就可以随着任务运行而存活。</p>
<p>修改起来非常简单：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#75715e">//             👇 Atomically Reference Counted = Arc
</span><span style="color:#75715e"></span><span style="color:#66d9ef">use</span> std::sync::Arc;

<span style="color:#75715e">#[tokio::main(flavor = </span><span style="color:#e6db74">&#34;current_thread&#34;</span><span style="color:#75715e">)]</span>
<span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() -&gt; Result<span style="color:#f92672">&lt;</span>(), Report<span style="color:#f92672">&gt;</span> {
    setup()<span style="color:#f92672">?</span>;

    <span style="color:#75715e">//           👇 there we go
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> client <span style="color:#f92672">=</span> Arc::new(Client::new());

    <span style="color:#75715e">//                              👇
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> fut1 <span style="color:#f92672">=</span> fetch_thing(client.clone(), URL_1);
    <span style="color:#75715e">// (cloning it only increases the reference count)
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> fut2 <span style="color:#f92672">=</span> fetch_thing(client.clone(), URL_2);

    <span style="color:#66d9ef">let</span> handle1 <span style="color:#f92672">=</span> tokio::spawn(fut1);
    <span style="color:#66d9ef">let</span> handle2 <span style="color:#f92672">=</span> tokio::spawn(fut2);

    handle1.<span style="color:#66d9ef">await</span>.unwrap()<span style="color:#f92672">?</span>;
    handle2.<span style="color:#66d9ef">await</span>.unwrap()<span style="color:#f92672">?</span>;

    Ok(())
}

<span style="color:#75715e">#[allow(clippy::manual_async_fn)]</span>
<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">fetch_thing</span>(
    <span style="color:#75715e">//       👇 now taking this, we have shared ownership of it
</span><span style="color:#75715e"></span>    client: <span style="color:#a6e22e">Arc</span><span style="color:#f92672">&lt;</span>Client<span style="color:#f92672">&gt;</span>,
    url: <span style="color:#66d9ef">&amp;</span>&#39;static <span style="color:#66d9ef">str</span>,
) -&gt; <span style="color:#a6e22e">impl</span> Future<span style="color:#f92672">&lt;</span>Output <span style="color:#f92672">=</span> Result<span style="color:#f92672">&lt;</span>(), Report<span style="color:#f92672">&gt;&gt;</span> <span style="color:#f92672">+</span> &#39;static {
    <span style="color:#66d9ef">async</span> <span style="color:#66d9ef">move</span> {
        <span style="color:#75715e">// luckily this  👇 only requires `&amp;self`
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">let</span> res <span style="color:#f92672">=</span> client.get(url).send().<span style="color:#66d9ef">await</span><span style="color:#f92672">?</span>.error_for_status()<span style="color:#f92672">?</span>;
        info<span style="color:#f92672">!</span>(<span style="color:#f92672">%</span>url, content_type <span style="color:#f92672">=</span> <span style="color:#f92672">?</span>res.headers().get(<span style="color:#e6db74">&#34;content-type&#34;</span>), <span style="color:#e6db74">&#34;Got a response!&#34;</span>);
        Ok(())
    }
}
</code></pre></div><p>好了，现在我感觉好多了。我们的程序不再泄漏一些字节即使它永远不会运行超过几秒钟。一切都还好。</p>
<p>让我们看一下 <code>reqwest</code> 的 <code>Client</code> 定义:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#75715e">#[derive(Clone)]</span>
<span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Client</span> {
    inner: <span style="color:#a6e22e">Arc</span><span style="color:#f92672">&lt;</span>ClientRef<span style="color:#f92672">&gt;</span>,
}
</code></pre></div><p>它已经是引用计数的了，所以我们可以直接接受一个 <code>Client</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#75715e">#[tokio::main(flavor = </span><span style="color:#e6db74">&#34;current_thread&#34;</span><span style="color:#75715e">)]</span>
<span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() -&gt; Result<span style="color:#f92672">&lt;</span>(), Report<span style="color:#f92672">&gt;</span> {
    setup()<span style="color:#f92672">?</span>;

    <span style="color:#75715e">//             👇
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> client <span style="color:#f92672">=</span> Client::new();

    <span style="color:#75715e">//                              👇
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> fut1 <span style="color:#f92672">=</span> fetch_thing(client.clone(), URL_1);
    <span style="color:#75715e">// no need to clone a second time
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> fut2 <span style="color:#f92672">=</span> fetch_thing(client, URL_2);

    <span style="color:#66d9ef">let</span> handle1 <span style="color:#f92672">=</span> tokio::spawn(fut1);
    <span style="color:#66d9ef">let</span> handle2 <span style="color:#f92672">=</span> tokio::spawn(fut2);

    handle1.<span style="color:#66d9ef">await</span>.unwrap()<span style="color:#f92672">?</span>;
    handle2.<span style="color:#66d9ef">await</span>.unwrap()<span style="color:#f92672">?</span>;

    Ok(())
}

<span style="color:#75715e">#[allow(clippy::manual_async_fn)]</span>
<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">fetch_thing</span>(
    <span style="color:#75715e">//        👇
</span><span style="color:#75715e"></span>    client: <span style="color:#a6e22e">Client</span>,
    url: <span style="color:#66d9ef">&amp;</span>&#39;static <span style="color:#66d9ef">str</span>,
) -&gt; <span style="color:#a6e22e">impl</span> Future<span style="color:#f92672">&lt;</span>Output <span style="color:#f92672">=</span> Result<span style="color:#f92672">&lt;</span>(), Report<span style="color:#f92672">&gt;&gt;</span> <span style="color:#f92672">+</span> &#39;static {
    <span style="color:#66d9ef">async</span> <span style="color:#66d9ef">move</span> {
        <span style="color:#66d9ef">let</span> res <span style="color:#f92672">=</span> client.get(url).send().<span style="color:#66d9ef">await</span><span style="color:#f92672">?</span>.error_for_status()<span style="color:#f92672">?</span>;
        info<span style="color:#f92672">!</span>(<span style="color:#f92672">%</span>url, content_type <span style="color:#f92672">=</span> <span style="color:#f92672">?</span>res.headers().get(<span style="color:#e6db74">&#34;content-type&#34;</span>), <span style="color:#e6db74">&#34;Got a response!&#34;</span>);
        Ok(())
    }
}
</code></pre></div><p>好了。</p>
<p>对了，仅供参考，更简单的 <code>async fn</code> 也可以工作了：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">fetch_thing</span>(client: <span style="color:#a6e22e">Client</span>, url: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>) -&gt; Result<span style="color:#f92672">&lt;</span>(), Report<span style="color:#f92672">&gt;</span> {
    <span style="color:#66d9ef">let</span> res <span style="color:#f92672">=</span> client.get(url).send().<span style="color:#66d9ef">await</span><span style="color:#f92672">?</span>.error_for_status()<span style="color:#f92672">?</span>;
    info<span style="color:#f92672">!</span>(<span style="color:#f92672">%</span>url, content_type <span style="color:#f92672">=</span> <span style="color:#f92672">?</span>res.headers().get(<span style="color:#e6db74">&#34;content-type&#34;</span>), <span style="color:#e6db74">&#34;Got a response!&#34;</span>);
    Ok(())
}
</code></pre></div><p>我们甚至不需要要求 <code>url</code> 的借用生命周期是 <code>'static</code> 。如果 <code>url</code> 是 <code>'static</code> 的则返回的 Future 也是，反之亦然。</p>
<p>作为例子，下面代码无法通过编译：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#75715e">#[tokio::main(flavor = </span><span style="color:#e6db74">&#34;current_thread&#34;</span><span style="color:#75715e">)]</span>
<span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() -&gt; Result<span style="color:#f92672">&lt;</span>(), Report<span style="color:#f92672">&gt;</span> {
    setup()<span style="color:#f92672">?</span>;

    <span style="color:#66d9ef">let</span> client <span style="color:#f92672">=</span> Client::new();

    <span style="color:#75715e">// this is a `String`, owned by main
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> url1 <span style="color:#f92672">=</span> String::from(URL_1);

    <span style="color:#75715e">// we&#39;re borrowing from main           👇
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> fut1 <span style="color:#f92672">=</span> fetch_thing(client.clone(), <span style="color:#f92672">&amp;</span>url1);
    <span style="color:#66d9ef">let</span> fut2 <span style="color:#f92672">=</span> fetch_thing(client, URL_2);

    <span style="color:#66d9ef">let</span> handle1 <span style="color:#f92672">=</span> tokio::spawn(fut1);
    <span style="color:#66d9ef">let</span> handle2 <span style="color:#f92672">=</span> tokio::spawn(fut2);

    handle1.<span style="color:#66d9ef">await</span>.unwrap()<span style="color:#f92672">?</span>;
    handle2.<span style="color:#66d9ef">await</span>.unwrap()<span style="color:#f92672">?</span>;

    Ok(())
}
</code></pre></div><pre><code class="language-nil" data-lang="nil">$ cargo check
    Checking waytoodeep v0.1.0 (/home/amos/ftl/waytoodeep)

error[E0597]: `url1` does not live long enough
  --&gt; src/main.rs:18:44
   |
18 |     let fut1 = fetch_thing(client.clone(), &amp;url1);
   |                ----------------------------^^^^^-
   |                |                           |
   |                |                           borrowed value does not live long enough
   |                argument requires that `url1` is borrowed for `'static`
...
28 | }
   | - `url1` dropped here while still borrowed
</code></pre><blockquote>
<p>你面对的考验就是：修改了一些代码，然后突然间整个 <code>Future</code> 不再实现 <code>Send</code> ，但是你需要它实现 <code>Send</code> 。参考<a href="https://fasterthanli.me/articles/getting-in-and-out-of-trouble-with-rust-futures">Getting in and out of trouble with Rust futures</a>。</p>
</blockquote>

</article>



</body>

</html>
