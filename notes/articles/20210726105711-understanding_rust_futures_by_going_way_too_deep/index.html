<!DOCTYPE html>
<html lang="en">
<head>
  
    <title>Understanding Rust futures by going way too deep :: Taking Smart Notes With Org-mode</title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="tags: Translate,Rust,Tokio  原文链接：Understanding Rust futures by going way too deep。
译者注：原文大量的引入了有趣的对话，迫于排版问题这里不进行翻译，必要的对话通过引用块来解释。
深入理解 Rust future 用 Rust future！就是这么简单！直到我们发现并非如此。所以我们先探索简单的部分，然后继续探索困难部分而不是等它慢慢靠近我们。
起步  Choo choo here comes the easy part 🚂💨
 我们创建一个新的项目：
$ cargo new waytoodeep Created binary (application) `waytoodeep` package 我们需要安装 cargo-edit 如果之前没有安装过的话，接下来就可以直接 cargo add ：
$ cargo install cargo-edit Updating crates.io index Downloaded cargo-edit v0.7.0 Downloaded 1 crate (57.6 KB) in 0.47s Ignored package `cargo-edit v0.7.0` is already installed, use --force to override  因为 cargo-edit 很方便，所以你可能已经安装过它。部分读者会感到困惑是因为像 cargo new, cargo build, cargo test, cargo run 等子命令都内置在 cargo 中， 但是 cargo add 没有。" />
<meta name="keywords" content="" />
<meta name="robots" content="noodp" />
<link rel="canonical" href="https://www.linuxzen.com/notes/articles/20210726105711-understanding_rust_futures_by_going_way_too_deep/" />




<link rel="stylesheet" href="https://www.linuxzen.com/notes/assets/style.css">






<link rel="apple-touch-icon" href="https://www.linuxzen.com/notes/img/apple-touch-icon-192x192.png">

  <link rel="shortcut icon" href="https://www.linuxzen.com/notes/img/favicon/orange.png">



<meta name="twitter:card" content="summary" />



<meta property="og:locale" content="en" />
<meta property="og:type" content="article" />
<meta property="og:title" content="Understanding Rust futures by going way too deep">
<meta property="og:description" content="tags: Translate,Rust,Tokio  原文链接：Understanding Rust futures by going way too deep。
译者注：原文大量的引入了有趣的对话，迫于排版问题这里不进行翻译，必要的对话通过引用块来解释。
深入理解 Rust future 用 Rust future！就是这么简单！直到我们发现并非如此。所以我们先探索简单的部分，然后继续探索困难部分而不是等它慢慢靠近我们。
起步  Choo choo here comes the easy part 🚂💨
 我们创建一个新的项目：
$ cargo new waytoodeep Created binary (application) `waytoodeep` package 我们需要安装 cargo-edit 如果之前没有安装过的话，接下来就可以直接 cargo add ：
$ cargo install cargo-edit Updating crates.io index Downloaded cargo-edit v0.7.0 Downloaded 1 crate (57.6 KB) in 0.47s Ignored package `cargo-edit v0.7.0` is already installed, use --force to override  因为 cargo-edit 很方便，所以你可能已经安装过它。部分读者会感到困惑是因为像 cargo new, cargo build, cargo test, cargo run 等子命令都内置在 cargo 中， 但是 cargo add 没有。" />
<meta property="og:url" content="https://www.linuxzen.com/notes/articles/20210726105711-understanding_rust_futures_by_going_way_too_deep/" />
<meta property="og:site_name" content="Taking Smart Notes With Org-mode" />

  
    <meta property="og:image" content="https://www.linuxzen.com/notes/img/favicon/orange.png">
  

<meta property="og:image:width" content="2048">
<meta property="og:image:height" content="1024">


  <meta property="article:published_time" content="2021-07-26 10:57:00 &#43;0800 &#43;0800" />












</head>
<body class="orange">


<div class="container center headings--one-size">

  <header class="header">
  <div class="header__inner">
    <div class="header__logo">
      <a href="https://www.linuxzen.com/notes/">
  <div class="logo">
    Terminal
  </div>
</a>

    </div>
    
      <div class="menu-trigger">menu</div>
    
  </div>
  
    <nav class="menu">
  <ul class="menu__inner menu__inner--desktop">
    
      
        
          <li><a href="/notes/projects/"> Projects in Progress</a></li>
        
      
        
          <li><a href="/notes/articles/">Articles</a></li>
        
      
        
          <li><a href="/notes/flashcards/">Flashcards</a></li>
        
      
        
          <li><a href="/notes/notes/">Notes</a></li>
        
      
        
          <li><a href="/notes/topics/">Topics</a></li>
        
      
      
    

    
  </ul>

  <ul class="menu__inner menu__inner--mobile">
    
      
        <li><a href="/notes/projects/"> Projects in Progress</a></li>
      
    
      
        <li><a href="/notes/articles/">Articles</a></li>
      
    
      
        <li><a href="/notes/flashcards/">Flashcards</a></li>
      
    
      
        <li><a href="/notes/notes/">Notes</a></li>
      
    
      
        <li><a href="/notes/topics/">Topics</a></li>
      
    
    
  </ul>
</nav>

  
</header>


  <div class="content">
    
<div class="post">
  <h1 class="post-title">
    <a href="https://www.linuxzen.com/notes/articles/20210726105711-understanding_rust_futures_by_going_way_too_deep/">Understanding Rust futures by going way too deep</a></h1>
  <div class="post-meta">
    
      <span class="post-date">
        2021-07-26 
      </span>
    
    
    <span class="post-author">:: [Gray King]</span>
    
  </div>

  

  

  

  <div class="post-content"><div>
        <ul>
<li>tags: <a href="/notes/topics/20200309112105_translate/">Translate</a>,<a href="/notes/topics/20200307191429_rust/">Rust</a>,<a href="/notes/notes/20210808083146-tokio/">Tokio</a></li>
</ul>
<p>原文链接：<a href="https://fasterthanli.me/articles/understanding-rust-futures-by-going-way-too-deep">Understanding Rust futures by going way too deep</a>。</p>
<p>译者注：原文大量的引入了有趣的对话，迫于排版问题这里不进行翻译，必要的对话通过引用块来解释。</p>
<h2 id="深入理解-rust-future">深入理解 Rust future<a href="#深入理解-rust-future" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>用 Rust future！就是这么简单！直到我们发现并非如此。所以我们先探索简单的部分，然后继续探索困难部分而不是等它慢慢靠近我们。</p>
<h2 id="起步">起步<a href="#起步" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<blockquote>
<p>Choo choo here comes the easy part 🚂💨</p>
</blockquote>
<p>我们创建一个新的项目：</p>
<pre tabindex="0"><code class="language-nil" data-lang="nil">$ cargo new waytoodeep
	 Created binary (application) `waytoodeep` package
</code></pre><p>我们需要安装 <code>cargo-edit</code> 如果之前没有安装过的话，接下来就可以直接 <code>cargo add</code> ：</p>
<pre tabindex="0"><code class="language-nil" data-lang="nil">$ cargo install cargo-edit
	Updating crates.io index
  Downloaded cargo-edit v0.7.0
  Downloaded 1 crate (57.6 KB) in 0.47s
	 Ignored package `cargo-edit v0.7.0` is already installed, use --force to override
</code></pre><blockquote>
<p>因为 <code>cargo-edit</code> 很方便，所以你可能已经安装过它。部分读者会感到困惑是因为像
<code>cargo new</code>, <code>cargo build</code>, <code>cargo test</code>, <code>cargo run</code> 等子命令都内置在 cargo 中，
但是 <code>cargo add</code> 没有。</p>
<p>实际上，有一大堆像这样的包，如 <a href="https://lib.rs/crates/cargo-hack">cargo-hack</a>,<a href="https://lib.rs/crates/cargo-udeps">cargo-udeps</a>,<a href="https://lib.rs/crates/cargo-expand">cargo-expand</a>&hellip;<a href="https://lib.rs/keywords/cargo">等等</a>。</p>
</blockquote>
<p>然后我们需要选择一个「异步运行时」（async runtime），因为这些 future 对象不会轮询（poll）自己。。。
我们毫无理由的选择 tokio，唯一的原因是：过去几个月我一直在用它。</p>
<pre tabindex="0"><code class="language-nil" data-lang="nil">$ cargo add tokio@1.9.0 --features full
	Updating &#39;https://github.com/rust-lang/crates.io-index&#39; index
	  Adding tokio v1.9.0 to dependencies with features: [&#34;full&#34;]
</code></pre><p>然后我们修改 <code>main</code> 函数使用 tokio 默认执行器（executor）（ <code>cargo new</code> 为我们生成了一个 <code>main</code> 函数，但是这里并不能满足我们的需求）：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">// in `src/main.rs`
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#[tokio::main]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	println!(<span style="color:#e6db74">&#34;Hello from a (so far completely unnecessary) async runtime&#34;</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><pre tabindex="0"><code class="language-nil" data-lang="nil">$ cargo run                                                                                                                                                                                          3s 209ms
   Compiling waytoodeep v0.1.0 (/Users/wh/codes/rust/waytoodeep)
	Finished dev [unoptimized + debuginfo] target(s) in 3.47s
	 Running `target/debug/waytoodeep`
Hello from a (so far completely unnecessary) async runtime
</code></pre><p>酷！</p>
<p>接下来让我们添加其他一些我喜欢在我的项目中使用的好东西。</p>
<p>首先，对于错误处理 - 我们编写程序就需要处理一堆不同库里不同的错误类型，如果能通过一个类型统一它们就会非常整洁。</p>
<p><a href="https://lib.rs/crates/eyre">eyre</a> 可以赋予我们这些（就像 <code>anyhow</code> ）！</p>
<p>并且因为我喜欢漂亮的颜色我将使用 <a href="https://lib.rs/crates/color-eyre">color-eyre</a>。</p>
<pre tabindex="0"><code class="language-nil" data-lang="nil">$ cargo add color-eyre@0.5.11
	Updating &#39;https://github.com/rust-lang/crates.io-index&#39; index
	  Adding color-eyre v0.5.11 to dependencies
</code></pre><p>现在我们需要安装 <code>color-eyre</code> 作为默认的崩溃（panic）处理器，我悄悄修改了一些环境变量来默认输出调用堆栈（backtracks）。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">use</span> color_eyre::Report;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#[tokio::main]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() -&gt; Result<span style="color:#f92672">&lt;</span>(), Report<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>	setup()<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	println!(<span style="color:#e6db74">&#34;Hello from a (so far completely unnecessary) async runtime&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	Ok(())
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">setup</span>() -&gt; Result<span style="color:#f92672">&lt;</span>(), Report<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> std::env::var(<span style="color:#e6db74">&#34;RUST_LIB_BACKTRACE&#34;</span>).is_err() {
</span></span><span style="display:flex;"><span>		std::env::set_var(<span style="color:#e6db74">&#34;RUST_LIB_BACKTRACE&#34;</span>, <span style="color:#e6db74">&#34;1&#34;</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	color_eyre::install()<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	Ok(())
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><pre tabindex="0"><code class="language-nil" data-lang="nil">$ cargo run
	Finished dev [unoptimized + debuginfo] target(s) in 0.02s
	 Running `target/debug/waytoodeep`
Hello from a (so far completely unnecessary) async runtime
</code></pre><p>很好！现在如果我们某处出现了一个错误，我们将看到完整的堆栈跟踪，就像下面这样：
<img src="https://fasterthanli.me/content/articles/understanding-rust-futures-by-going-way-too-deep/assets/color-eyre.78931d5fc80841f6.webp" alt=""></p>
<p>最后，因为我喜欢结构化日志，让我们添加 <a href="https://lib.rs/crates/tracing">tracing</a> 然后通过漂亮的颜色打印它们，让我们添加 <a href="https://lib.rs/crates/tracing-subscriber">tracing-subscriber</a>.</p>
<pre tabindex="0"><code class="language-nil" data-lang="nil">$ cargo add tracing@0.1.26 tracing-subscriber@0.2.19
	Updating &#39;https://github.com/rust-lang/crates.io-index&#39; index
	  Adding tracing v0.1.26 to dependencies
	  Adding tracing-subscriber v0.2.19 to dependencies
</code></pre><p>我们已经有一个 <code>setup</code> 函数，所以直接在那里安装 <code>tracing-subscriber</code>.. 然后我们将 <code>println!</code> 改成 <code>info!</code> ！
然后，为了演示如何设置让我们再次修改一些环境变量：对所有包（crates）默认 <code>info</code> 日志级别。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">use</span> color_eyre::Report;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">use</span> tracing::info;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">use</span> tracing_subscriber::EnvFilter;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#[tokio::main]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() -&gt; Result<span style="color:#f92672">&lt;</span>(), Report<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>	setup()<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	info<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;Hello from a comfy nest we&#39;ve made for ourselves&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	Ok(())
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">setup</span>() -&gt; Result<span style="color:#f92672">&lt;</span>(), Report<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> std::env::var(<span style="color:#e6db74">&#34;RUST_LIB_BACKTRACE&#34;</span>).is_err() {
</span></span><span style="display:flex;"><span>		std::env::set_var(<span style="color:#e6db74">&#34;RUST_LIB_BACKTRACE&#34;</span>, <span style="color:#e6db74">&#34;1&#34;</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	color_eyre::install()<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> std::env::var(<span style="color:#e6db74">&#34;RUST_LOG&#34;</span>).is_err() {
</span></span><span style="display:flex;"><span>		std::env::set_var(<span style="color:#e6db74">&#34;RUST_LOG&#34;</span>, <span style="color:#e6db74">&#34;info&#34;</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	tracing_subscriber::fmt::fmt()
</span></span><span style="display:flex;"><span>		.with_env_filter(EnvFilter::from_default_env())
</span></span><span style="display:flex;"><span>		.init();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	Ok(())
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><pre tabindex="0"><code class="language-nil" data-lang="nil">$ cargo run
	Finished dev [unoptimized + debuginfo] target(s) in 0.02s
	 Running `target/debug/waytoodeep`
Jul 25 17:03:46.993  INFO waytoodeep: Hello from a comfy nest we&#39;ve made for ourselves
</code></pre><p>好了，我们准备好做一些有用的事情了。</p>
<h3 id="做一些有用的事情">做一些有用的事情<a href="#做一些有用的事情" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>当决定在咖啡间隙阅读哪一篇文章的时候，人们通常同时打开几个网站，然后读最先加载出来的那一篇。</p>
<p>事实如此。你可以引用我的话，谁会去验证呢？毕竟这听起来需要很多工作。</p>
<p>所以让我们来编写一个程序做相同的事情。</p>
<p>让我们引入 <a href="https://lib.rs/crates/reqwest">reqwest</a> &ndash; 尽管我不喜欢它的 API，但它会很好的完成接下来的工作。</p>
<p>同时，因为 <a href="https://www.openssl.org/news/vulnerabilities.html">screw OpenSSL</a> 我们将标记 reqwest 使用 <a href="https://lib.rs/crates/rustls">rustls</a>：</p>
<pre tabindex="0"><code class="language-nil" data-lang="nil">$ cargo add reqwest@0.11.4 --no-default-features --features rustls-tls
	Updating &#39;https://github.com/rust-lang/crates.io-index&#39; index
	  Adding reqwest v0.11.4 to dependencies with features: [&#34;rustls-tls&#34;]
</code></pre><p>我们准备好发送一个请求了！</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">use</span> color_eyre::Report;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">use</span> tracing::info;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">use</span> tracing_subscriber::EnvFilter;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">use</span> reqwest::Client;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#[tokio::main]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() -&gt; Result<span style="color:#f92672">&lt;</span>(), Report<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>	setup()<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	info<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;Hello from a comfy nest we&#39;ve made for ourselves&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> client <span style="color:#f92672">=</span> Client::new();
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> url <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;https://fasterthanli.me&#34;</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// this will turn non-200 HTTP status codes into rust errors,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// so the first `?` propagates &#34;we had a connection problem&#34; and
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// the second `?` propagates &#34;we had a chat with the server and they
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// were not pleased&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">let</span> res <span style="color:#f92672">=</span> client.get(url).send().<span style="color:#66d9ef">await</span><span style="color:#f92672">?</span>.error_for_status()<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>	info<span style="color:#f92672">!</span>(<span style="color:#f92672">%</span>url, content_type <span style="color:#f92672">=</span> <span style="color:#f92672">?</span>res.headers().get(<span style="color:#e6db74">&#34;content-type&#34;</span>), <span style="color:#e6db74">&#34;Got a response!&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	Ok(())
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">setup</span>() -&gt; Result<span style="color:#f92672">&lt;</span>(), Report<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> std::env::var(<span style="color:#e6db74">&#34;RUST_LIB_BACKTRACE&#34;</span>).is_err() {
</span></span><span style="display:flex;"><span>		std::env::set_var(<span style="color:#e6db74">&#34;RUST_LIB_BACKTRACE&#34;</span>, <span style="color:#e6db74">&#34;1&#34;</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	color_eyre::install()<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> std::env::var(<span style="color:#e6db74">&#34;RUST_LOG&#34;</span>).is_err() {
</span></span><span style="display:flex;"><span>		std::env::set_var(<span style="color:#e6db74">&#34;RUST_LOG&#34;</span>, <span style="color:#e6db74">&#34;info&#34;</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	tracing_subscriber::fmt::fmt()
</span></span><span style="display:flex;"><span>		.with_env_filter(EnvFilter::from_default_env())
</span></span><span style="display:flex;"><span>		.init();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	Ok(())
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>出发了！</p>
<pre tabindex="0"><code class="language-nil" data-lang="nil">cargo run
   Compiling waytoodeep v0.1.0 (/Users/wh/codes/rust/waytoodeep)
	Finished dev [unoptimized + debuginfo] target(s) in 7.16s
	 Running `target/debug/waytoodeep`
Jul 26 16:50:57.778  INFO waytoodeep: Hello from a comfy nest we&#39;ve made for ourselves
Jul 26 16:50:59.090  INFO waytoodeep: Got a response! url=https://fasterthanli.me content_type=Some(&#34;text/html; charset=utf-8&#34;)
</code></pre><p>这就是我所说的「结构化日志」。嗯，其中的一部分。让我们看下这行代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>info<span style="color:#f92672">!</span>(<span style="color:#f92672">%</span>url, content_type <span style="color:#f92672">=</span> <span style="color:#f92672">?</span>res.headers().get(<span style="color:#e6db74">&#34;content-type&#34;</span>), <span style="color:#e6db74">&#34;Got a response!&#34;</span>);
</span></span></code></pre></div><p>我们输出来一个消息： <code>Got a response!</code> ，一个名为 <code>url</code> 的标签：值为变量 <code>url</code> 的 <a href="https://doc.rust-lang.org/stable/std/fmt/trait.Display.html">Display</a> 格式，
一个名为 <code>content_type</code> 的标签：值为表达式的 <a href="https://doc.rust-lang.org/stable/std/fmt/trait.Debug.html">Debug</a> 格式。</p>
<p>就是这么简单！ <code>name = %value</code> 输出 <code>Display</code> ， <code>name = ?value</code> 输出 <code>Debug</code> 。</p>
<p>当然，还有非常棒的跨度（spans），重点是你可以将它们发送到 APM（Appliation Performance Monitoring），比如 Datadog 或者 Honeycomb 等，但是这不是一篇关于跟踪的文章。</p>
<p>为了举例说明，如果我们安装一个 JSON 的 tracing subscriber，我们将获得如下内容：</p>
<pre tabindex="0"><code class="language-nil" data-lang="nil">$ cargo run
   Compiling waytoodeep v0.1.0 (/home/amos/ftl/waytoodeep)
	Finished dev [unoptimized + debuginfo] target(s) in 3.09s
	 Running `target/debug/waytoodeep`
{&#34;timestamp&#34;:&#34;Jul 25 17:17:21.531&#34;,&#34;level&#34;:&#34;INFO&#34;,&#34;fields&#34;:{&#34;message&#34;:&#34;Hello from a comfy nest we&#39;ve made for ourselves&#34;},&#34;target&#34;:&#34;waytoodeep&#34;}
{&#34;timestamp&#34;:&#34;Jul 25 17:17:21.709&#34;,&#34;level&#34;:&#34;INFO&#34;,&#34;fields&#34;:{&#34;message&#34;:&#34;Got a response!&#34;,&#34;url&#34;:&#34;https://fasterthanli.me&#34;,&#34;content_type&#34;:&#34;Some(\&#34;text/html; charset=utf-8\&#34;)&#34;},&#34;target&#34;:&#34;waytoodeep&#34;}
</code></pre><p>这应该足以激起你的兴趣。</p>
<h3 id="同时获取两个地址">同时获取两个地址<a href="#同时获取两个地址" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>现在让我们获取两个地址：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">const</span> URL_1: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;https://fasterthanli.me/articles/whats-in-the-box&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">const</span> URL_2: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;https://fasterthanli.me/series/advent-of-code-2020/part-13&#34;</span>;
</span></span></code></pre></div><p>。。。这是一个公平的比较。 这两篇文章都托管在我自己的网站上，绝对不是为了推广，而是为了使获取时间具有可比性，并且任一都有可能先加载完成（并且会随着时间的推移随机变化）。</p>
<p>我们将创建一个函数来获取内容：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">fetch_thing</span>(client: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">Client</span>, url: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>) -&gt; Result<span style="color:#f92672">&lt;</span>(), Report<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> res <span style="color:#f92672">=</span> client.get(url).send().<span style="color:#66d9ef">await</span><span style="color:#f92672">?</span>.error_for_status()<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>	info<span style="color:#f92672">!</span>(<span style="color:#f92672">%</span>url, content_type <span style="color:#f92672">=</span> <span style="color:#f92672">?</span>res.headers().get(<span style="color:#e6db74">&#34;content-type&#34;</span>), <span style="color:#e6db74">&#34;Got a response!&#34;</span>);
</span></span><span style="display:flex;"><span>	Ok(())
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>并使用它：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">#[tokio::main]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() -&gt; Result<span style="color:#f92672">&lt;</span>(), Report<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>	setup()<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	info<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;Hello from a comfy nest we&#39;ve made for ourselves&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> client <span style="color:#f92672">=</span> Client::new();
</span></span><span style="display:flex;"><span>	fetch_thing(<span style="color:#f92672">&amp;</span>client, URL_1);
</span></span><span style="display:flex;"><span>	fetch_thing(<span style="color:#f92672">&amp;</span>client, URL_2);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	Ok(())
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>然后运行它:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">$</span> cargo run
</span></span><span style="display:flex;"><span>   Compiling waytoodeep v0.<span style="color:#ae81ff">1.0</span> (<span style="color:#f92672">/</span>home<span style="color:#f92672">/</span>amos<span style="color:#f92672">/</span>ftl<span style="color:#f92672">/</span>waytoodeep)
</span></span><span style="display:flex;"><span>warning: <span style="color:#a6e22e">unused</span> implementer of <span style="color:#960050;background-color:#1e0010">`</span>Future<span style="color:#960050;background-color:#1e0010">`</span> that must be used
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">-</span>-&gt; <span style="color:#a6e22e">src</span><span style="color:#f92672">/</span>main.rs:<span style="color:#ae81ff">15</span>:<span style="color:#ae81ff">5</span>
</span></span><span style="display:flex;"><span>   <span style="color:#f92672">|</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">15</span> <span style="color:#f92672">|</span>     fetch_thing(<span style="color:#f92672">&amp;</span>client, URL_1);
</span></span><span style="display:flex;"><span>   <span style="color:#f92672">|</span>     <span style="color:#f92672">^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span>
</span></span><span style="display:flex;"><span>   <span style="color:#f92672">|</span>
</span></span><span style="display:flex;"><span>   <span style="color:#f92672">=</span> note: <span style="color:#960050;background-color:#1e0010">`</span><span style="color:#75715e">#[warn(unused_must_use)]</span><span style="color:#960050;background-color:#1e0010">`</span> on by default
</span></span><span style="display:flex;"><span>   <span style="color:#f92672">=</span> note: <span style="color:#a6e22e">futures</span> <span style="color:#66d9ef">do</span> nothing unless you <span style="color:#960050;background-color:#1e0010">`</span>.<span style="color:#66d9ef">await</span><span style="color:#960050;background-color:#1e0010">`</span> or poll them
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>warning: <span style="color:#a6e22e">unused</span> implementer of <span style="color:#960050;background-color:#1e0010">`</span>Future<span style="color:#960050;background-color:#1e0010">`</span> that must be used
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">-</span>-&gt; <span style="color:#a6e22e">src</span><span style="color:#f92672">/</span>main.rs:<span style="color:#ae81ff">16</span>:<span style="color:#ae81ff">5</span>
</span></span><span style="display:flex;"><span>   <span style="color:#f92672">|</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">16</span> <span style="color:#f92672">|</span>     fetch_thing(<span style="color:#f92672">&amp;</span>client, URL_2);
</span></span><span style="display:flex;"><span>   <span style="color:#f92672">|</span>     <span style="color:#f92672">^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span>
</span></span><span style="display:flex;"><span>   <span style="color:#f92672">|</span>
</span></span><span style="display:flex;"><span>   <span style="color:#f92672">=</span> note: <span style="color:#a6e22e">futures</span> <span style="color:#66d9ef">do</span> nothing unless you <span style="color:#960050;background-color:#1e0010">`</span>.<span style="color:#66d9ef">await</span><span style="color:#960050;background-color:#1e0010">`</span> or poll them
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>warning: <span style="color:#ae81ff">2</span> warnings emitted
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	Finished dev [unoptimized <span style="color:#f92672">+</span> debuginfo] target(s) <span style="color:#66d9ef">in</span> <span style="color:#ae81ff">3.01</span>s
</span></span><span style="display:flex;"><span>	 Running <span style="color:#960050;background-color:#1e0010">`</span>target<span style="color:#f92672">/</span>debug<span style="color:#f92672">/</span>waytoodeep<span style="color:#960050;background-color:#1e0010">`</span>
</span></span><span style="display:flex;"><span>Jul <span style="color:#ae81ff">25</span> <span style="color:#ae81ff">17</span>:<span style="color:#ae81ff">26</span>:<span style="color:#ae81ff">31.571</span>  INFO waytoodeep: <span style="color:#a6e22e">Hello</span> from a comfy nest we<span style="color:#f92672">&#39;</span><span style="color:#a6e22e">ve</span> made <span style="color:#66d9ef">for</span> ourselves
</span></span></code></pre></div><p>奇怪的是，没有任何事情发生。</p>
<blockquote>
<p>黄色的波浪线和恼人的 Rust 警告已经给出了提示。</p>
</blockquote>
<p>让我们来修复它：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>fetch_thing(<span style="color:#f92672">&amp;</span>client, URL_1).<span style="color:#66d9ef">await</span><span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>fetch_thing(<span style="color:#f92672">&amp;</span>client, URL_2).<span style="color:#66d9ef">await</span><span style="color:#f92672">?</span>;
</span></span></code></pre></div><pre tabindex="0"><code class="language-nil" data-lang="nil">$ cargo run
   Compiling waytoodeep v0.1.0 (/home/amos/ftl/waytoodeep)
	Finished dev [unoptimized + debuginfo] target(s) in 3.17s
	 Running `target/debug/waytoodeep`
Jul 25 17:27:29.768  INFO waytoodeep: Hello from a comfy nest we&#39;ve made for ourselves
Jul 25 17:27:29.891  INFO waytoodeep: Got a response! url=https://fasterthanli.me/articles/whats-in-the-box content_type=Some(&#34;text/html; charset=utf-8&#34;)
Jul 25 17:27:29.974  INFO waytoodeep: Got a response! url=https://fasterthanli.me/series/advent-of-code-2020/part-13 content_type=Some(&#34;text/html; charset=utf-8&#34;)
</code></pre><p>所以，第零课：future 对象不做任何事情直到它们被轮询（polled）。</p>
<p>这是因为 future 对象几乎就是状态。让我们来创建一个：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">// in `src/main.rs`
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">mod</span> dumb;
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">// in `src/dumb.rs`
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">use</span> std::{
</span></span><span style="display:flex;"><span>	future::Future,
</span></span><span style="display:flex;"><span>	pin::Pin,
</span></span><span style="display:flex;"><span>	task::{Context, Poll},
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">use</span> tracing::info;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">DumbFuture</span> {}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span> Future <span style="color:#66d9ef">for</span> DumbFuture {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Output</span> <span style="color:#f92672">=</span> ();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">poll</span>(self: <span style="color:#a6e22e">Pin</span><span style="color:#f92672">&lt;&amp;</span><span style="color:#66d9ef">mut</span> Self<span style="color:#f92672">&gt;</span>, _cx: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> Context<span style="color:#f92672">&lt;&#39;</span>_<span style="color:#f92672">&gt;</span>) -&gt; <span style="color:#a6e22e">Poll</span><span style="color:#f92672">&lt;</span>Self::Output<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>		info<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;Hello from a dumb future!&#34;</span>);
</span></span><span style="display:flex;"><span>		Poll::Ready(())
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">// back in `src/main.rs`
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#[tokio::main]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() -&gt; Result<span style="color:#f92672">&lt;</span>(), Report<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>	setup()<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> fut <span style="color:#f92672">=</span> dumb::DumbFuture {};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	Ok(())
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>以上！我们几乎就完成了，除了我们没有进行 <code>.await</code> 。</p>
<p>运行它除了打印警告不会有任何效果：</p>
<pre tabindex="0"><code class="language-nil" data-lang="nil">$ cargo run
   Compiling waytoodeep v0.1.0 (/home/amos/ftl/waytoodeep)
warning: unused variable: `fut`
  --&gt; src/main.rs:14:9
   |
14 |     let fut = dumb::DumbFuture {};
   |         ^^^ help: if this is intentional, prefix it with an underscore: `_fut`
   |
   = note: `#[warn(unused_variables)]` on by default

warning: 1 warning emitted

	Finished dev [unoptimized + debuginfo] target(s) in 2.11s
	 Running `target/debug/waytoodeep`
</code></pre><p>因为怎么可能？我们字面上仅仅构建了一个结构体。一个零大小的结构体。</p>
<p>如果我们调用它的 <code>.await</code> 。。 然后当我们要求运行时运行它的事件循环直到 future 对象被轮询（polled）并且最终返回 <code>Poll::Ready</code> （我们的代码立即返回）：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">#[tokio::main]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() -&gt; Result<span style="color:#f92672">&lt;</span>(), Report<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>	setup()<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	info<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;Building that dumb future...&#34;</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> fut <span style="color:#f92672">=</span> dumb::DumbFuture {};
</span></span><span style="display:flex;"><span>	info<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;Awaiting that dumb future...&#34;</span>);
</span></span><span style="display:flex;"><span>	fut.<span style="color:#66d9ef">await</span>;
</span></span><span style="display:flex;"><span>	info<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;Done awaiting that dumb future&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	Ok(())
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><pre tabindex="0"><code class="language-nil" data-lang="nil">$ cargo run
   Compiling waytoodeep v0.1.0 (/home/amos/ftl/waytoodeep)
	Finished dev [unoptimized + debuginfo] target(s) in 2.34s
	 Running `target/debug/waytoodeep`
Jul 25 17:37:09.261  INFO waytoodeep: Building that dumb future...
Jul 25 17:37:09.261  INFO waytoodeep: Awaiting that dumb future...
Jul 25 17:37:09.261  INFO waytoodeep::dumb: Hello from a dumb future!
Jul 25 17:37:09.262  INFO waytoodeep: Done awaiting that dumb future
</code></pre><p>这里与 ECMAScript 的 <code>promise</code> 有一些略微的区别：即使它们压根没有被 await 其中包含的工作依然会被执行。</p>
<p>但是 Rust 的 future 对象仅仅是无聊的状态机，如果你故意制造麻烦就可以理解这个机制：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">// in `src/dumb.rs`
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span> Future <span style="color:#66d9ef">for</span> DumbFuture {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Output</span> <span style="color:#f92672">=</span> ();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">poll</span>(self: <span style="color:#a6e22e">Pin</span><span style="color:#f92672">&lt;&amp;</span><span style="color:#66d9ef">mut</span> Self<span style="color:#f92672">&gt;</span>, _cx: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> Context<span style="color:#f92672">&lt;&#39;</span>_<span style="color:#f92672">&gt;</span>) -&gt; <span style="color:#a6e22e">Poll</span><span style="color:#f92672">&lt;</span>Self::Output<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>		panic!(<span style="color:#e6db74">&#34;Oh heck no&#34;</span>);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><pre tabindex="0"><code class="language-nil" data-lang="nil">$ RUST_BACKTRACE=1 cargo run
   Compiling waytoodeep v0.1.0 (/home/amos/ftl/waytoodeep)
	Finished dev [unoptimized + debuginfo] target(s) in 2.28s
	 Running `target/debug/waytoodeep`
Jul 25 17:41:18.956  INFO waytoodeep: Building that dumb future...
Jul 25 17:41:18.956  INFO waytoodeep: Awaiting that dumb future...
The application panicked (crashed).
Message:  Oh heck no
Location: src/dumb.rs:14

  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ BACKTRACE ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
								⋮ 6 frames hidden ⋮
   7: &lt;waytoodeep::dumb::DumbFuture as core::future::future::Future&gt;::poll::h4a44780628f4c5f0
	  at /home/amos/ftl/waytoodeep/src/dumb.rs:14
   8: waytoodeep::main::{{closure}}::h36de5a1f1f2a5c5b
	  at /home/amos/ftl/waytoodeep/src/main.rs:17
   9: &lt;core::future::from_generator::GenFuture&lt;T&gt; as core::future::future::Future&gt;::poll::h20a96e082c7a581e
	  at /home/amos/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/future/mod.rs:80
  10: tokio::park::thread::CachedParkThread::block_on::{{closure}}::hdf98cb3c7fdf3de4
	  at /home/amos/.cargo/registry/src/github.com-1ecc6299db9ec823/tokio-1.9.0/src/park/thread.rs:263
  11: tokio::coop::with_budget::{{closure}}::h6a86a24a246e220f
	  at /home/amos/.cargo/registry/src/github.com-1ecc6299db9ec823/tokio-1.9.0/src/coop.rs:106
  12: std::thread::local::LocalKey&lt;T&gt;::try_with::h2ce0ac27c85965b6
	  at /home/amos/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/thread/local.rs:376
  13: std::thread::local::LocalKey&lt;T&gt;::with::hc449f38c9f65fb53
	  at /home/amos/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/thread/local.rs:352
  14: tokio::coop::with_budget::h5db157bd1e95e0e8
	  at /home/amos/.cargo/registry/src/github.com-1ecc6299db9ec823/tokio-1.9.0/src/coop.rs:99
  15: tokio::coop::budget::h7b57383f1255ac24
	  at /home/amos/.cargo/registry/src/github.com-1ecc6299db9ec823/tokio-1.9.0/src/coop.rs:76
  16: tokio::park::thread::CachedParkThread::block_on::hece399485213b91c
	  at /home/amos/.cargo/registry/src/github.com-1ecc6299db9ec823/tokio-1.9.0/src/park/thread.rs:263
  17: tokio::runtime::enter::Enter::block_on::h89e9882e539e82d3
	  at /home/amos/.cargo/registry/src/github.com-1ecc6299db9ec823/tokio-1.9.0/src/runtime/enter.rs:151
  18: tokio::runtime::thread_pool::ThreadPool::block_on::h1a0186470c00ba70
	  at /home/amos/.cargo/registry/src/github.com-1ecc6299db9ec823/tokio-1.9.0/src/runtime/thread_pool/mod.rs:71
  19: tokio::runtime::Runtime::block_on::h7c21d6989b86d606
	  at /home/amos/.cargo/registry/src/github.com-1ecc6299db9ec823/tokio-1.9.0/src/runtime/mod.rs:452
  20: waytoodeep::main::hb4dd5ffd46a5c032
	  at /home/amos/ftl/waytoodeep/src/main.rs:20
  21: core::ops::function::FnOnce::call_once::hc1fcc87431f77d25
	  at /home/amos/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ops/function.rs:227
								⋮ 11 frames hidden ⋮

Run with COLORBT_SHOW_HIDDEN=1 environment variable to disable frame filtering.
Run with RUST_BACKTRACE=full to include source snippets.
</code></pre><p>上面堆栈跟踪如果加上颜色效果会更好，所以我希望你在本地做了相同的尝试，即使如此我们依然可以看到我们真正的 main 函数在 20 帧，然后往上，我们可以看到 <code>Runtime::block_on</code>  、一个线程池的东西、一些挂起（parked）的线程、thread-local（其他 TLS）、一个 <strong><strong>生成的</strong></strong> future（帧 9 和 8，也就是我们的 <code>async fn main</code> 的最终结果），最后是我们的 <code>DumbFuture</code> poll 方法（帧 7）。</p>
<p>帧 6 到 1 就是 <a href="https://doc.rust-lang.org/stable/std/panic/index.html">panic</a> 机制，再次完全超出本文讨论的范围。</p>
<p>但是请站起来，亲爱的观众，用你的手臂绕过这个装置，以确保没有障眼法，没有隐藏的线，没有。。。</p>
<p>。。。我要说的是对于异步堆栈跟踪没有“特殊处理”（special handling）。当然，这里我们崩溃了，但是仅仅是 Rust，操作系统甚至不知道我几乎避免了一场灾难。</p>
<p>但是我们可以制造更大的混乱，如果我们愿意使用 <code>unsafe</code> ：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">impl</span> Future <span style="color:#66d9ef">for</span> DumbFuture {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Output</span> <span style="color:#f92672">=</span> ();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">poll</span>(self: <span style="color:#a6e22e">Pin</span><span style="color:#f92672">&lt;&amp;</span><span style="color:#66d9ef">mut</span> Self<span style="color:#f92672">&gt;</span>, _cx: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> Context<span style="color:#f92672">&lt;&#39;</span>_<span style="color:#f92672">&gt;</span>) -&gt; <span style="color:#a6e22e">Poll</span><span style="color:#f92672">&lt;</span>Self::Output<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">unsafe</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#f92672">*</span>(<span style="color:#ae81ff">0xF00D</span> <span style="color:#66d9ef">as</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">mut</span> <span style="color:#66d9ef">u64</span>) <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x0</span>;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		unreachable!(); <span style="color:#75715e">// pinky promise
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>然后就不会有一些列的崩溃处理来拯救我们：</p>
<pre tabindex="0"><code class="language-nil" data-lang="nil">$ RUST_BACKTRACE=1 cargo run
   Compiling waytoodeep v0.1.0 (/home/amos/ftl/waytoodeep)
	Finished dev [unoptimized + debuginfo] target(s) in 2.18s
	 Running `target/debug/waytoodeep`
Jul 25 17:46:53.926  INFO waytoodeep: Building that dumb future...
Jul 25 17:46:53.926  INFO waytoodeep: Awaiting that dumb future...
zsh: segmentation fault (core dumped)  RUST_BACKTRACE=1 cargo run
</code></pre><p>但是 GDB 可以：</p>
<pre tabindex="0"><code class="language-nil" data-lang="nil">$ cargo build &amp;&amp; gdb --quiet --args ./target/debug/waytoodeep
	Finished dev [unoptimized + debuginfo] target(s) in 0.04s
Reading symbols from ./target/debug/waytoodeep...
warning: Missing auto-load script at offset 0 in section .debug_gdb_scripts
of file /home/amos/ftl/waytoodeep/target/debug/waytoodeep.
Use `info auto-load python-scripts [REGEXP]&#39; to list them.
(gdb) r
Starting program: /home/amos/ftl/waytoodeep/target/debug/waytoodeep
[Thread debugging using libthread_db enabled]
Using host libthread_db library &#34;/lib/x86_64-linux-gnu/libthread_db.so.1&#34;.
[New Thread 0x7ffff7c28700 (LWP 129418)]
[New Thread 0x7ffff7a27700 (LWP 129419)]
[New Thread 0x7ffff7826700 (LWP 129420)]
[New Thread 0x7ffff7625700 (LWP 129421)]
[New Thread 0x7ffff7424700 (LWP 129422)]
[New Thread 0x7ffff7223700 (LWP 129423)]
[New Thread 0x7ffff7022700 (LWP 129424)]
[New Thread 0x7ffff6e1e700 (LWP 129425)]
[New Thread 0x7ffff6c1a700 (LWP 129426)]
[New Thread 0x7ffff6a16700 (LWP 129427)]
[New Thread 0x7ffff6812700 (LWP 129428)]
[New Thread 0x7ffff660e700 (LWP 129429)]
[New Thread 0x7ffff640a700 (LWP 129430)]
[New Thread 0x7ffff6206700 (LWP 129431)]
[New Thread 0x7ffff6002700 (LWP 129432)]
Jul 25 17:47:13.278  INFO waytoodeep: Building that dumb future...
Jul 25 17:47:13.279  INFO waytoodeep: Awaiting that dumb future...

Thread 1 &#34;waytoodeep&#34; received signal SIGSEGV, Segmentation fault.
&lt;waytoodeep::dumb::DumbFuture as core::future::future::Future&gt;::poll (self=..., _cx=0x7fffffffd690) at src/dumb.rs:15
15                  *(0xF00D as *mut u64) = 0x0;
(gdb) bt
#0  &lt;waytoodeep::dumb::DumbFuture as core::future::future::Future&gt;::poll (self=..., _cx=0x7fffffffd690) at src/dumb.rs:15
#1  0x00005555555ab3a3 in waytoodeep::main::{{closure}} () at src/main.rs:17
#2  0x00005555555adb29 in &lt;core::future::from_generator::GenFuture&lt;T&gt; as core::future::future::Future&gt;::poll (self=..., cx=0x7fffffffd690)
	at /home/amos/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/future/mod.rs:80
#3  0x00005555555adaa0 in tokio::park::thread::CachedParkThread::block_on::{{closure}} ()
	at /home/amos/.cargo/registry/src/github.com-1ecc6299db9ec823/tokio-1.9.0/src/park/thread.rs:263
#4  0x00005555555b1742 in tokio::coop::with_budget::{{closure}} (cell=0x7ffff7c2c412)
	at /home/amos/.cargo/registry/src/github.com-1ecc6299db9ec823/tokio-1.9.0/src/coop.rs:106
#5  0x00005555555a9f58 in std::thread::local::LocalKey&lt;T&gt;::try_with (self=0x555555925fc0, f=...)
	at /home/amos/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/thread/local.rs:376
#6  0x00005555555a9e3d in std::thread::local::LocalKey&lt;T&gt;::with (self=0x555555925fc0, f=...)
	at /home/amos/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/thread/local.rs:352
#7  0x00005555555ad7c8 in tokio::coop::with_budget (budget=..., f=...)
	at /home/amos/.cargo/registry/src/github.com-1ecc6299db9ec823/tokio-1.9.0/src/coop.rs:99
#8  tokio::coop::budget (f=...) at /home/amos/.cargo/registry/src/github.com-1ecc6299db9ec823/tokio-1.9.0/src/coop.rs:76
#9  tokio::park::thread::CachedParkThread::block_on (self=0x7fffffffd7a0, f=...)
	at /home/amos/.cargo/registry/src/github.com-1ecc6299db9ec823/tokio-1.9.0/src/park/thread.rs:263
#10 0x00005555555abcc9 in tokio::runtime::enter::Enter::block_on (self=0x7fffffffd7f0, f=...)
	at /home/amos/.cargo/registry/src/github.com-1ecc6299db9ec823/tokio-1.9.0/src/runtime/enter.rs:151
#11 0x00005555555acf2e in tokio::runtime::thread_pool::ThreadPool::block_on (self=0x7fffffffd908, future=...)
	at /home/amos/.cargo/registry/src/github.com-1ecc6299db9ec823/tokio-1.9.0/src/runtime/thread_pool/mod.rs:71
#12 0x00005555555b0dfd in tokio::runtime::Runtime::block_on (self=0x7fffffffd900, future=...)
	at /home/amos/.cargo/registry/src/github.com-1ecc6299db9ec823/tokio-1.9.0/src/runtime/mod.rs:452
#13 0x00005555555aa807 in waytoodeep::main () at src/main.rs:20
(gdb)
</code></pre><p>我们再次丢失了高亮颜色，这里可以看一下：
<img src="https://fasterthanli.me/content/articles/understanding-rust-futures-by-going-way-too-deep/assets/gdb-colors.b45af429c46a37d9.webp" alt=""></p>
<blockquote>
<p>译注：我在本地环境并没有通过 GDB 复现带高亮的堆栈跟踪，反而是通过 LLDB 可以看到高亮的堆栈跟踪。</p>
</blockquote>
<p>是不是很漂亮？</p>
<p>现在让我们回到正常有用的代码，移除所有关于自己实现的 future 代码： <code>src/dumb.rs</code> 和 <code>mod dumb</code> 。并使用一个获取 future 替代：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">#[tokio::main]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() -&gt; Result<span style="color:#f92672">&lt;</span>(), Report<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>	setup()<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	info<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;Building that fetch future...&#34;</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> client <span style="color:#f92672">=</span> Client::new();
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> fut <span style="color:#f92672">=</span> fetch_thing(<span style="color:#f92672">&amp;</span>client, URL_1);
</span></span><span style="display:flex;"><span>	info<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;Awaiting that fetch future...&#34;</span>);
</span></span><span style="display:flex;"><span>	fut.<span style="color:#66d9ef">await</span><span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>	info<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;Done awaiting that fetch future&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	Ok(())
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><pre tabindex="0"><code class="language-nil" data-lang="nil">$ RUST_BACKTRACE=1 cargo run
   Compiling waytoodeep v0.1.0 (/home/amos/ftl/waytoodeep)
	Finished dev [unoptimized + debuginfo] target(s) in 2.99s
	 Running `target/debug/waytoodeep`
Jul 25 17:51:49.281  INFO waytoodeep: Building that fetch future...
Jul 25 17:51:49.282  INFO waytoodeep: Awaiting that fetch future...
Jul 25 17:51:49.437  INFO waytoodeep: Got a response! url=https://fasterthanli.me/articles/whats-in-the-box content_type=Some(&#34;text/html; charset=utf-8&#34;)
Jul 25 17:51:49.438  INFO waytoodeep: Done awaiting that fetch future
</code></pre><p>有两种方式考虑我们的函数，一个是语法糖层：也就是 <code>async fn</code> ：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">fetch_thing</span>(client: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">Client</span>, url: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>) -&gt; Result<span style="color:#f92672">&lt;</span>(), Report<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> res <span style="color:#f92672">=</span> client.get(url).send().<span style="color:#66d9ef">await</span><span style="color:#f92672">?</span>.error_for_status()<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>	info<span style="color:#f92672">!</span>(<span style="color:#f92672">%</span>url, content_type <span style="color:#f92672">=</span> <span style="color:#f92672">?</span>res.headers().get(<span style="color:#e6db74">&#34;content-type&#34;</span>), <span style="color:#e6db74">&#34;Got a response!&#34;</span>);
</span></span><span style="display:flex;"><span>	Ok(())
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>然后是核心实现层：一个普通的 <code>fn</code> 仅用来返回一个 future 对象：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">use</span> std::future::Future;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">fetch_thing</span><span style="color:#f92672">&lt;&#39;</span><span style="color:#a6e22e">a</span><span style="color:#f92672">&gt;</span>(
</span></span><span style="display:flex;"><span>	client: <span style="color:#66d9ef">&amp;</span><span style="color:#f92672">&#39;</span><span style="color:#a6e22e">a</span> <span style="color:#a6e22e">Client</span>,
</span></span><span style="display:flex;"><span>	url: <span style="color:#66d9ef">&amp;</span><span style="color:#f92672">&#39;</span><span style="color:#a6e22e">a</span> <span style="color:#66d9ef">str</span>,
</span></span><span style="display:flex;"><span>) -&gt; <span style="color:#a6e22e">impl</span> Future<span style="color:#f92672">&lt;</span>Output <span style="color:#f92672">=</span> Result<span style="color:#f92672">&lt;</span>(), Report<span style="color:#f92672">&gt;&gt;</span> <span style="color:#f92672">+</span> <span style="color:#f92672">&#39;</span><span style="color:#a6e22e">a</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">async</span> <span style="color:#66d9ef">move</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">let</span> res <span style="color:#f92672">=</span> client.get(url).send().<span style="color:#66d9ef">await</span><span style="color:#f92672">?</span>.error_for_status()<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>		info<span style="color:#f92672">!</span>(<span style="color:#f92672">%</span>url, content_type <span style="color:#f92672">=</span> <span style="color:#f92672">?</span>res.headers().get(<span style="color:#e6db74">&#34;content-type&#34;</span>), <span style="color:#e6db74">&#34;Got a response!&#34;</span>);
</span></span><span style="display:flex;"><span>		Ok(())
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>由于借用 <code>client</code> 和 <code>url</code> ，所以 <code>Future</code> 对象的存活时间不能超过两者，这也是为什么我会将上面两个生命周期命名为 <code>'a</code> ，
并且返回的值也是任意实现了 <code>Future</code> （通过 <code>Output</code> ）同时生命周期也是 <code>'a</code> 。</p>
<p>整个 <code>async move {}</code> 快也仅仅是“构建状态” &ndash; 等于一个实现了 <code>Future</code> 的类型。</p>
<p>我们只是无法命名它。</p>
<p>我们只能尽量获取它的描述：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">type_name_of</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>(_: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">T</span>) -&gt; <span style="color:#66d9ef">&amp;</span><span style="color:#f92672">&#39;</span>static <span style="color:#66d9ef">str</span> {
</span></span><span style="display:flex;"><span>	std::any::type_name::<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// in main
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#[tokio::main]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() -&gt; Result<span style="color:#f92672">&lt;</span>(), Report<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>	setup()<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	info<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;Building that fetch future...&#34;</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> client <span style="color:#f92672">=</span> Client::new();
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> fut <span style="color:#f92672">=</span> fetch_thing(<span style="color:#f92672">&amp;</span>client, URL_1);
</span></span><span style="display:flex;"><span>	info<span style="color:#f92672">!</span>(
</span></span><span style="display:flex;"><span>		type_name <span style="color:#f92672">=</span> type_name_of(<span style="color:#f92672">&amp;</span>fut),
</span></span><span style="display:flex;"><span>		<span style="color:#e6db74">&#34;That fetch future has a type..&#34;</span>
</span></span><span style="display:flex;"><span>	);
</span></span><span style="display:flex;"><span>	info<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;Awaiting that fetch future...&#34;</span>);
</span></span><span style="display:flex;"><span>	fut.<span style="color:#66d9ef">await</span><span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>	info<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;Done awaiting that fetch future&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	Ok(())
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><pre tabindex="0"><code class="language-nil" data-lang="nil">$ cargo run
	Finished dev [unoptimized + debuginfo] target(s) in 0.05s
	 Running `target/debug/waytoodeep`
Jul 25 18:00:39.774  INFO waytoodeep: Building that fetch future...
Jul 25 18:00:39.775  INFO waytoodeep: That fetch future has a type.. type_name=&#34;core::future::from_generator::GenFuture&lt;waytoodeep::fetch_thing::{{closure}}&gt;&#34;
Jul 25 18:00:39.775  INFO waytoodeep: Awaiting that fetch future...
Jul 25 18:00:39.882  INFO waytoodeep: Got a response! url=https://fasterthanli.me/articles/whats-in-the-box content_type=Some(&#34;text/html; charset=utf-8&#34;)
Jul 25 18:00:39.882  INFO waytoodeep: Done awaiting that fetch future
</code></pre><p>。。。但是等等，由于我们使用了 <code>async</code> 语法所以它是一个编译器生成的类型。某种意义上我们无法命名它也就意味这我们无法绑定这个对象，或者编写一个函数仅仅接受该类型。</p>
<p>为了让我们自己相信 future 对象在我们真正轮询它之前它不会做任何工作，我们可以打开 <code>reqwest</code> 的调试日志：</p>
<pre tabindex="0"><code class="language-nil" data-lang="nil">$ RUST_LOG=info,reqwest=debug cargo run
   Compiling waytoodeep v0.1.0 (/home/amos/ftl/waytoodeep)
	Finished dev [unoptimized + debuginfo] target(s) in 3.07s
	 Running `target/debug/waytoodeep`
Jul 25 18:05:07.384  INFO waytoodeep: Building that fetch future...
Jul 25 18:05:07.385  INFO waytoodeep: That fetch future has a type.. type_name=&#34;core::future::from_generator::GenFuture&lt;waytoodeep::fetch_thing::{{closure}}&gt;&#34;
Jul 25 18:05:07.385  INFO waytoodeep: Awaiting that fetch future...
Jul 25 18:05:07.385 DEBUG reqwest::connect: starting new connection: https://fasterthanli.me/
Jul 25 18:05:07.503 DEBUG reqwest::async_impl::client: response &#39;200 OK&#39; for https://fasterthanli.me/articles/whats-in-the-box
Jul 25 18:05:07.503  INFO waytoodeep: Got a response! url=https://fasterthanli.me/articles/whats-in-the-box content_type=Some(&#34;text/html; charset=utf-8&#34;)
Jul 25 18:05:07.503  INFO waytoodeep: Done awaiting that fetch future
</code></pre><p>甚至对于每一个包（crate），我们都可以通过监听 <a href="https://lib.rs/crates/hyper">hyper</a> 和 <a href="https://lib.rs/crates/h2">h2</a> 来观察：</p>
<pre tabindex="0"><code class="language-nil" data-lang="nil">$ RUST_LOG=debug cargo run
	Finished dev [unoptimized + debuginfo] target(s) in 0.04s
	 Running `target/debug/waytoodeep`
Jul 25 18:05:59.973  INFO waytoodeep: Building that fetch future...
Jul 25 18:05:59.973  INFO waytoodeep: That fetch future has a type.. type_name=&#34;core::future::from_generator::GenFuture&lt;waytoodeep::fetch_thing::{{closure}}&gt;&#34;
Jul 25 18:05:59.973  INFO waytoodeep: Awaiting that fetch future...
Jul 25 18:05:59.974 DEBUG reqwest::connect: starting new connection: https://fasterthanli.me/
Jul 25 18:05:59.974 DEBUG hyper::client::connect::dns: resolving host=&#34;fasterthanli.me&#34;
Jul 25 18:05:59.989 DEBUG hyper::client::connect::http: connecting to 172.67.196.144:443
Jul 25 18:06:00.000 DEBUG hyper::client::connect::http: connected to 172.67.196.144:443
Jul 25 18:06:00.000 DEBUG rustls::client::hs: No cached session for DNSNameRef(&#34;fasterthanli.me&#34;)
Jul 25 18:06:00.000 DEBUG rustls::client::hs: Not resuming any session
Jul 25 18:06:00.016 DEBUG rustls::client::hs: Using ciphersuite TLS13_CHACHA20_POLY1305_SHA256
Jul 25 18:06:00.016 DEBUG rustls::client::tls13: Not resuming
Jul 25 18:06:00.017 DEBUG rustls::client::tls13: TLS1.3 encrypted extensions: [ServerNameAck, Protocols([PayloadU8([104, 50])])]
Jul 25 18:06:00.017 DEBUG rustls::client::hs: ALPN protocol is Some(b&#34;h2&#34;)
Jul 25 18:06:00.018 DEBUG h2::client: binding client connection
Jul 25 18:06:00.018 DEBUG h2::client: client connection bound
Jul 25 18:06:00.018 DEBUG h2::codec::framed_write: send frame=Settings { flags: (0x0), enable_push: 0, initial_window_size: 2097152, max_frame_size: 16384 }
Jul 25 18:06:00.019 DEBUG Connection{peer=Client}: h2::codec::framed_write: send frame=WindowUpdate { stream_id: StreamId(0), size_increment: 5177345 }
Jul 25 18:06:00.019 DEBUG hyper::client::pool: pooling idle connection for (&#34;https&#34;, fasterthanli.me)
Jul 25 18:06:00.020 DEBUG Connection{peer=Client}: h2::codec::framed_write: send frame=Headers { stream_id: StreamId(1), flags: (0x5: END_HEADERS | END_STREAM) }
Jul 25 18:06:00.029 DEBUG Connection{peer=Client}: rustls::client::tls13: Ticket saved
Jul 25 18:06:00.029 DEBUG Connection{peer=Client}: rustls::client::tls13: Ticket saved
Jul 25 18:06:00.029 DEBUG Connection{peer=Client}: h2::codec::framed_read: received frame=Settings { flags: (0x0), max_concurrent_streams: 256, initial_window_size: 65536, max_frame_size: 16777215 }
Jul 25 18:06:00.030 DEBUG Connection{peer=Client}: h2::codec::framed_write: send frame=Settings { flags: (0x1: ACK) }
Jul 25 18:06:00.030 DEBUG Connection{peer=Client}: h2::codec::framed_read: received frame=WindowUpdate { stream_id: StreamId(0), size_increment: 2147418112 }
Jul 25 18:06:00.041 DEBUG Connection{peer=Client}: h2::codec::framed_read: received frame=Settings { flags: (0x1: ACK) }
Jul 25 18:06:00.041 DEBUG Connection{peer=Client}: h2::proto::settings: received settings ACK; applying Settings { flags: (0x0), enable_push: 0, initial_window_size: 2097152, max_frame_size: 16384 }
Jul 25 18:06:00.120 DEBUG Connection{peer=Client}: h2::codec::framed_read: received frame=Headers { stream_id: StreamId(1), flags: (0x4: END_HEADERS) }
Jul 25 18:06:00.120 DEBUG Connection{peer=Client}: h2::codec::framed_read: received frame=Data { stream_id: StreamId(1) }
Jul 25 18:06:00.121 DEBUG reqwest::async_impl::client: response &#39;200 OK&#39; for https://fasterthanli.me/articles/whats-in-the-box
Jul 25 18:06:00.121  INFO waytoodeep: Got a response! url=https://fasterthanli.me/articles/whats-in-the-box content_type=Some(&#34;text/html; charset=utf-8&#34;)
Jul 25 18:06:00.121  INFO waytoodeep: Done awaiting that fetch future
Jul 25 18:06:00.121 DEBUG Connection{peer=Client}: h2::codec::framed_read: received frame=Data { stream_id: StreamId(1) }
Jul 25 18:06:00.122 DEBUG Connection{peer=Client}: h2::codec::framed_write: send frame=Reset { stream_id: StreamId(1), error_code: CANCEL }
Jul 25 18:06:00.122 DEBUG Connection{peer=Client}: h2::codec::framed_write: send frame=GoAway { error_code: NO_ERROR, last_stream_id: StreamId(0) }
Jul 25 18:06:00.122 DEBUG Connection{peer=Client}: h2::proto::connection: Connection::poll; connection error error=NO_ERROR
Jul 25 18:06:00.122 DEBUG Connection{peer=Client}: rustls::session: Sending warning alert CloseNotify
</code></pre><blockquote>
<p>上面出现了 rustls，并且使用了 TLS 1.3，作者做过<a href="https://www.youtube.com/watch?v=YHIiVsFybLA">一期视频</a>介绍过 TLS 1.3。</p>
</blockquote>
<p>这些应该足够说服你，除非你只相信内核所说的，所以让我们看看调用堆栈只为了更加确定。</p>
<p>我们在 <code>await</code> future 对象之前增加一秒钟的休眠：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">use</span> tokio::time::sleep;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">use</span> std::time::Duration;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#[tokio::main]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() -&gt; Result<span style="color:#f92672">&lt;</span>(), Report<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>	setup()<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	info<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;Building that fetch future...&#34;</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> client <span style="color:#f92672">=</span> Client::new();
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> fut <span style="color:#f92672">=</span> fetch_thing(<span style="color:#f92672">&amp;</span>client, URL_1);
</span></span><span style="display:flex;"><span>	info<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;Sleeping for a bit...&#34;</span>);
</span></span><span style="display:flex;"><span>	sleep(Duration::from_secs(<span style="color:#ae81ff">1</span>)).<span style="color:#66d9ef">await</span>;
</span></span><span style="display:flex;"><span>	info<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;Awaiting that fetch future...&#34;</span>);
</span></span><span style="display:flex;"><span>	fut.<span style="color:#66d9ef">await</span><span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>	info<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;Done awaiting that fetch future&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	Ok(())
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><pre tabindex="0"><code class="language-nil" data-lang="nil">$ cargo build &amp;&amp; strace -e &#39;connect&#39; ./target/debug/waytoodeep
   Compiling waytoodeep v0.1.0 (/home/amos/ftl/waytoodeep)
	Finished dev [unoptimized + debuginfo] target(s) in 3.13s
Jul 25 18:09:36.595  INFO waytoodeep: Building that fetch future...
Jul 25 18:09:36.596  INFO waytoodeep: Sleeping for a bit...
Jul 25 18:09:37.599  INFO waytoodeep: Awaiting that fetch future...
connect(9, {sa_family=AF_INET, sin_port=htons(443), sin_addr=inet_addr(&#34;104.21.92.169&#34;)}, 16) = -1 EINPROGRESS (Operation now in progress)
Jul 25 18:09:37.720  INFO waytoodeep: Got a response! url=https://fasterthanli.me/articles/whats-in-the-box content_type=Some(&#34;text/html; charset=utf-8&#34;)
Jul 25 18:09:37.721  INFO waytoodeep: Done awaiting that fetch future
+++ exited with 0 +++
</code></pre><p>再次强调，附上会让显著提高上面信息的可读性，如果不让我选择它们的话我是非常喜欢高亮的。我本地看起来是这样的：
<img src="https://fasterthanli.me/content/articles/understanding-rust-futures-by-going-way-too-deep/assets/strace-colors.a4163f4bda179c2b.webp" alt="">
由于 <code>tracing-subscriber</code> 默认格式会输出时间戳，可以看到程序休眠了1分钟（外加3毫秒），而且只有我们真正调用 <code>await</code> 时我们的程序才会开始连接到托管文章的 CDN 节点。</p>
<p>好了！让我们再次尝试拉取两篇文章：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">#[tokio::main]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() -&gt; Result<span style="color:#f92672">&lt;</span>(), Report<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>	setup()<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> client <span style="color:#f92672">=</span> Client::new();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> fut1 <span style="color:#f92672">=</span> fetch_thing(<span style="color:#f92672">&amp;</span>client, URL_1);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> fut2 <span style="color:#f92672">=</span> fetch_thing(<span style="color:#f92672">&amp;</span>client, URL_2);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	fut1.<span style="color:#66d9ef">await</span><span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>	fut2.<span style="color:#66d9ef">await</span><span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	Ok(())
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>再次检查日志：</p>
<pre tabindex="0"><code class="language-nil" data-lang="nil">$ RUST_LOG=info,reqwest=debug cargo run --quiet
Jul 25 18:31:47.396 DEBUG reqwest::connect: starting new connection: https://fasterthanli.me/
Jul 25 18:31:47.536 DEBUG reqwest::async_impl::client: response &#39;200 OK&#39; for https://fasterthanli.me/articles/whats-in-the-box
Jul 25 18:31:47.537  INFO waytoodeep: Got a response! url=https://fasterthanli.me/articles/whats-in-the-box content_type=Some(&#34;text/html; charset=utf-8&#34;)
Jul 25 18:31:47.627 DEBUG reqwest::async_impl::client: response &#39;200 OK&#39; for https://fasterthanli.me/series/advent-of-code-2020/part-13
Jul 25 18:31:47.627  INFO waytoodeep: Got a response! url=https://fasterthanli.me/series/advent-of-code-2020/part-13 content_type=Some(&#34;text/html; charset=utf-8&#34;)
</code></pre><p>非常有趣。从这里可以看到， <code>reqwest</code> 为两个请求复用了相同的连接。我会这么说是因我只看到了一行 <code>reqwest::connect</code> 日志。</p>
<p>让我们快速通过 <code>strace</code> 检查一下：</p>
<pre tabindex="0"><code class="language-nil" data-lang="nil">$ cargo build --quiet &amp;&amp; strace -e &#39;connect&#39; ./target/debug/waytoodeep &gt; /dev/null
connect(9, {sa_family=AF_INET, sin_port=htons(443), sin_addr=inet_addr(&#34;172.67.196.144&#34;)}, 16) = -1 EINPROGRESS (Operation now in progress)
+++ exited with 0 +++
</code></pre><p>现在可以确认了，只有一次连接。</p>
<p>但是，第一个请求完成后才开始了第二个请求。第一个耗费了 <code>536-396 = 140</code> 毫秒，但是第二个耗费了 <code>627-537 = 90</code> 毫秒！</p>
<blockquote>
<p>Emmm，现在我们运行构建的是 debug 版本不是吗？</p>
</blockquote>
<p>这是真的。我确信我们面临的是 IO 密集型，而不是 CPU 密集型。</p>
<p>debug 版本的构建绝对有一些额外的开销，但是我怀疑这里它不会太影响延迟。无论如何，让我们检查一下：
（注意 &ndash;release）</p>
<pre tabindex="0"><code class="language-nil" data-lang="nil">$ RUST_LOG=info,reqwest=debug cargo run --quiet --release
Jul 25 18:34:59.211 DEBUG reqwest::connect: starting new connection: https://fasterthanli.me/
Jul 25 18:34:59.343 DEBUG reqwest::async_impl::client: response &#39;200 OK&#39; for https://fasterthanli.me/articles/whats-in-the-box
Jul 25 18:34:59.343  INFO waytoodeep: Got a response! url=https://fasterthanli.me/articles/whats-in-the-box content_type=Some(&#34;text/html; charset=utf-8&#34;)
Jul 25 18:34:59.427 DEBUG reqwest::async_impl::client: response &#39;200 OK&#39; for https://fasterthanli.me/series/advent-of-code-2020/part-13
Jul 25 18:34:59.427  INFO waytoodeep: Got a response! url=https://fasterthanli.me/series/advent-of-code-2020/part-13 content_type=Some(&#34;text/html; charset=utf-8&#34;)
</code></pre><p>我们计算一下延迟 <code>343-211 = 132ms</code> ， <code>427-343 = 84ms</code> 。</p>
<p>几毫秒的差异可能的解释是邻居打开了一个 YouTube 视频导致无线电波爆发，从而导致冲突（802.11 没有空中流量控制，全民自由（free-for-all））和重传。</p>
<p>或者另外一百万个原因。这也是我们不继续分析的原因。</p>
<p>让我们回到文章的主题。</p>
<h3 id="等待第一个完成">等待第一个完成<a href="#等待第一个完成" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>是的！等待第一个完成。所以我们如何让程序同时请求两个？</p>
<p>其实有一大堆方式！</p>
<p>例如，我们可以在一个执行器上执行（ <code>spawn</code> ）这些 future 对象，然后休眠一秒钟。1 秒钟足够了吧？</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">#[tokio::main]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() -&gt; Result<span style="color:#f92672">&lt;</span>(), Report<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>	setup()<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> client <span style="color:#f92672">=</span> Client::new();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> fut1 <span style="color:#f92672">=</span> fetch_thing(<span style="color:#f92672">&amp;</span>client, URL_1);
</span></span><span style="display:flex;"><span>	tokio::spawn(fut1);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> fut2 <span style="color:#f92672">=</span> fetch_thing(<span style="color:#f92672">&amp;</span>client, URL_2);
</span></span><span style="display:flex;"><span>	tokio::spawn(fut2);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	tokio::time::sleep(Duration::from_secs(<span style="color:#ae81ff">1</span>)).<span style="color:#66d9ef">await</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	Ok(())
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><pre tabindex="0"><code class="language-nil" data-lang="nil">$ RUST_LOG=info,reqwest=debug cargo run --quiet --release
error[E0597]: `client` does not live long enough
  --&gt; src/main.rs:17:28
   |
17 |     let fut1 = fetch_thing(&amp;client, URL_1);
   |                ------------^^^^^^^--------
   |                |           |
   |                |           borrowed value does not live long enough
   |                argument requires that `client` is borrowed for `&#39;static`
...
25 | }
   | - `client` dropped here while still borrowed

error: aborting due to previous error

For more information about this error, try `rustc --explain E0597`.
error: could not compile `waytoodeep`

To learn more, run the command again with --verbose.
</code></pre><p>额，除非我们不可以。不可以是因为。。。</p>
<blockquote>
<p>我们将「future 对象交给执行器执行」并将 future 对象转交给执行器，对吧？我们转移了它和它的内容的所有权。</p>
<p>然后即使我们不对其进行 <code>await</code> ，future 对象因为是「执行器需要做」的一部分依然会被执行，所以即使我们从 <code>main</code> 返回 future 对象也会被轮询（polled）。</p>
<p>但是如果我们从 <code>main</code> 返回，则整个程序都会退出。</p>
<p>这里也可以是任何函数（这里是 <code>main</code> ）。重要的是如果函数返回了但是 future 对象借用了部分数据将无法通过借用检查器。</p>
</blockquote>
<p>这让我很高兴，因为这意味着我们不会意外访问到一些被释放的资源：<a href="https://cve.mitre.org/cgi-bin/cvekey.cgi?keyword=use+after+free">UAF</a>。</p>
<p>这里我们的例子没有完成。</p>
<p>所以。。。我们需要解决这个问题。如果 <code>fetch_thing</code> 返回的 future 对象是 <code>'static</code> 的呢？或者它不借用任何东西？</p>
<p>程序现在看起来如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">use</span> std::future::Future;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">fetch_thing</span><span style="color:#f92672">&lt;&#39;</span><span style="color:#a6e22e">a</span><span style="color:#f92672">&gt;</span>(
</span></span><span style="display:flex;"><span>	client: <span style="color:#66d9ef">&amp;</span><span style="color:#f92672">&#39;</span><span style="color:#a6e22e">a</span> <span style="color:#a6e22e">Client</span>,
</span></span><span style="display:flex;"><span>	url: <span style="color:#66d9ef">&amp;</span><span style="color:#f92672">&#39;</span><span style="color:#a6e22e">a</span> <span style="color:#66d9ef">str</span>,
</span></span><span style="display:flex;"><span>) -&gt; <span style="color:#a6e22e">impl</span> Future<span style="color:#f92672">&lt;</span>Output <span style="color:#f92672">=</span> Result<span style="color:#f92672">&lt;</span>(), Report<span style="color:#f92672">&gt;&gt;</span> <span style="color:#f92672">+</span> <span style="color:#f92672">&#39;</span><span style="color:#a6e22e">a</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">async</span> <span style="color:#66d9ef">move</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">let</span> res <span style="color:#f92672">=</span> client.get(url).send().<span style="color:#66d9ef">await</span><span style="color:#f92672">?</span>.error_for_status()<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>		info<span style="color:#f92672">!</span>(<span style="color:#f92672">%</span>url, content_type <span style="color:#f92672">=</span> <span style="color:#f92672">?</span>res.headers().get(<span style="color:#e6db74">&#34;content-type&#34;</span>), <span style="color:#e6db74">&#34;Got a response!&#34;</span>);
</span></span><span style="display:flex;"><span>		Ok(())
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>好吧，之前我们用了 <code>async fn</code> ，但是为了更加深入的理解，我们不得不放弃漂亮的语法。</p>
<p>但是幸运的是，这正是我们想要的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">fetch_thing</span><span style="color:#f92672">&lt;&#39;</span><span style="color:#a6e22e">a</span><span style="color:#f92672">&gt;</span>(
</span></span><span style="display:flex;"><span>	client: <span style="color:#66d9ef">&amp;</span><span style="color:#f92672">&#39;</span><span style="color:#a6e22e">a</span> <span style="color:#a6e22e">Client</span>,
</span></span><span style="display:flex;"><span>	url: <span style="color:#66d9ef">&amp;</span><span style="color:#f92672">&#39;</span><span style="color:#a6e22e">a</span> <span style="color:#66d9ef">str</span>,
</span></span><span style="display:flex;"><span><span style="color:#75715e">//                                                 👇
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>) -&gt; <span style="color:#a6e22e">impl</span> Future<span style="color:#f92672">&lt;</span>Output <span style="color:#f92672">=</span> Result<span style="color:#f92672">&lt;</span>(), Report<span style="color:#f92672">&gt;&gt;</span> <span style="color:#f92672">+</span> <span style="color:#f92672">&#39;</span>static {}
</span></span></code></pre></div><p>但是我们借用了 <code>client</code> 和 <code>url</code> 我们必须避免这个问题。</p>
<p>因为 <code>url</code> 本身就是常量，所以很容易解决：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">const</span> URL_1: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;https://fasterthanli.me/articles/whats-in-the-box&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">const</span> URL_2: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;https://fasterthanli.me/series/advent-of-code-2020/part-13&#34;</span>;
</span></span></code></pre></div><p>它们本身就是 <code>'static</code> 。所以我们只需要调整需要 <code>'static</code> 就行:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">fetch_thing</span><span style="color:#f92672">&lt;&#39;</span><span style="color:#a6e22e">a</span><span style="color:#f92672">&gt;</span>(
</span></span><span style="display:flex;"><span>	client: <span style="color:#66d9ef">&amp;</span><span style="color:#f92672">&#39;</span><span style="color:#a6e22e">a</span> <span style="color:#a6e22e">Client</span>,
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//       👇
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	url: <span style="color:#66d9ef">&amp;</span><span style="color:#f92672">&#39;</span>static <span style="color:#66d9ef">str</span>,
</span></span><span style="display:flex;"><span>) -&gt; <span style="color:#a6e22e">impl</span> Future<span style="color:#f92672">&lt;</span>Output <span style="color:#f92672">=</span> Result<span style="color:#f92672">&lt;</span>(), Report<span style="color:#f92672">&gt;&gt;</span> <span style="color:#f92672">+</span> <span style="color:#f92672">&#39;</span>static {}
</span></span></code></pre></div><p>非常好！解决了一个生命周期，还剩下一个。</p>
<p>我们可以要求 <code>client</code> 的生命周期为 <code>'static</code> 。由于它是一个  <code>Client</code> 的引用，意味着 <code>Cleint</code> 本身也需要是 <code>'static</code> 生命周期。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">fetch_thing</span>(
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//         👇
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	client: <span style="color:#66d9ef">&amp;</span><span style="color:#f92672">&#39;</span>static <span style="color:#a6e22e">Client</span>,
</span></span><span style="display:flex;"><span>	url: <span style="color:#66d9ef">&amp;</span><span style="color:#f92672">&#39;</span>static <span style="color:#66d9ef">str</span>,
</span></span><span style="display:flex;"><span>) -&gt; <span style="color:#a6e22e">impl</span> Future<span style="color:#f92672">&lt;</span>Output <span style="color:#f92672">=</span> Result<span style="color:#f92672">&lt;</span>(), Report<span style="color:#f92672">&gt;&gt;</span> <span style="color:#f92672">+</span> <span style="color:#f92672">&#39;</span>static {}
</span></span></code></pre></div><p>由于它被 <code>main</code> 所有，额，我们可以，可以。。。可以泄漏它：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">#[tokio::main]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() -&gt; Result<span style="color:#f92672">&lt;</span>(), Report<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>	setup()<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> client <span style="color:#f92672">=</span> Client::new();
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> leaked_client <span style="color:#f92672">=</span> Box::leak(Box::new(client));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> fut1 <span style="color:#f92672">=</span> fetch_thing(leaked_client, URL_1);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> fut2 <span style="color:#f92672">=</span> fetch_thing(leaked_client, URL_2);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	tokio::spawn(fut1);
</span></span><span style="display:flex;"><span>	tokio::spawn(fut2);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	tokio::time::sleep(Duration::from_secs(<span style="color:#ae81ff">1</span>)).<span style="color:#66d9ef">await</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	Ok(())
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>完美！没有生命周期的问题了。</p>
<p>仅仅将所有东西泄漏就行。看到没？你不需要 C！</p>
<pre tabindex="0"><code class="language-nil" data-lang="nil">$ RUST_LOG=info,reqwest=debug cargo run --quiet --release
Jul 25 18:54:53.614 DEBUG reqwest::connect: starting new connection: https://fasterthanli.me/
Jul 25 18:54:53.614 DEBUG reqwest::connect: starting new connection: https://fasterthanli.me/
Jul 25 18:54:53.708 DEBUG reqwest::async_impl::client: response &#39;200 OK&#39; for https://fasterthanli.me/articles/whats-in-the-box
Jul 25 18:54:53.708  INFO waytoodeep: Got a response! url=https://fasterthanli.me/articles/whats-in-the-box content_type=Some(&#34;text/html; charset=utf-8&#34;)
Jul 25 18:54:53.733 DEBUG reqwest::async_impl::client: response &#39;200 OK&#39; for https://fasterthanli.me/series/advent-of-code-2020/part-13
Jul 25 18:54:53.733  INFO waytoodeep: Got a response! url=https://fasterthanli.me/series/advent-of-code-2020/part-13 content_type=Some(&#34;text/html; charset=utf-8&#34;)
</code></pre><p>非～～常有趣！</p>
<p>我们的两个请求肯定是并发的发出去了，我们之所以知道是因为从我的笔记本上请求我的网站大概耗时 80ms 到 140ms 之间，但是在日志中我们看到两个响应之间只有 ~25ms 的间隔。</p>
<p>我们还可以看到 <code>reqwest</code> 有连接池机制：同时创建了两个连接。可能是因为我们开始第二个连接的时候第一个请求的连接还没有建立完成。</p>
<p>也就意味着我们通过 <code>strace</code> 可以看到：</p>
<pre tabindex="0"><code class="language-nil" data-lang="nil">$ cargo build --quiet --release &amp;&amp; strace -e &#39;connect&#39; ./target/release/waytoodeep
Jul 25 18:58:16.425  INFO waytoodeep: Got a response! url=https://fasterthanli.me/articles/whats-in-the-box content_type=Some(&#34;text/html; charset=utf-8&#34;)
Jul 25 18:58:16.443  INFO waytoodeep: Got a response! url=https://fasterthanli.me/series/advent-of-code-2020/part-13 content_type=Some(&#34;text/html; charset=utf-8&#34;)
+++ exited with 0 +++
</code></pre><p>。。。两个 <code>connect</code> 调用！如我所料！</p>
<blockquote>
<p>谬论：一个 <code>connect</code> 调用都没看到？因为 Rust 构建 HTTP/2 请求的时候甚至都需要建立 TCP 连接。真是革命性的！</p>
</blockquote>
<p>这当然不是真的。可能在其他线程执行了？也许 <code>strace</code> 默认仅跟踪了主线程？</p>
<p>啊，对了， <code>-f</code> 可以跟踪所有「子进程」，就像大家知道的那样 Linux 线程仅仅是披了件风衣的进程（或者其他方式）。所以，让我们看一下：</p>
<pre tabindex="0"><code class="language-nil" data-lang="nil">$ cargo build --quiet --release &amp;&amp; strace -f -e &#39;connect&#39; ./target/release/waytoodeep
strace: Process 154612 attached
strace: Process 154613 attached
strace: Process 154614 attached
strace: Process 154615 attached
strace: Process 154616 attached
strace: Process 154617 attached
strace: Process 154618 attached
strace: Process 154619 attached
strace: Process 154620 attached
strace: Process 154621 attached
strace: Process 154622 attached
strace: Process 154623 attached
strace: Process 154624 attached
strace: Process 154625 attached
strace: Process 154626 attached
strace: Process 154627 attached
strace: Process 154628 attached
[pid 154627] connect(9, {sa_family=AF_UNIX, sun_path=&#34;/var/run/nscd/socket&#34;}, 110) = -1 ENOENT (No such file or directory)
[pid 154628] connect(10, {sa_family=AF_UNIX, sun_path=&#34;/var/run/nscd/socket&#34;}, 110) = -1 ENOENT (No such file or directory)
[pid 154627] connect(9, {sa_family=AF_UNIX, sun_path=&#34;/var/run/nscd/socket&#34;}, 110) = -1 ENOENT (No such file or directory)
[pid 154628] connect(9, {sa_family=AF_INET, sin_port=htons(53), sin_addr=inet_addr(&#34;127.0.0.53&#34;)}, 16) = 0
[pid 154627] connect(10, {sa_family=AF_INET, sin_port=htons(53), sin_addr=inet_addr(&#34;127.0.0.53&#34;)}, 16) = 0
[pid 154627] connect(9, {sa_family=AF_INET6, sin6_port=htons(0), sin6_flowinfo=htonl(0), inet_pton(AF_INET6, &#34;2606:4700:3034::6815:5ca9&#34;, &amp;sin6_addr), sin6_scope_id=0}, 28) = -1 ENETUNREACH (Network is unreachable)
[pid 154627] connect(9, {sa_family=AF_UNSPEC, sa_data=&#34;\0\0\0\0\0\0\0\0\0\0\0\0\0\0&#34;}, 16) = 0
[pid 154627] connect(9, {sa_family=AF_INET6, sin6_port=htons(0), sin6_flowinfo=htonl(0), inet_pton(AF_INET6, &#34;2606:4700:3031::ac43:c490&#34;, &amp;sin6_addr), sin6_scope_id=0}, 28) = -1 ENETUNREACH (Network is unreachable)
[pid 154627] connect(9, {sa_family=AF_UNSPEC, sa_data=&#34;\0\0\0\0\0\0\0\0\0\0\0\0\0\0&#34;}, 16) = 0
[pid 154627] connect(9, {sa_family=AF_INET, sin_port=htons(0), sin_addr=inet_addr(&#34;104.21.92.169&#34;)}, 16) = 0
[pid 154627] connect(9, {sa_family=AF_UNSPEC, sa_data=&#34;\0\0\0\0\0\0\0\0\0\0\0\0\0\0&#34;}, 16) = 0
[pid 154627] connect(9, {sa_family=AF_INET, sin_port=htons(0), sin_addr=inet_addr(&#34;172.67.196.144&#34;)}, 16) = 0
[pid 154628] connect(10, {sa_family=AF_INET6, sin6_port=htons(0), sin6_flowinfo=htonl(0), inet_pton(AF_INET6, &#34;2606:4700:3034::6815:5ca9&#34;, &amp;sin6_addr), sin6_scope_id=0}, 28) = -1 ENETUNREACH (Network is unreachable)
[pid 154628] connect(10, {sa_family=AF_UNSPEC, sa_data=&#34;\0\0\0\0\0\0\0\0\0\0\0\0\0\0&#34;}, 16) = 0
[pid 154628] connect(10, {sa_family=AF_INET6, sin6_port=htons(0), sin6_flowinfo=htonl(0), inet_pton(AF_INET6, &#34;2606:4700:3031::ac43:c490&#34;, &amp;sin6_addr), sin6_scope_id=0}, 28) = -1 ENETUNREACH (Network is unreachable)
[pid 154628] connect(10, {sa_family=AF_UNSPEC, sa_data=&#34;\0\0\0\0\0\0\0\0\0\0\0\0\0\0&#34;}, 16) = 0
[pid 154628] connect(10, {sa_family=AF_INET, sin_port=htons(0), sin_addr=inet_addr(&#34;104.21.92.169&#34;)}, 16) = 0
[pid 154628] connect(10, {sa_family=AF_UNSPEC, sa_data=&#34;\0\0\0\0\0\0\0\0\0\0\0\0\0\0&#34;}, 16) = 0
[pid 154628] connect(10, {sa_family=AF_INET, sin_port=htons(0), sin_addr=inet_addr(&#34;172.67.196.144&#34;)}, 16) = 0
[pid 154625] connect(9, {sa_family=AF_INET, sin_port=htons(443), sin_addr=inet_addr(&#34;104.21.92.169&#34;)}, 16) = -1 EINPROGRESS (Operation now in progress)
[pid 154626] connect(10, {sa_family=AF_INET, sin_port=htons(443), sin_addr=inet_addr(&#34;104.21.92.169&#34;)}, 16) = -1 EINPROGRESS (Operation now in progress)
Jul 25 19:00:53.862  INFO waytoodeep: Got a response! url=https://fasterthanli.me/articles/whats-in-the-box content_type=Some(&#34;text/html; charset=utf-8&#34;)
Jul 25 19:00:53.880  INFO waytoodeep: Got a response! url=https://fasterthanli.me/series/advent-of-code-2020/part-13 content_type=Some(&#34;text/html; charset=utf-8&#34;)
[pid 154628] +++ exited with 0 +++
[pid 154627] +++ exited with 0 +++
[pid 154618] +++ exited with 0 +++
[pid 154614] +++ exited with 0 +++
[pid 154612] +++ exited with 0 +++
[pid 154619] +++ exited with 0 +++
[pid 154617] +++ exited with 0 +++
[pid 154613] +++ exited with 0 +++
[pid 154615] +++ exited with 0 +++
[pid 154623] +++ exited with 0 +++
[pid 154616] +++ exited with 0 +++
[pid 154624] +++ exited with 0 +++
[pid 154621] +++ exited with 0 +++
[pid 154622] +++ exited with 0 +++
[pid 154626] +++ exited with 0 +++
[pid 154620] +++ exited with 0 +++
[pid 154625] +++ exited with 0 +++
+++ exited with 0 +++shell
</code></pre><p>哇哦，一大堆 <code>connect</code> 。</p>
<p>所以程序首先尝试连接 <a href="https://jameshfisher.com/2018/02/05/dont-use-nscd/">nscd</a> 因为显然我们依然生活在 90 年代：</p>
<pre tabindex="0"><code class="language-nil" data-lang="nil">[pid 154627] connect(9, {sa_family=AF_UNIX, sun_path=&#34;/var/run/nscd/socket&#34;}, 110) = -1 ENOENT (No such file or directory)
</code></pre><p>。。。幸好我的系统没有它，所以它继续通过 <code>/etc/resolv.conf</code> 查询 DNS：</p>
<pre tabindex="0"><code class="language-nil" data-lang="nil">[pid 154628] connect(9, {sa_family=AF_INET, sin_port=htons(53), sin_addr=inet_addr(&#34;127.0.0.53&#34;)}, 16) = 0
</code></pre><p>然后最终获得一些 <a href="https://www.cloudflare.com/ips/">Cloudflare 的 IP 地址</a>，如 <code>172.67.196.144</code> 和 <code>104.21.92.169</code> 。还有一些 IPv6 相关的，由于我禁用了 IPv6 所以并没有工作：</p>
<pre tabindex="0"><code class="language-nil" data-lang="nil">[pid 154627] connect(9, {sa_family=AF_INET6, sin6_port=htons(0), sin6_flowinfo=htonl(0), inet_pton(AF_INET6, &#34;2606:4700:3034::6815:5ca9&#34;, &amp;sin6_addr), sin6_scope_id=0}, 28) = -1 ENETUNREACH (Network is unreachable)
</code></pre><p>然后终于程序决定使用 IPv4 的地址 <code>104.21.92.169</code> 去构建请求，同时我们能看到这些都是非阻塞的（non-blocking）连接，因为 <code>connect</code> 返回 <code>-1</code> 而不是 <code>0</code> 表示「正在连接、正在连接、稍后回来检查」。</p>
<pre tabindex="0"><code class="language-nil" data-lang="nil">[pid 154625] connect(9, {sa_family=AF_INET, sin_port=htons(443), sin_addr=inet_addr(&#34;104.21.92.169&#34;)}, 16) = -1 EINPROGRESS (Operation now in progress)
[pid 154626] connect(10, {sa_family=AF_INET, sin_port=htons(443), sin_addr=inet_addr(&#34;104.21.92.169&#34;)}, 16) = -1 EINPROGRESS (Operation now in progress)
</code></pre><p>好了！所以忽略 <a href="https://isitdns.com/">DNS</a> 的话我们看到了两个连接。</p>
<p>同时我们看到了一些线程。</p>
<p>这就是 Rust 异步的工作方式？我们只是用了一些线程？这也就是它能在「后台运行」的原因？</p>
<p>在我们回答这些问题前，让我们先调整我们的代码真正的去等待 future 完成，而不是随意的休眠 1 秒钟。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">#[tokio::main]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() -&gt; Result<span style="color:#f92672">&lt;</span>(), Report<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>	setup()<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> client <span style="color:#f92672">=</span> Client::new();
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> leaked_client <span style="color:#f92672">=</span> Box::leak(Box::new(client));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> fut1 <span style="color:#f92672">=</span> fetch_thing(leaked_client, URL_1);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> fut2 <span style="color:#f92672">=</span> fetch_thing(leaked_client, URL_2);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> handle1 <span style="color:#f92672">=</span> tokio::spawn(fut1);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> handle2 <span style="color:#f92672">=</span> tokio::spawn(fut2);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	handle1.<span style="color:#66d9ef">await</span>.unwrap()<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>	handle2.<span style="color:#66d9ef">await</span>.unwrap()<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	Ok(())
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>等等，我们这不又回到原点吗？等待第一个请求完成，然后才开始第二个请求。</p>
<p>当然不是！我们运行几次就可以看到：</p>
<pre tabindex="0"><code class="language-nil" data-lang="nil">$ RUST_LOG=info cargo run --quiet --release
Jul 25 19:11:07.934  INFO waytoodeep: Got a response! url=https://fasterthanli.me/articles/whats-in-the-box content_type=Some(&#34;text/html; charset=utf-8&#34;)
Jul 25 19:11:07.958  INFO waytoodeep: Got a response! url=https://fasterthanli.me/series/advent-of-code-2020/part-13 content_type=Some(&#34;text/html; charset=utf-8&#34;)
$ RUST_LOG=info cargo run --quiet --release
Jul 25 19:11:08.676  INFO waytoodeep: Got a response! url=https://fasterthanli.me/articles/whats-in-the-box content_type=Some(&#34;text/html; charset=utf-8&#34;)
Jul 25 19:11:08.680  INFO waytoodeep: Got a response! url=https://fasterthanli.me/series/advent-of-code-2020/part-13 content_type=Some(&#34;text/html; charset=utf-8&#34;)
$ RUST_LOG=info cargo run --quiet --release
Jul 25 19:11:09.325  INFO waytoodeep: Got a response! url=https://fasterthanli.me/articles/whats-in-the-box content_type=Some(&#34;text/html; charset=utf-8&#34;)
Jul 25 19:11:09.338  INFO waytoodeep: Got a response! url=https://fasterthanli.me/series/advent-of-code-2020/part-13 content_type=Some(&#34;text/html; charset=utf-8&#34;)
$ RUST_LOG=info cargo run --quiet --release
Jul 25 19:11:10.134  INFO waytoodeep: Got a response! url=https://fasterthanli.me/series/advent-of-code-2020/part-13 content_type=Some(&#34;text/html; charset=utf-8&#34;)
Jul 25 19:11:10.144  INFO waytoodeep: Got a response! url=https://fasterthanli.me/articles/whats-in-the-box content_type=Some(&#34;text/html; charset=utf-8&#34;)
</code></pre><p>。。。大部分情况下“whats-in-the-box”胜出了（它确实先开始），但是“advent-of-code-2020”也首先完成了几次。这也是我们希望看到的。</p>
<blockquote>
<p>谬论：也就是说因为有线程请求被并行（parallel）的执行了。</p>
</blockquote>
<p>不是的。但是不要相信我，让我们继续深入。</p>
<h3 id="不是因为线程">不是因为线程<a href="#不是因为线程" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>让我们通过 GDB 运行我们的小程序，大部分原因是我还没有对 LLDB 形成肌肉记忆，我相信这是水到渠成的事。</p>
<pre tabindex="0"><code class="language-nil" data-lang="nil">$ cargo build --quiet &amp;&amp; gdb --quiet --args ./target/debug/waytoodeep
Reading symbols from ./target/debug/waytoodeep...
warning: Missing auto-load script at offset 0 in section .debug_gdb_scripts
of file /home/amos/ftl/waytoodeep/target/debug/waytoodeep.
Use `info auto-load python-scripts [REGEXP]&#39; to list them.
(gdb)
</code></pre><p>一切就绪！</p>
<p>在我们开始之前先设置一下断点。我说了断点？应该是捕捉点（catchpoint）。我不知道参与构造 HTTP/2 请求的所有函数名，但是我知道 <code>connect</code> 对应的系统调用（syscall），这也是我们需要打断点的地方，或者捕捉（catch）。</p>
<pre tabindex="0"><code class="language-nil" data-lang="nil">(gdb) catch syscall connect
Catchpoint 1 (syscall &#39;connect&#39; [42])
</code></pre><p>现在我们开始！</p>
<pre tabindex="0"><code class="language-nil" data-lang="nil">$ Starting program: /home/amos/ftl/waytoodeep/target/debug/waytoodeep
[Thread debugging using libthread_db enabled]
Using host libthread_db library &#34;/lib/x86_64-linux-gnu/libthread_db.so.1&#34;.
[New Thread 0x7ffff7c28700 (LWP 158945)]
[New Thread 0x7ffff7a27700 (LWP 158946)]
[New Thread 0x7fffef826700 (LWP 158947)]
[New Thread 0x7ffff7826700 (LWP 158948)]
[New Thread 0x7ffff7625700 (LWP 158949)]
[New Thread 0x7ffff7424700 (LWP 158950)]
[New Thread 0x7ffff7223700 (LWP 158951)]
[New Thread 0x7ffff701f700 (LWP 158952)]
[New Thread 0x7ffff6e1e700 (LWP 158953)]
[New Thread 0x7ffff6c1a700 (LWP 158954)]
[New Thread 0x7ffff6a16700 (LWP 158955)]
[New Thread 0x7ffff680f700 (LWP 158956)]
[New Thread 0x7ffff660e700 (LWP 158957)]
[New Thread 0x7ffff640a700 (LWP 158958)]
[New Thread 0x7ffff6206700 (LWP 158959)]
[New Thread 0x7ffff5f4b700 (LWP 158960)]
[New Thread 0x7ffff5d4a700 (LWP 158961)]
[Switching to Thread 0x7ffff5f4b700 (LWP 158960)]

Thread 17 &#34;tokio-runtime-w&#34; hit Catchpoint 1 (call to syscall connect), 0x00007ffff7d5033b in __libc_connect (fd=fd@entry=9, addr=..., addr@entry=...,
	len=len@entry=110) at ../sysdeps/unix/sysv/linux/connect.c:26
26      ../sysdeps/unix/sysv/linux/connect.c: No such file or directory.
(gdb)
</code></pre><p>不错不错，真快！我们停在了名为 <code>tokio-runtime-w</code> 的 <code>Thread 17</code> 中，因为我猜其他所有字母都被使用了。</p>
<blockquote>
<p><code>w</code> 意味这 <code>worker</code> ，如果你不是第一天用 Unix 就会知道什么这么简写。</p>
</blockquote>
<p>好的， <code>Thread 17</code> ，那么其他线程在做什么呢？</p>
<pre tabindex="0"><code class="language-nil" data-lang="nil">(gdb) info threads
  Id   Target Id                                            Frame
  1    Thread 0x7ffff7c2c6c0 (LWP 158941) &#34;waytoodeep&#34;      syscall () at ../sysdeps/unix/sysv/linux/x86_64/syscall.S:38
  2    Thread 0x7ffff7c28700 (LWP 158945) &#34;tokio-runtime-w&#34; syscall () at ../sysdeps/unix/sysv/linux/x86_64/syscall.S:38
  3    Thread 0x7ffff7a27700 (LWP 158946) &#34;tokio-runtime-w&#34; 0x00007ffff7d4f5ce in epoll_wait (epfd=3, events=0x555556338b60, maxevents=1024, timeout=-1)
	at ../sysdeps/unix/sysv/linux/epoll_wait.c:30
  4    Thread 0x7fffef826700 (LWP 158947) &#34;tokio-runtime-w&#34; syscall () at ../sysdeps/unix/sysv/linux/x86_64/syscall.S:38
  5    Thread 0x7ffff7826700 (LWP 158948) &#34;tokio-runtime-w&#34; syscall () at ../sysdeps/unix/sysv/linux/x86_64/syscall.S:38
  6    Thread 0x7ffff7625700 (LWP 158949) &#34;tokio-runtime-w&#34; syscall () at ../sysdeps/unix/sysv/linux/x86_64/syscall.S:38
  7    Thread 0x7ffff7424700 (LWP 158950) &#34;tokio-runtime-w&#34; syscall () at ../sysdeps/unix/sysv/linux/x86_64/syscall.S:38
  8    Thread 0x7ffff7223700 (LWP 158951) &#34;tokio-runtime-w&#34; syscall () at ../sysdeps/unix/sysv/linux/x86_64/syscall.S:38
  9    Thread 0x7ffff701f700 (LWP 158952) &#34;tokio-runtime-w&#34; syscall () at ../sysdeps/unix/sysv/linux/x86_64/syscall.S:38
  10   Thread 0x7ffff6e1e700 (LWP 158953) &#34;tokio-runtime-w&#34; syscall () at ../sysdeps/unix/sysv/linux/x86_64/syscall.S:38
  11   Thread 0x7ffff6c1a700 (LWP 158954) &#34;tokio-runtime-w&#34; syscall () at ../sysdeps/unix/sysv/linux/x86_64/syscall.S:38
  12   Thread 0x7ffff6a16700 (LWP 158955) &#34;tokio-runtime-w&#34; syscall () at ../sysdeps/unix/sysv/linux/x86_64/syscall.S:38
  13   Thread 0x7ffff680f700 (LWP 158956) &#34;tokio-runtime-w&#34; syscall () at ../sysdeps/unix/sysv/linux/x86_64/syscall.S:38
  14   Thread 0x7ffff660e700 (LWP 158957) &#34;tokio-runtime-w&#34; syscall () at ../sysdeps/unix/sysv/linux/x86_64/syscall.S:38
  15   Thread 0x7ffff640a700 (LWP 158958) &#34;tokio-runtime-w&#34; syscall () at ../sysdeps/unix/sysv/linux/x86_64/syscall.S:38
  16   Thread 0x7ffff6206700 (LWP 158959) &#34;tokio-runtime-w&#34; syscall () at ../sysdeps/unix/sysv/linux/x86_64/syscall.S:38
 *17   Thread 0x7ffff5f4b700 (LWP 158960) &#34;tokio-runtime-w&#34; 0x00007ffff7d5033b in __libc_connect (fd=fd@entry=9, addr=..., addr@entry=..., len=len@entry=110)
	at ../sysdeps/unix/sysv/linux/connect.c:26
  18   Thread 0x7ffff5d4a700 (LWP 158961) &#34;tokio-runtime-w&#34; 0x00007ffff7d48a46 in __GI___mmap64 (offset=0, fd=-1, flags=16418, prot=0, len=134217728, addr=0x0)
	at ../sysdeps/unix/sysv/linux/mmap64.c:59
</code></pre><p>额。</p>
<p>我们可以获得更多的栈帧？</p>
<pre tabindex="0"><code class="language-nil" data-lang="nil">(gdb) thread apply all backtrace 2

Thread 18 (Thread 0x7ffff5d4a700 (LWP 158961)):
#0  0x00007ffff7d48a46 in __GI___mmap64 (offset=0, fd=-1, flags=16418, prot=0, len=134217728, addr=0x0) at ../sysdeps/unix/sysv/linux/mmap64.c:59
#1  __GI___mmap64 (addr=addr@entry=0x0, len=len@entry=134217728, prot=prot@entry=0, flags=flags@entry=16418, fd=fd@entry=-1, offset=offset@entry=0) at ../sysdeps/unix/sysv/linux/mmap64.c:47
(More stack frames follow...)

Thread 17 (Thread 0x7ffff5f4b700 (LWP 158960)):
#0  0x00007ffff7d5033b in __libc_connect (fd=fd@entry=9, addr=..., addr@entry=..., len=len@entry=110) at ../sysdeps/unix/sysv/linux/connect.c:26
#1  0x00007ffff7d8b713 in open_socket (type=type@entry=GETFDHST, key=key@entry=0x7ffff7de5ccb &#34;hosts&#34;, keylen=keylen@entry=6) at nscd_helper.c:185
(More stack frames follow...)

Thread 16 (Thread 0x7ffff6206700 (LWP 158959)):
#0  syscall () at ../sysdeps/unix/sysv/linux/x86_64/syscall.S:38
#1  0x0000555555b9f1d1 in parking_lot_core::thread_parker::imp::ThreadParker::futex_wait (self=0x7ffff6206498, ts=...) at /home/amos/.cargo/registry/src/github.com-1ecc6299db9ec823/parking_lot_core-0.8.3/src/thread_parker/linux.rs:112
(More stack frames follow...)

Thread 15 (Thread 0x7ffff640a700 (LWP 158958)):
#0  syscall () at ../sysdeps/unix/sysv/linux/x86_64/syscall.S:38
#1  0x0000555555b9f1d1 in parking_lot_core::thread_parker::imp::ThreadParker::futex_wait (self=0x7ffff640a498, ts=...) at /home/amos/.cargo/registry/src/github.com-1ecc6299db9ec823/parking_lot_core-0.8.3/src/thread_parker/linux.rs:112
(More stack frames follow...)

Thread 14 (Thread 0x7ffff660e700 (LWP 158957)):
#0  syscall () at ../sysdeps/unix/sysv/linux/x86_64/syscall.S:38
#1  0x0000555555b9f1d1 in parking_lot_core::thread_parker::imp::ThreadParker::futex_wait (self=0x7ffff660e498, ts=...) at /home/amos/.cargo/registry/src/github.com-1ecc6299db9ec823/parking_lot_core-0.8.3/src/thread_parker/linux.rs:112
(More stack frames follow...)

Thread 13 (Thread 0x7ffff680f700 (LWP 158956)):
#0  syscall () at ../sysdeps/unix/sysv/linux/x86_64/syscall.S:38
#1  0x0000555555b9f1d1 in parking_lot_core::thread_parker::imp::ThreadParker::futex_wait (self=0x7ffff680f498, ts=...) at /home/amos/.cargo/registry/src/github.com-1ecc6299db9ec823/parking_lot_core-0.8.3/src/thread_parker/linux.rs:112
(More stack frames follow...)
</code></pre><p>额。大部分都是挂起的。也就是空闲的。更准确的是它们在等待工作。</p>
<p>我们也可以通过 htop 查看这些所有线程，我知道我们已经看到了，但是我仅仅是觉得 htop 很棒。感谢 <a href="https://twitter.com/hisham%5Fhm">Hisham</a>！
<img src="https://fasterthanli.me/content/articles/understanding-rust-futures-by-going-way-too-deep/assets/htop-colors.571c5effbff8a0b3.webp" alt="">
所以，我们注意到一些线程，同时也有一些 CPU 核心。可能是一个 CPU 核心一个线程？
<img src="https://fasterthanli.me/content/articles/understanding-rust-futures-by-going-way-too-deep/assets/worker-threads.64dbe39e33ccfc4f.webp" alt="">
是的。然后还有一些阻塞的线程，正如我们从上面 <code>strace</code> 输出看到的那样， 它会进行一些阻塞的 <code>connect</code> 调用去查询 DNS（实际是 glibc 在执行），
所以它通过运行在工作线程之外避免阻塞其他任务。</p>
<blockquote>
<p>所以多个线程，这就是为什么一次可以运行多个请求的原因？</p>
</blockquote>
<p>实际上文档上表明这是一个单线程的执行器，我也不能确定，所以让我们试一下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">//                           👇
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#[tokio::main(flavor = </span><span style="color:#e6db74">&#34;current_thread&#34;</span><span style="color:#75715e">)]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() -&gt; Result<span style="color:#f92672">&lt;</span>(), Report<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// (same as before)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><pre tabindex="0"><code class="language-nil" data-lang="nil">$ RUST_LOG=info cargo run --quiet --release
Jul 25 19:50:15.977  INFO waytoodeep: Got a response! url=https://fasterthanli.me/articles/whats-in-the-box content_type=Some(&#34;text/html; charset=utf-8&#34;)
Jul 25 19:50:15.994  INFO waytoodeep: Got a response! url=https://fasterthanli.me/series/advent-of-code-2020/part-13 content_type=Some(&#34;text/html; charset=utf-8&#34;)
</code></pre><p>两个响应间隔 <code>17ms</code> ，这个时间不够构造一个完整的请求，所以请求并行（parallel）的执行了。如果你依然坚持它内部使用了线程，让我们进一步确认我们只有一个线程：
<img src="https://fasterthanli.me/content/articles/understanding-rust-futures-by-going-way-too-deep/assets/current-thread.cd7b619ed644899b.webp" alt="">
确实有多个线程，但是这些都是阻塞线程。仅仅是 DNS 查询。可以通过 htop 看到已经没有无数（15）的工作线程了：
<img src="https://fasterthanli.me/content/articles/understanding-rust-futures-by-going-way-too-deep/assets/htop-current-thread.fe28174abc5d15fa.webp" alt="">
（顺便说一下 15 个工作线程的原因，这是因为我预留了一个 CPU 核心没有分配给虚拟机，这样即使虚拟机全速运行也不会导致宿主机停止响应）。</p>
<p>如果我们将 DNS 查询排除在外，我们就可以看到实际上仅仅使用了一个线程，我们将继续下去，以防你依然存疑！</p>
<h3 id="插曲-让我们避免泄漏内存">插曲：让我们避免泄漏内存<a href="#插曲-让我们避免泄漏内存" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>但是在那之前：正在泄漏 reqwest 的 <code>Client</code> 让我很不爽。</p>
<p>为了避免，我们可以创建一个原子引用计数（atomically-reference-counted），这样它就可以随着任务运行而存活。</p>
<p>修改起来非常简单：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">//             👇 Atomically Reference Counted = Arc
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">use</span> std::sync::Arc;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#[tokio::main(flavor = </span><span style="color:#e6db74">&#34;current_thread&#34;</span><span style="color:#75715e">)]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() -&gt; Result<span style="color:#f92672">&lt;</span>(), Report<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>	setup()<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//           👇 there we go
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">let</span> client <span style="color:#f92672">=</span> Arc::new(Client::new());
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//                              👇
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">let</span> fut1 <span style="color:#f92672">=</span> fetch_thing(client.clone(), URL_1);
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// (cloning it only increases the reference count)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">let</span> fut2 <span style="color:#f92672">=</span> fetch_thing(client.clone(), URL_2);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> handle1 <span style="color:#f92672">=</span> tokio::spawn(fut1);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> handle2 <span style="color:#f92672">=</span> tokio::spawn(fut2);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	handle1.<span style="color:#66d9ef">await</span>.unwrap()<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>	handle2.<span style="color:#66d9ef">await</span>.unwrap()<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	Ok(())
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#[allow(clippy::manual_async_fn)]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">fetch_thing</span>(
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//       👇 now taking this, we have shared ownership of it
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	client: <span style="color:#a6e22e">Arc</span><span style="color:#f92672">&lt;</span>Client<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>	url: <span style="color:#66d9ef">&amp;</span><span style="color:#f92672">&#39;</span>static <span style="color:#66d9ef">str</span>,
</span></span><span style="display:flex;"><span>) -&gt; <span style="color:#a6e22e">impl</span> Future<span style="color:#f92672">&lt;</span>Output <span style="color:#f92672">=</span> Result<span style="color:#f92672">&lt;</span>(), Report<span style="color:#f92672">&gt;&gt;</span> <span style="color:#f92672">+</span> <span style="color:#f92672">&#39;</span>static {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">async</span> <span style="color:#66d9ef">move</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// luckily this  👇 only requires `&amp;self`
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">let</span> res <span style="color:#f92672">=</span> client.get(url).send().<span style="color:#66d9ef">await</span><span style="color:#f92672">?</span>.error_for_status()<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>		info<span style="color:#f92672">!</span>(<span style="color:#f92672">%</span>url, content_type <span style="color:#f92672">=</span> <span style="color:#f92672">?</span>res.headers().get(<span style="color:#e6db74">&#34;content-type&#34;</span>), <span style="color:#e6db74">&#34;Got a response!&#34;</span>);
</span></span><span style="display:flex;"><span>		Ok(())
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>好了，现在我感觉好多了。我们的程序不再泄漏一些字节即使它永远不会运行超过几秒钟。一切都还好。</p>
<p>让我们看一下 <code>reqwest</code> 的 <code>Client</code> 定义:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">#[derive(Clone)]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Client</span> {
</span></span><span style="display:flex;"><span>	inner: <span style="color:#a6e22e">Arc</span><span style="color:#f92672">&lt;</span>ClientRef<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>它已经是引用计数的了，所以我们可以直接接受一个 <code>Client</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">#[tokio::main(flavor = </span><span style="color:#e6db74">&#34;current_thread&#34;</span><span style="color:#75715e">)]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() -&gt; Result<span style="color:#f92672">&lt;</span>(), Report<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>	setup()<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//             👇
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">let</span> client <span style="color:#f92672">=</span> Client::new();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//                              👇
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">let</span> fut1 <span style="color:#f92672">=</span> fetch_thing(client.clone(), URL_1);
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// no need to clone a second time
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">let</span> fut2 <span style="color:#f92672">=</span> fetch_thing(client, URL_2);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> handle1 <span style="color:#f92672">=</span> tokio::spawn(fut1);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> handle2 <span style="color:#f92672">=</span> tokio::spawn(fut2);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	handle1.<span style="color:#66d9ef">await</span>.unwrap()<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>	handle2.<span style="color:#66d9ef">await</span>.unwrap()<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	Ok(())
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#[allow(clippy::manual_async_fn)]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">fetch_thing</span>(
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//        👇
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	client: <span style="color:#a6e22e">Client</span>,
</span></span><span style="display:flex;"><span>	url: <span style="color:#66d9ef">&amp;</span><span style="color:#f92672">&#39;</span>static <span style="color:#66d9ef">str</span>,
</span></span><span style="display:flex;"><span>) -&gt; <span style="color:#a6e22e">impl</span> Future<span style="color:#f92672">&lt;</span>Output <span style="color:#f92672">=</span> Result<span style="color:#f92672">&lt;</span>(), Report<span style="color:#f92672">&gt;&gt;</span> <span style="color:#f92672">+</span> <span style="color:#f92672">&#39;</span>static {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">async</span> <span style="color:#66d9ef">move</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">let</span> res <span style="color:#f92672">=</span> client.get(url).send().<span style="color:#66d9ef">await</span><span style="color:#f92672">?</span>.error_for_status()<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>		info<span style="color:#f92672">!</span>(<span style="color:#f92672">%</span>url, content_type <span style="color:#f92672">=</span> <span style="color:#f92672">?</span>res.headers().get(<span style="color:#e6db74">&#34;content-type&#34;</span>), <span style="color:#e6db74">&#34;Got a response!&#34;</span>);
</span></span><span style="display:flex;"><span>		Ok(())
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>好了。</p>
<p>对了，仅供参考，更简单的 <code>async fn</code> 也可以工作了：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">fetch_thing</span>(client: <span style="color:#a6e22e">Client</span>, url: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>) -&gt; Result<span style="color:#f92672">&lt;</span>(), Report<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> res <span style="color:#f92672">=</span> client.get(url).send().<span style="color:#66d9ef">await</span><span style="color:#f92672">?</span>.error_for_status()<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>	info<span style="color:#f92672">!</span>(<span style="color:#f92672">%</span>url, content_type <span style="color:#f92672">=</span> <span style="color:#f92672">?</span>res.headers().get(<span style="color:#e6db74">&#34;content-type&#34;</span>), <span style="color:#e6db74">&#34;Got a response!&#34;</span>);
</span></span><span style="display:flex;"><span>	Ok(())
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>我们甚至不需要要求 <code>url</code> 的借用生命周期是 <code>'static</code> 。如果 <code>url</code> 是 <code>'static</code> 的则返回的 Future 也是，反之亦然。</p>
<p>作为例子，下面代码无法通过编译：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">#[tokio::main(flavor = </span><span style="color:#e6db74">&#34;current_thread&#34;</span><span style="color:#75715e">)]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() -&gt; Result<span style="color:#f92672">&lt;</span>(), Report<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>	setup()<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> client <span style="color:#f92672">=</span> Client::new();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// this is a `String`, owned by main
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">let</span> url1 <span style="color:#f92672">=</span> String::from(URL_1);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// we&#39;re borrowing from main           👇
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">let</span> fut1 <span style="color:#f92672">=</span> fetch_thing(client.clone(), <span style="color:#f92672">&amp;</span>url1);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> fut2 <span style="color:#f92672">=</span> fetch_thing(client, URL_2);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> handle1 <span style="color:#f92672">=</span> tokio::spawn(fut1);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> handle2 <span style="color:#f92672">=</span> tokio::spawn(fut2);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	handle1.<span style="color:#66d9ef">await</span>.unwrap()<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>	handle2.<span style="color:#66d9ef">await</span>.unwrap()<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	Ok(())
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><pre tabindex="0"><code class="language-nil" data-lang="nil">$ cargo check
	Checking waytoodeep v0.1.0 (/home/amos/ftl/waytoodeep)

error[E0597]: `url1` does not live long enough
  --&gt; src/main.rs:18:44
   |
18 |     let fut1 = fetch_thing(client.clone(), &amp;url1);
   |                ----------------------------^^^^^-
   |                |                           |
   |                |                           borrowed value does not live long enough
   |                argument requires that `url1` is borrowed for `&#39;static`
...
28 | }
   | - `url1` dropped here while still borrowed
</code></pre><blockquote>
<p>你面对的考验就是：修改了一些代码，然后突然间整个 <code>Future</code> 不再实现 <code>Send</code> ，但是你需要它实现 <code>Send</code> 。参考<a href="https://fasterthanli.me/articles/getting-in-and-out-of-trouble-with-rust-futures">Getting in and out of trouble with Rust futures</a>。</p>
</blockquote>
<p>在我们进一步深入之前，我们还想提一下，除了通过 <code>tokio::spawn</code> 可以同时运行两个 future 并且立即等待两个 future 完成，还是使用 <code>FuturesUnordered</code> 实现相同目的。</p>
<pre tabindex="0"><code class="language-nil" data-lang="nil">$ cargo add futures@0.3.16
	Updating &#39;https://github.com/rust-lang/crates.io-index&#39; index
	  Adding futures v0.3.16 to dependencies
</code></pre><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">use</span> futures::{stream::FuturesUnordered, StreamExt};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#[tokio::main(flavor = </span><span style="color:#e6db74">&#34;current_thread&#34;</span><span style="color:#75715e">)]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() -&gt; Result<span style="color:#f92672">&lt;</span>(), Report<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>	setup()<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> client <span style="color:#f92672">=</span> Client::new();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> group <span style="color:#f92672">=</span> vec![
</span></span><span style="display:flex;"><span>		fetch_thing(client.clone(), URL_1),
</span></span><span style="display:flex;"><span>		fetch_thing(client, URL_2),
</span></span><span style="display:flex;"><span>	]
</span></span><span style="display:flex;"><span>	.into_iter()
</span></span><span style="display:flex;"><span>	.collect::<span style="color:#f92672">&lt;</span>FuturesUnordered<span style="color:#f92672">&lt;</span>_<span style="color:#f92672">&gt;&gt;</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">while</span> <span style="color:#66d9ef">let</span> Some(item) <span style="color:#f92672">=</span> group.next().<span style="color:#66d9ef">await</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// propagate errors
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		item<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	Ok(())
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>通过这个解决半啃啊，我们可以 await 任意数量的 future 对象，同时也是并发的被轮询（polled）。</p>
<pre tabindex="0"><code class="language-nil" data-lang="nil">$ RUST_LOG=info cargo run --quiet --release
Jul 25 20:12:37.208  INFO waytoodeep: Got a response! url=https://fasterthanli.me/articles/whats-in-the-box content_type=Some(&#34;text/html; charset=utf-8&#34;)
Jul 25 20:12:37.227  INFO waytoodeep: Got a response! url=https://fasterthanli.me/series/advent-of-code-2020/part-13 content_type=Some(&#34;text/html; charset=utf-8&#34;)
</code></pre><p>仅仅。。。19 毫秒的间隔 &ndash; 可以确定是并发的。</p>
<h3 id="彻底摆脱-dns">彻底摆脱 DNS<a href="#彻底摆脱-dns" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>现在让我们暂时忘掉 <code>reqwest</code> 。</p>
<p>HTTP <a href="https://fasterthanli.me/articles/aiming-for-correctness-with-types">并不难</a> ，我们可以自己构建。只要 TCP 就行：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">use</span> std::net::SocketAddr;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">use</span> tokio::{
</span></span><span style="display:flex;"><span>	io::{AsyncReadExt, AsyncWriteExt},
</span></span><span style="display:flex;"><span>	net::TcpStream,
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">fetch_thing</span>(name: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>) -&gt; Result<span style="color:#f92672">&lt;</span>(), Report<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// look mom, no DNS!
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">let</span> addr: <span style="color:#a6e22e">SocketAddr</span> <span style="color:#f92672">=</span> ([<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>], <span style="color:#ae81ff">80</span>).into();
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> socket <span style="color:#f92672">=</span> TcpStream::connect(addr).<span style="color:#66d9ef">await</span><span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// we&#39;re writing straight to the socket, there&#39;s no buffering
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// so no need to flush
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	socket.write_all(<span style="color:#e6db74">b&#34;GET / HTTP/1.1</span><span style="color:#ae81ff">\r\n</span><span style="color:#e6db74">&#34;</span>).<span style="color:#66d9ef">await</span><span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>	socket.write_all(<span style="color:#e6db74">b&#34;Host: 1.1.1.1</span><span style="color:#ae81ff">\r\n</span><span style="color:#e6db74">&#34;</span>).<span style="color:#66d9ef">await</span><span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>	socket.write_all(<span style="color:#e6db74">b&#34;User-Agent: cool-bear</span><span style="color:#ae81ff">\r\n</span><span style="color:#e6db74">&#34;</span>).<span style="color:#66d9ef">await</span><span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>	socket.write_all(<span style="color:#e6db74">b&#34;Connection: close</span><span style="color:#ae81ff">\r\n</span><span style="color:#e6db74">&#34;</span>).<span style="color:#66d9ef">await</span><span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>	socket.write_all(<span style="color:#e6db74">b&#34;</span><span style="color:#ae81ff">\r\n</span><span style="color:#e6db74">&#34;</span>).<span style="color:#66d9ef">await</span><span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> response <span style="color:#f92672">=</span> String::with_capacity(<span style="color:#ae81ff">256</span>);
</span></span><span style="display:flex;"><span>	socket.read_to_string(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> response).<span style="color:#66d9ef">await</span><span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> status <span style="color:#f92672">=</span> response.lines().next().unwrap_or_default();
</span></span><span style="display:flex;"><span>	info<span style="color:#f92672">!</span>(<span style="color:#f92672">%</span>status, , <span style="color:#e6db74">&#34;Got response!&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// dropping the socket will close the connection
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	Ok(())
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>可以正常运行：</p>
<pre tabindex="0"><code class="language-nil" data-lang="nil">$ RUST_LOG=info cargo run --quiet --release
Jul 25 20:24:05.158  INFO waytoodeep: Got response! status=HTTP/1.1 301 Moved Permanently name=second
Jul 25 20:24:05.159  INFO waytoodeep: Got response! status=HTTP/1.1 301 Moved Permanently name=first
</code></pre><p>（看，第二个赢得了胜利）。</p>
<p>同时再也没有 DNS 查询了。</p>
<p>当然 <code>http://1.1.1.1</code> 将我们重定向到 HTTPS 的页面，技术上实现 TLS 并不困难，但是我们的篇幅已经很长了，所以。。。</p>
<pre tabindex="0"><code class="language-nil" data-lang="nil">$ cargo add tokio-rustls@0.22.0
	Updating &#39;https://github.com/rust-lang/crates.io-index&#39; index
	  Adding tokio-rustls v0.22.0 to dependencies
$ cargo add webpki@0.21.4
	Updating &#39;https://github.com/rust-lang/crates.io-index&#39; index
	  Adding webpki v0.21.4 to dependencies
$ cargo add webpki-roots@0.21.1
	Updating &#39;https://github.com/rust-lang/crates.io-index&#39; index
	  Adding webpki-roots v0.21.1 to dependencies
</code></pre><p>然后。。。</p>
<pre tabindex="0"><code class="language-nil" data-lang="nil">$ cargo rm reqwest
	Removing reqwest from dependencies
</code></pre><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">use</span> std::sync::Arc;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">use</span> webpki::DNSNameRef;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">use</span> tokio_rustls::{rustls::ClientConfig, TlsConnector};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">fetch_thing</span>(name: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>) -&gt; Result<span style="color:#f92672">&lt;</span>(), Report<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// look out it&#39;s port 443 now
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">let</span> addr: <span style="color:#a6e22e">SocketAddr</span> <span style="color:#f92672">=</span> ([<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>], <span style="color:#ae81ff">443</span>).into();
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> socket <span style="color:#f92672">=</span> TcpStream::connect(addr).<span style="color:#66d9ef">await</span><span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// establish a TLS session...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">let</span> connector: <span style="color:#a6e22e">TlsConnector</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> config <span style="color:#f92672">=</span> ClientConfig::new();
</span></span><span style="display:flex;"><span>		config
</span></span><span style="display:flex;"><span>			.root_store
</span></span><span style="display:flex;"><span>			.add_server_trust_anchors(<span style="color:#f92672">&amp;</span>webpki_roots::TLS_SERVER_ROOTS);
</span></span><span style="display:flex;"><span>		Arc::new(config).into()
</span></span><span style="display:flex;"><span>	};
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// we have to use the proper DNS name now      👇
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">let</span> dnsname <span style="color:#f92672">=</span> DNSNameRef::try_from_ascii_str(<span style="color:#e6db74">&#34;one.one.one.one&#34;</span>)<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> socket <span style="color:#f92672">=</span> connector.connect(dnsname, socket).<span style="color:#66d9ef">await</span><span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// we&#39;re writing straight to the socket, there&#39;s no buffering
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// so no need to flush
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	socket.write_all(<span style="color:#e6db74">b&#34;GET / HTTP/1.1</span><span style="color:#ae81ff">\r\n</span><span style="color:#e6db74">&#34;</span>).<span style="color:#66d9ef">await</span><span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//                        👇
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	socket.write_all(<span style="color:#e6db74">b&#34;Host: one.one.one.one</span><span style="color:#ae81ff">\r\n</span><span style="color:#e6db74">&#34;</span>).<span style="color:#66d9ef">await</span><span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>	socket.write_all(<span style="color:#e6db74">b&#34;User-Agent: cool-bear</span><span style="color:#ae81ff">\r\n</span><span style="color:#e6db74">&#34;</span>).<span style="color:#66d9ef">await</span><span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>	socket.write_all(<span style="color:#e6db74">b&#34;Connection: close</span><span style="color:#ae81ff">\r\n</span><span style="color:#e6db74">&#34;</span>).<span style="color:#66d9ef">await</span><span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>	socket.write_all(<span style="color:#e6db74">b&#34;</span><span style="color:#ae81ff">\r\n</span><span style="color:#e6db74">&#34;</span>).<span style="color:#66d9ef">await</span><span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> response <span style="color:#f92672">=</span> String::with_capacity(<span style="color:#ae81ff">256</span>);
</span></span><span style="display:flex;"><span>	socket.read_to_string(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> response).<span style="color:#66d9ef">await</span><span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> status <span style="color:#f92672">=</span> response.lines().next().unwrap_or_default();
</span></span><span style="display:flex;"><span>	info<span style="color:#f92672">!</span>(<span style="color:#f92672">%</span>status, , <span style="color:#e6db74">&#34;Got response!&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// dropping the socket will close the connection
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	Ok(())
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><pre tabindex="0"><code class="language-nil" data-lang="nil">$ RUST_LOG=info cargo run --quiet --release
Jul 25 20:31:32.627  INFO waytoodeep: Got response! status=HTTP/1.1 200 OK name=second
Jul 25 20:31:32.658  INFO waytoodeep: Got response! status=HTTP/1.1 200 OK name=first
</code></pre><p>好了，现在返回状态码 200！</p>
<p>我们的目标是了解 Rust 的 future，我们已经获得了不错的进展。</p>
<p>但是让我们考虑以下场景：我们想并发的执行两个请求，一旦其中一个失败，另外一个也应该立即请求失败，或者两个一起成功。</p>
<h3 id="tokio-的-try-join-宏">tokio 的 try_join 宏<a href="#tokio-的-try-join-宏" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>实际上，又一个宏可以做这个！</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">#[tokio::main(flavor = </span><span style="color:#e6db74">&#34;current_thread&#34;</span><span style="color:#75715e">)]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() -&gt; Result<span style="color:#f92672">&lt;</span>(), Report<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>	setup()<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> res <span style="color:#f92672">=</span> tokio::try_join<span style="color:#f92672">!</span>(fetch_thing(<span style="color:#e6db74">&#34;first&#34;</span>), fetch_thing(<span style="color:#e6db74">&#34;second&#34;</span>),)<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>	info<span style="color:#f92672">!</span>(<span style="color:#f92672">?</span>res, <span style="color:#e6db74">&#34;All done!&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	Ok(())
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>这就是我们想要的！</p>
<pre tabindex="0"><code class="language-nil" data-lang="nil">$ RUST_LOG=info cargo run --quiet --release
Jul 25 20:44:52.150  INFO waytoodeep: Got response! status=HTTP/1.1 200 OK name=first
Jul 25 20:44:52.165  INFO waytoodeep: Got response! status=HTTP/1.1 200 OK name=second
Jul 25 20:44:52.165  INFO waytoodeep: All done! res=((), ())
</code></pre><p>再次快速检查以下：响应间隔在 15ms &ndash; 也就是确定是并发的发送。</p>
<p><code>try_join!</code> 帮我们进行了 <code>await</code> ，同时帮我们处理了结果。如果一切正常，我们得到所有 future 对象的结果：内容为 <code>Ok</code> 的空元组（有序的）。</p>
<p>所以我们可以取到我们 future 返回的对象：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">//                                          👇
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">fetch_thing</span>(name: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>) -&gt; Result<span style="color:#f92672">&lt;&amp;</span><span style="color:#66d9ef">str</span>, Report<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// (omitted)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//  👇
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	Ok(name)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>为了方便我们自己，它们按照顺序返回，无论哪个先被执行：</p>
<pre tabindex="0"><code class="language-nil" data-lang="nil">$ RUST_LOG=info cargo run --quiet --release
Jul 25 20:47:56.967  INFO waytoodeep: Got response! status=HTTP/1.1 200 OK name=second
Jul 25 20:47:56.967  INFO waytoodeep: Got response! status=HTTP/1.1 200 OK name=first
Jul 25 20:47:56.967  INFO waytoodeep: All done! res=(&#34;first&#34;, &#34;second&#34;)
$ RUST_LOG=info cargo run --quiet --release
Jul 25 20:47:57.933  INFO waytoodeep: Got response! status=HTTP/1.1 200 OK name=first
Jul 25 20:47:57.935  INFO waytoodeep: Got response! status=HTTP/1.1 200 OK name=second
Jul 25 20:47:57.935  INFO waytoodeep: All done! res=(&#34;first&#34;, &#34;second&#34;)
$ RUST_LOG=info cargo run --quiet --release
Jul 25 20:47:58.942  INFO waytoodeep: Got response! status=HTTP/1.1 200 OK name=second
Jul 25 20:47:58.946  INFO waytoodeep: Got response! status=HTTP/1.1 200 OK name=first
Jul 25 20:47:58.946  INFO waytoodeep: All done! res=(&#34;first&#34;, &#34;second&#34;)
</code></pre><p>好了，现在我们没有 DNS 查询，我们就可以消除“同时”请求是由于多线程实现的。</p>
<p>因为，如果我们在 <code>strace</code> 下运行程序，并通过 <code>-f</code> 请求跟踪子线程（ BTW <code>f</code> 意思是跟踪（ <code>follow</code> ）子线程）：</p>
<pre tabindex="0"><code class="language-nil" data-lang="nil">$ cargo build --quiet --release &amp;&amp; strace -f -e &#39;connect&#39; ./target/release/waytoodeep
connect(9, {sa_family=AF_INET, sin_port=htons(443), sin_addr=inet_addr(&#34;1.1.1.1&#34;)}, 16) = -1 EINPROGRESS (Operation now in progress)
connect(10, {sa_family=AF_INET, sin_port=htons(443), sin_addr=inet_addr(&#34;1.1.1.1&#34;)}, 16) = -1 EINPROGRESS (Operation now in progress)
Jul 25 20:51:54.004  INFO waytoodeep: Got response! status=HTTP/1.1 200 OK name=first
Jul 25 20:51:54.013  INFO waytoodeep: Got response! status=HTTP/1.1 200 OK name=second
Jul 25 20:51:54.015  INFO waytoodeep: All done! res=(&#34;first&#34;, &#34;second&#34;)
+++ exited with 0 +++
</code></pre><p>。。。现在我们看到了预期的两次 <code>connect</code> 调用，但是没有任何子线程。而且在这个运行中，响应之间的间隔时间是 9 毫秒！少于我直接 ping 1.1.1.1:</p>
<pre tabindex="0"><code class="language-nil" data-lang="nil">$ ping -c 1 1.1.1.1
PING 1.1.1.1 (1.1.1.1) 56(84) bytes of data.
64 bytes from 1.1.1.1: icmp_seq=1 ttl=57 time=13.7 ms

--- 1.1.1.1 ping statistics ---
1 packets transmitted, 1 received, 0% packet loss, time 0ms
rtt min/avg/max/mdev = 13.748/13.748/13.748/0.000 ms
</code></pre><p>这是因为执行器通过 Event Loop 构建非阻塞的系统调用，然后订阅 Event Loop 管理的资源相关的事件，
然后就可以知道一个 socket 什么时间可以进行读写。</p>
<p>所以，future 对象只是一些状态，接下来就可以进行 await，那么在哪订阅的事件呢？</p>
<p>让我们尝试创建一个我们自己的 <code>try_join</code> &ndash; 一个函数，并且只接受两个 future。然后我们就能看到发生了什么。</p>
<p>我们已经实现了自己的 future，实现一个 <code>try_join</code> 函数会有多麻烦？</p>
<h3 id="事实证明很麻烦">事实证明很麻烦<a href="#事实证明很麻烦" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>我们先从简单的开始！我们想实现一个函数接受两个 future 对象然后返回一个 future 对象。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">// in `src/main.rs`
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">mod</span> tj;
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">// in `src/tj.rs`
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">use</span> std::future::Future;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">try_join</span><span style="color:#f92672">&lt;</span>A, B<span style="color:#f92672">&gt;</span>(a: <span style="color:#a6e22e">A</span>, b: <span style="color:#a6e22e">B</span>) -&gt; <span style="color:#a6e22e">impl</span> Future<span style="color:#f92672">&lt;</span>Output <span style="color:#f92672">=</span> ()<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">where</span>
</span></span><span style="display:flex;"><span>	A: <span style="color:#a6e22e">Future</span>,
</span></span><span style="display:flex;"><span>	B: <span style="color:#a6e22e">Future</span>,
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	todo!(<span style="color:#e6db74">&#34;implement me!&#34;</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>额。函数不应该只返回一个空元组，它需要返回一个包含成功结果的元组。或者遇到的第一个错误。</p>
<p>所以我们需要添加一些更多的范型参数：一个错误类型（我们假设两个 future 对象返回同样的错误类型），另一个是 future 对象返回的 <code>Ok</code> 的类型。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">try_join</span><span style="color:#f92672">&lt;</span>A, B, AR, BR, E<span style="color:#f92672">&gt;</span>(a: <span style="color:#a6e22e">A</span>, b: <span style="color:#a6e22e">B</span>) -&gt; <span style="color:#a6e22e">impl</span> Future<span style="color:#f92672">&lt;</span>Output <span style="color:#f92672">=</span> Result<span style="color:#f92672">&lt;</span>(AR, BR), E<span style="color:#f92672">&gt;&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">where</span>
</span></span><span style="display:flex;"><span>	A: <span style="color:#a6e22e">Future</span><span style="color:#f92672">&lt;</span>Output <span style="color:#f92672">=</span> Result<span style="color:#f92672">&lt;</span>AR, E<span style="color:#f92672">&gt;&gt;</span>,
</span></span><span style="display:flex;"><span>	B: <span style="color:#a6e22e">Future</span><span style="color:#f92672">&lt;</span>Output <span style="color:#f92672">=</span> Result<span style="color:#f92672">&lt;</span>BR, E<span style="color:#f92672">&gt;&gt;</span>,
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	todo!(<span style="color:#e6db74">&#34;implement me!&#34;</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>好了！这非常绕口，但是我相信我们已经实现了需求。</p>
<p>需要注意的是我们使用了 <code>impl Trait</code> 语法，让我们不用暴露我们自己的 <code>try join future</code> 。这不重要，但是可以让我们用更少的 <code>pub</code> 关键字，同时我们的手指已经码累了。非常累。</p>
<p>所以，让我们来创建这个类型！</p>
<p>类型需要持续 <code>A</code> 和 <code>B</code> ，并注意 <code>AR</code> 、 <code>BR</code> 和 <code>E</code> 类型。所以，希望您对这些范型参数沙拉有个好胃口。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">TryJoin</span><span style="color:#f92672">&lt;</span>A, B, AR, BR, E<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">where</span>
</span></span><span style="display:flex;"><span>	A: <span style="color:#a6e22e">Future</span><span style="color:#f92672">&lt;</span>Output <span style="color:#f92672">=</span> Result<span style="color:#f92672">&lt;</span>AR, E<span style="color:#f92672">&gt;&gt;</span>,
</span></span><span style="display:flex;"><span>	B: <span style="color:#a6e22e">Future</span><span style="color:#f92672">&lt;</span>Output <span style="color:#f92672">=</span> Result<span style="color:#f92672">&lt;</span>BR, E<span style="color:#f92672">&gt;&gt;</span>,
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	a: <span style="color:#a6e22e">A</span>,
</span></span><span style="display:flex;"><span>	b: <span style="color:#a6e22e">B</span>,
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>然后可以在我们的 <code>try_join</code> 函数中返回它：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">try_join</span><span style="color:#f92672">&lt;</span>A, B, AR, BR, E<span style="color:#f92672">&gt;</span>(a: <span style="color:#a6e22e">A</span>, b: <span style="color:#a6e22e">B</span>) -&gt; <span style="color:#a6e22e">impl</span> Future<span style="color:#f92672">&lt;</span>Output <span style="color:#f92672">=</span> Result<span style="color:#f92672">&lt;</span>(AR, BR), E<span style="color:#f92672">&gt;&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">where</span>
</span></span><span style="display:flex;"><span>	A: <span style="color:#a6e22e">Future</span><span style="color:#f92672">&lt;</span>Output <span style="color:#f92672">=</span> Result<span style="color:#f92672">&lt;</span>AR, E<span style="color:#f92672">&gt;&gt;</span>,
</span></span><span style="display:flex;"><span>	B: <span style="color:#a6e22e">Future</span><span style="color:#f92672">&lt;</span>Output <span style="color:#f92672">=</span> Result<span style="color:#f92672">&lt;</span>BR, E<span style="color:#f92672">&gt;&gt;</span>,
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// so simple!
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	TryJoin { a, b }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>我认为这很好的说明一个事实：创建 future 对象仅仅是构建状态。不需要任何额外的工作。</p>
<p>当然，这个不会通过编译，因为 <code>TryJoin</code> 还没有实现 <code>Future</code> 。</p>
<p>但是不要担心！ <code>rust-analyzer</code> 可以帮助我们生成缺失的部分：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">use</span> std::{
</span></span><span style="display:flex;"><span>	future::Future,
</span></span><span style="display:flex;"><span>	pin::Pin,
</span></span><span style="display:flex;"><span>	task::{Context, Poll},
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>A, B, AR, BR, E<span style="color:#f92672">&gt;</span> Future <span style="color:#66d9ef">for</span> TryJoin<span style="color:#f92672">&lt;</span>A, B, AR, BR, E<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">where</span>
</span></span><span style="display:flex;"><span>	A: <span style="color:#a6e22e">Future</span><span style="color:#f92672">&lt;</span>Output <span style="color:#f92672">=</span> Result<span style="color:#f92672">&lt;</span>AR, E<span style="color:#f92672">&gt;&gt;</span>,
</span></span><span style="display:flex;"><span>	B: <span style="color:#a6e22e">Future</span><span style="color:#f92672">&lt;</span>Output <span style="color:#f92672">=</span> Result<span style="color:#f92672">&lt;</span>BR, E<span style="color:#f92672">&gt;&gt;</span>,
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Output</span> <span style="color:#f92672">=</span> Result<span style="color:#f92672">&lt;</span>(AR, BR), E<span style="color:#f92672">&gt;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">poll</span>(self: <span style="color:#a6e22e">Pin</span><span style="color:#f92672">&lt;&amp;</span><span style="color:#66d9ef">mut</span> Self<span style="color:#f92672">&gt;</span>, cx: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> Context<span style="color:#f92672">&lt;&#39;</span>_<span style="color:#f92672">&gt;</span>) -&gt; <span style="color:#a6e22e">Poll</span><span style="color:#f92672">&lt;</span>Self::Output<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>		todo!()
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>如果我们真正的实现了，我们将按照下面方式使用：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">#[tokio::main(flavor = </span><span style="color:#e6db74">&#34;current_thread&#34;</span><span style="color:#75715e">)]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() -&gt; Result<span style="color:#f92672">&lt;</span>(), Report<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>	setup()<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> res <span style="color:#f92672">=</span> tj::try_join(fetch_thing(<span style="color:#e6db74">&#34;first&#34;</span>), fetch_thing(<span style="color:#e6db74">&#34;second&#34;</span>)).<span style="color:#66d9ef">await</span><span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>	info<span style="color:#f92672">!</span>(<span style="color:#f92672">?</span>res, <span style="color:#e6db74">&#34;All done!&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	Ok(())
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>当然，现在只是会崩溃：</p>
<pre tabindex="0"><code class="language-nil" data-lang="nil">$ RUST_LOG=info cargo run --quiet --release

The application panicked (crashed).
Message:  not yet implemented
Location: src/tj.rs:32

Backtrace omitted.
Run with RUST_BACKTRACE=1 environment variable to display it.
Run with RUST_BACKTRACE=full to include source snippets.
</code></pre><p>所以，我猜我们需要实现它！</p>
<p>好吧，让我们先尝试至少轮询（polling）一个 future 对象。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">poll</span>(self: <span style="color:#a6e22e">Pin</span><span style="color:#f92672">&lt;&amp;</span><span style="color:#66d9ef">mut</span> Self<span style="color:#f92672">&gt;</span>, cx: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> Context<span style="color:#f92672">&lt;&#39;</span>_<span style="color:#f92672">&gt;</span>) -&gt; <span style="color:#a6e22e">Poll</span><span style="color:#f92672">&lt;</span>Self::Output<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> a <span style="color:#f92672">=</span> self.a.poll(cx);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	todo!()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><pre tabindex="0"><code class="language-nil" data-lang="nil">$ RUST_LOG=info cargo run --quiet --release
error[E0599]: no method named `poll` found for type parameter `A` in the current scope
   --&gt; src/tj.rs:32:24
	|
32  |         let a = self.a.poll(cx);
	|                        ^^^^ method not found in `A`
	|
   ::: /home/amos/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/future/future.rs:100:8
	|
100 |     fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;&#39;_&gt;) -&gt; Poll&lt;Self::Output&gt;;
	|        ---- the method is available for `Pin&lt;&amp;mut A&gt;` here
	|
help: consider wrapping the receiver expression with the appropriate type
	|
32  |         let a = Pin::new(&amp;mut self.a).poll(cx);
	|                 ^^^^^^^^^^^^^       ^
</code></pre><p>额！一个好的开始，好的开始。</p>
<p>我已经在这里<a href="https://fasterthanli.me/articles/pin-and-suffering">详细的解释了</a> Pin，所以这里我们就简单的介绍一下。</p>
<p>方法通常通过如下方式定义接收者（receiver）：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">MyType</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">do_thing</span>(<span style="color:#f92672">&amp;</span>self) {
</span></span><span style="display:flex;"><span>		println!(<span style="color:#e6db74">&#34;my value is {}&#34;</span>, self.value)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>也就是下面的简写：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">MyType</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">do_thing</span>(self: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">Self</span>) {
</span></span><span style="display:flex;"><span>		println!(<span style="color:#e6db74">&#34;my value is {}&#34;</span>, self.value)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>因为我们在 <code>impl MyType</code> 代码块中 <code>Self</code> 就是 <code>MyType</code> 。</p>
<p>很清晰吧？好了，还可以定义其他很多类型作为接收者， <code>Pin&lt;&amp;mut Self&gt;</code> 就是其中之一：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">MyType</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">do_thing</span>(self: <span style="color:#a6e22e">Pin</span><span style="color:#f92672">&lt;&amp;</span><span style="color:#66d9ef">mut</span> Self<span style="color:#f92672">&gt;</span>) {
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// good luck!1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>那么 <code>MyType</code> 必须是固定的（pinned）是什么意思呢？比如，它保证不进行转移（move）。除非它实现了 <code>Unpin</code> ，
然后它就可以是非固定的（unpinned），可移动，然后被再一次固定。</p>
<p>对于剩下的文章，我们不会假设我们的 future <code>A</code> 和 <code>B</code> 都是 <code>Unpin</code> ，也就是说我们自己不会移动（move）它们（只销毁（drop）它们）。</p>
<p>你可以说我们不需要 <code>A</code> 和 <code>B</code> 是 <code>Unpin</code> 的，因为我们没有添加指定的 where clause 来标记需要它们是 <code>Unpin</code> 。
因为如果我们需要，我们就要像下面这样添加额外的 <code>trait bound</code> ：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">TryJoin</span><span style="color:#f92672">&lt;</span>A, B, AR, BR, E<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">where</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//                                    👇
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	A: <span style="color:#a6e22e">Future</span><span style="color:#f92672">&lt;</span>Output <span style="color:#f92672">=</span> Result<span style="color:#f92672">&lt;</span>AR, E<span style="color:#f92672">&gt;&gt;</span> <span style="color:#f92672">+</span> Unpin,
</span></span><span style="display:flex;"><span>	B: <span style="color:#a6e22e">Future</span><span style="color:#f92672">&lt;</span>Output <span style="color:#f92672">=</span> Result<span style="color:#f92672">&lt;</span>BR, E<span style="color:#f92672">&gt;&gt;</span> <span style="color:#f92672">+</span> Unpin,
</span></span><span style="display:flex;"><span>{}
</span></span></code></pre></div><p>但是我们没有，所以我们不能假设 <code>A</code> 或 <code>B</code> 是 <code>Unpin</code> 的。</p>
<p>所以！我们现在真的只是面临固定（pin）保护的问题。</p>
<p>我们现在只持有一个 <code>Pin&lt;&amp;mut TryJoin&lt;A, B, ...&gt;&gt;</code> 但是我希望持续一个 <code>Pin&lt;&amp;mut A&gt;</code> （因为这就是我们因为需要轮询 <code>A</code> ）。</p>
<p>另外一个解决方法，我倾向于通过一些类似 <a href="https://lib.rs/crates/pin-project">pin-project</a> 包，或者类似 <a href="https://lib.rs/crates/pin-project-lite">pin-project-lite</a>，但是在我们前进的方向直接使用 <code>pin-project</code> 真的很尴尬，
所以我们这里使用 <code>unsafe</code> 作为替代：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">poll</span>(self: <span style="color:#a6e22e">Pin</span><span style="color:#f92672">&lt;&amp;</span><span style="color:#66d9ef">mut</span> Self<span style="color:#f92672">&gt;</span>, cx: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> Context<span style="color:#f92672">&lt;&#39;</span>_<span style="color:#f92672">&gt;</span>) -&gt; <span style="color:#a6e22e">Poll</span><span style="color:#f92672">&lt;</span>Self::Output<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> a <span style="color:#f92672">=</span> <span style="color:#66d9ef">unsafe</span> { self.map_unchecked_mut(<span style="color:#f92672">|</span>this<span style="color:#f92672">|</span> <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> this.a) };
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> a <span style="color:#f92672">=</span> a.poll(cx);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	todo!()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>可以通过编译。但是我们在使用 <code>unsafe</code> ，也就意味着编译器正式停止 <del>照顾</del> 检查我们的代码。
我们自己必须强制执行一些不变量（invariants），并且非常非常小心，同时让其他人审查（review）我们的工作，
但是依然可能会出错，因为他们也会休息。</p>
<p>现在，非常棒的是我们可以轮询 <code>a</code> 。它如果完成会返回 <code>Poll::Ready(Result&lt;AR, E&gt;)</code> ，
否则就是等会会完成则返回 <code>Poll::Pending</code> 。</p>
<p>我们可以观察到：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">poll</span>(self: <span style="color:#a6e22e">Pin</span><span style="color:#f92672">&lt;&amp;</span><span style="color:#66d9ef">mut</span> Self<span style="color:#f92672">&gt;</span>, cx: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> Context<span style="color:#f92672">&lt;&#39;</span>_<span style="color:#f92672">&gt;</span>) -&gt; <span style="color:#a6e22e">Poll</span><span style="color:#f92672">&lt;</span>Self::Output<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> a <span style="color:#f92672">=</span> <span style="color:#66d9ef">unsafe</span> { self.map_unchecked_mut(<span style="color:#f92672">|</span>this<span style="color:#f92672">|</span> <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> this.a) };
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">match</span> a.poll(cx) {
</span></span><span style="display:flex;"><span>		Poll::Pending <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>			info<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;A is pending...&#34;</span>);
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> Poll::Pending;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		Poll::Ready(res) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">match</span> res {
</span></span><span style="display:flex;"><span>			Ok(_) <span style="color:#f92672">=&gt;</span> info<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;A is ready!&#34;</span>),
</span></span><span style="display:flex;"><span>			Err(e) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">return</span> Poll::Ready(Err(e)),
</span></span><span style="display:flex;"><span>		},
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	todo!()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>我们通过打印日志“A is pending”知道准备完成。这可能需要几个回合：毕竟，我们正在做一些重要的事情。
我们建立一个 TCP 连接，接着在上面进行 TLS 会话，接着是一些分开的写，最后读到 EOF（end of file）。</p>
<p>当然，如果我们运行它的话：</p>
<pre tabindex="0"><code class="language-nil" data-lang="nil">aytoodeep::tj: A is pending...
Jul 25 22:54:14.495  INFO waytoodeep::tj: A is pending...
Jul 25 22:54:14.495  INFO waytoodeep::tj: A is pending...
Jul 25 22:54:14.495  INFO waytoodeep::tj: A is pending...
Jul 25 22:54:14.495  INFO waytoodeep::tj: A is pending...
Jul 25 22:54:14.495  INFO waytoodeep::tj: A is pending...
Jul 25 22:54:14.495  INFO waytoodeep::tj: A is pending...
Jul 25 22:54:14.495  INFO waytoodeep::tj: A is pending...
Jul 25 22:54:14.513  INFO waytoodeep::tj: A is pending...
Jul 25 22:54:14.513  INFO waytoodeep::tj: A is pending...
Jul 25 22:54:14.513  INFO waytoodeep::tj: A is pending...
Jul 25 22:54:14.513  INFO waytoodeep::tj: A is pending...
Jul 25 22:54:14.513  INFO waytoodeep::tj: A is pending...
Jul 25 22:54:14.514  INFO waytoodeep::tj: A is pending...
Jul 25 22:54:14.522  INFO waytoodeep::tj: A is pending...
Jul 25 22:54:14.522  INFO waytoodeep::tj: A is pending...
Jul 25 22:54:14.522  INFO waytoodeep::tj: A is pending...
Jul 25 22:54:14.522  INFO waytoodeep::tj: A is pending...
Jul 25 22:54:14.522  INFO waytoodeep::tj: A is pending...
Jul 25 22:54:14.523  INFO waytoodeep::tj: A is pending...
Jul 25 22:54:14.523  INFO waytoodeep::tj: A is pending...
Jul 25 22:54:14.530  INFO waytoodeep::tj: A is pending...
Jul 25 22:54:14.530  INFO waytoodeep::tj: A is pending...
Jul 25 22:54:14.530  INFO waytoodeep: Got response! status=HTTP/1.1 200 OK name=first
Jul 25 22:54:14.530  INFO waytoodeep::tj: A is ready!
The application panicked (crashed).
Message:  not yet implemented
Location: src/tj.rs:46

Backtrace omitted.
Run with RUST_BACKTRACE=1 environment variable to display it.
Run with RUST_BACKTRACE=full to include source snippets.
</code></pre><p>我们可以看到它确实花费了几个回合。</p>
<p>注意如果 <code>A</code> 返回错误我们的代码也会返回 <code>Poll:Ready</code> ，因为我们想收集 A 和 B 的结果。</p>
<p>所以我们对 B 做相同的事情：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">poll</span>(self: <span style="color:#a6e22e">Pin</span><span style="color:#f92672">&lt;&amp;</span><span style="color:#66d9ef">mut</span> Self<span style="color:#f92672">&gt;</span>, cx: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> Context<span style="color:#f92672">&lt;&#39;</span>_<span style="color:#f92672">&gt;</span>) -&gt; <span style="color:#a6e22e">Poll</span><span style="color:#f92672">&lt;</span>Self::Output<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> a <span style="color:#f92672">=</span> <span style="color:#66d9ef">unsafe</span> { self.map_unchecked_mut(<span style="color:#f92672">|</span>this<span style="color:#f92672">|</span> <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> this.a) };
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">match</span> a.poll(cx) {
</span></span><span style="display:flex;"><span>		Poll::Pending <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>			info<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;A is pending...&#34;</span>);
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> Poll::Pending;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		Poll::Ready(res) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">match</span> res {
</span></span><span style="display:flex;"><span>			Ok(_) <span style="color:#f92672">=&gt;</span> info<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;A is ready!&#34;</span>),
</span></span><span style="display:flex;"><span>			Err(e) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">return</span> Poll::Ready(Err(e)),
</span></span><span style="display:flex;"><span>		},
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> b <span style="color:#f92672">=</span> <span style="color:#66d9ef">unsafe</span> { self.map_unchecked_mut(<span style="color:#f92672">|</span>this<span style="color:#f92672">|</span> <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> this.a) };
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">match</span> b.poll(cx) {
</span></span><span style="display:flex;"><span>		Poll::Pending <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>			info<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;B is pending...&#34;</span>);
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> Poll::Pending;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		Poll::Ready(res) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">match</span> res {
</span></span><span style="display:flex;"><span>			Ok(_) <span style="color:#f92672">=&gt;</span> info<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;B is ready!&#34;</span>),
</span></span><span style="display:flex;"><span>			Err(e) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">return</span> Poll::Ready(Err(e)),
</span></span><span style="display:flex;"><span>		},
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	todo!()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>然后。。whoops：</p>
<pre tabindex="0"><code class="language-nil" data-lang="nil">RUST_LOG=info cargo run --quiet --release
error[E0382]: use of moved value: `self`
   --&gt; src/tj.rs:46:26
	|
33  |     fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;&#39;_&gt;) -&gt; Poll&lt;Self::Output&gt; {
	|             ---- move occurs because `self` has type `Pin&lt;&amp;mut TryJoin&lt;A, B, AR, BR, E&gt;&gt;`, which does not implement the `Copy` trait
34  |         let a = unsafe { self.map_unchecked_mut(|this| &amp;mut this.a) };
	|                               ------------------------------------- `self` moved due to this method call
...
46  |         let b = unsafe { self.map_unchecked_mut(|this| &amp;mut this.a) };
	|                          ^^^^ value used here after move
	|
note: this function takes ownership of the receiver `self`, which moves `self`
   --&gt; /home/amos/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/pin.rs:776:43
	|
776 |     pub unsafe fn map_unchecked_mut&lt;U, F&gt;(self, func: F) -&gt; Pin&lt;&amp;&#39;a mut U&gt;
	|                                           ^^^^
</code></pre><p>是的。 <code>map_unchecked_mut</code> 占有了 <code>self</code> 。</p>
<p>不用担心，我们可以使用 <code>.as_mut()</code> ：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">//       👇
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">poll</span>(<span style="color:#66d9ef">mut</span> self: <span style="color:#a6e22e">Pin</span><span style="color:#f92672">&lt;&amp;</span><span style="color:#66d9ef">mut</span> Self<span style="color:#f92672">&gt;</span>, cx: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> Context<span style="color:#f92672">&lt;&#39;</span>_<span style="color:#f92672">&gt;</span>) -&gt; <span style="color:#a6e22e">Poll</span><span style="color:#f92672">&lt;</span>Self::Output<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//                      👇
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">let</span> a <span style="color:#f92672">=</span> <span style="color:#66d9ef">unsafe</span> { self.as_mut().map_unchecked_mut(<span style="color:#f92672">|</span>this<span style="color:#f92672">|</span> <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> this.a) };
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">match</span> a.poll(cx) {
</span></span><span style="display:flex;"><span>		Poll::Pending <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>			info<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;A is pending...&#34;</span>);
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> Poll::Pending;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		Poll::Ready(res) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">match</span> res {
</span></span><span style="display:flex;"><span>			Ok(_) <span style="color:#f92672">=&gt;</span> info<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;A is ready!&#34;</span>),
</span></span><span style="display:flex;"><span>			Err(e) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">return</span> Poll::Ready(Err(e)),
</span></span><span style="display:flex;"><span>		},
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//                      👇
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">let</span> b <span style="color:#f92672">=</span> <span style="color:#66d9ef">unsafe</span> { self.as_mut().map_unchecked_mut(<span style="color:#f92672">|</span>this<span style="color:#f92672">|</span> <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> this.a) };
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">match</span> b.poll(cx) {
</span></span><span style="display:flex;"><span>		Poll::Pending <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>			info<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;B is pending...&#34;</span>);
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> Poll::Pending;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		Poll::Ready(res) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">match</span> res {
</span></span><span style="display:flex;"><span>			Ok(_) <span style="color:#f92672">=&gt;</span> info<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;B is ready!&#34;</span>),
</span></span><span style="display:flex;"><span>			Err(e) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">return</span> Poll::Ready(Err(e)),
</span></span><span style="display:flex;"><span>		},
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	todo!()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>但是依然无法通过编译：</p>
<pre tabindex="0"><code class="language-nil" data-lang="nil">$ RUST_LOG=info cargo run --quiet --release
(cut)
Jul 25 22:57:07.913  INFO waytoodeep::tj: A is pending...
Jul 25 22:57:07.913  INFO waytoodeep::tj: A is pending...
Jul 25 22:57:07.913  INFO waytoodeep: Got response! status=HTTP/1.1 200 OK name=first
Jul 25 22:57:07.913  INFO waytoodeep::tj: A is ready!
The application panicked (crashed).
Message:  `async fn` resumed after completion
Location: src/main.rs:24

Backtrace omitted.
Run with RUST_BACKTRACE=1 environment variable to display it.
Run with RUST_BACKTRACE=full to include source snippets.
</code></pre><p>可以看到，一旦 <code>Future</code> 返回 <code>Poll::Ready</code> 我们就不能再次轮询它了。我们为什么会这样？因为 <code>Future</code> 已经返回了结果。如果结果是非 <code>Copy</code> 的，它可能只能返回一次。</p>
<p>所以，我们需要 1）跟踪 <code>A</code> 是否完成，然后 2）在某个地方存储它的返回结果。</p>
<p>我们只需要在我们的结构体中添加一些字段：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">TryJoin</span><span style="color:#f92672">&lt;</span>A, B, AR, BR, E<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">where</span>
</span></span><span style="display:flex;"><span>	A: <span style="color:#a6e22e">Future</span><span style="color:#f92672">&lt;</span>Output <span style="color:#f92672">=</span> Result<span style="color:#f92672">&lt;</span>AR, E<span style="color:#f92672">&gt;&gt;</span>,
</span></span><span style="display:flex;"><span>	B: <span style="color:#a6e22e">Future</span><span style="color:#f92672">&lt;</span>Output <span style="color:#f92672">=</span> Result<span style="color:#f92672">&lt;</span>BR, E<span style="color:#f92672">&gt;&gt;</span>,
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	a: <span style="color:#a6e22e">A</span>,
</span></span><span style="display:flex;"><span>	b: <span style="color:#a6e22e">B</span>,
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 👇
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	a_res: Option<span style="color:#f92672">&lt;</span>AR<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>	b_res: Option<span style="color:#f92672">&lt;</span>BR<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>不要忘记初始化它们：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">try_join</span><span style="color:#f92672">&lt;</span>A, B, AR, BR, E<span style="color:#f92672">&gt;</span>(a: <span style="color:#a6e22e">A</span>, b: <span style="color:#a6e22e">B</span>) -&gt; <span style="color:#a6e22e">impl</span> Future<span style="color:#f92672">&lt;</span>Output <span style="color:#f92672">=</span> Result<span style="color:#f92672">&lt;</span>(AR, BR), E<span style="color:#f92672">&gt;&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">where</span>
</span></span><span style="display:flex;"><span>	A: <span style="color:#a6e22e">Future</span><span style="color:#f92672">&lt;</span>Output <span style="color:#f92672">=</span> Result<span style="color:#f92672">&lt;</span>AR, E<span style="color:#f92672">&gt;&gt;</span>,
</span></span><span style="display:flex;"><span>	B: <span style="color:#a6e22e">Future</span><span style="color:#f92672">&lt;</span>Output <span style="color:#f92672">=</span> Result<span style="color:#f92672">&lt;</span>BR, E<span style="color:#f92672">&gt;&gt;</span>,
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	TryJoin {
</span></span><span style="display:flex;"><span>		a,
</span></span><span style="display:flex;"><span>		b,
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 👇
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		a_res: None,
</span></span><span style="display:flex;"><span>		b_res: None,
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>现在计划是：</p>
<ul>
<li>如果 <code>a_res</code> 是 <code>Some</code> ，然后我们就不需要轮询 <code>a</code> ,因为它已经完成了</li>
<li>同样的逻辑处理 <code>b_res</code> 和 <code>b</code></li>
</ul>
<p>让我们实现它。同时，因为我们已经在使用了 <code>unsafe</code> ，所以我们已经负责维护不变量（invariants），
所以我决定同时固定 <code>a</code> 和 <code>b</code> ，如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">poll</span>(self: <span style="color:#a6e22e">Pin</span><span style="color:#f92672">&lt;&amp;</span><span style="color:#66d9ef">mut</span> Self<span style="color:#f92672">&gt;</span>, cx: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> Context<span style="color:#f92672">&lt;&#39;</span>_<span style="color:#f92672">&gt;</span>) -&gt; <span style="color:#a6e22e">Poll</span><span style="color:#f92672">&lt;</span>Self::Output<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> this <span style="color:#f92672">=</span> <span style="color:#66d9ef">unsafe</span> { self.get_unchecked_mut() };
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> (a, b) <span style="color:#f92672">=</span> <span style="color:#66d9ef">unsafe</span> {
</span></span><span style="display:flex;"><span>		(
</span></span><span style="display:flex;"><span>			Pin::new_unchecked(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> this.a),
</span></span><span style="display:flex;"><span>			Pin::new_unchecked(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> this.b),
</span></span><span style="display:flex;"><span>		)
</span></span><span style="display:flex;"><span>	};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> this.a_res.is_none() {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">match</span> a.poll(cx) {
</span></span><span style="display:flex;"><span>			Poll::Pending <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">return</span> Poll::Pending,
</span></span><span style="display:flex;"><span>			Poll::Ready(res) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">match</span> res {
</span></span><span style="display:flex;"><span>				Ok(x) <span style="color:#f92672">=&gt;</span> this.a_res <span style="color:#f92672">=</span> Some(x),
</span></span><span style="display:flex;"><span>				Err(e) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">return</span> Poll::Ready(Err(e)),
</span></span><span style="display:flex;"><span>			},
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> this.b_res.is_none() {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">match</span> b.poll(cx) {
</span></span><span style="display:flex;"><span>			Poll::Pending <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">return</span> Poll::Pending,
</span></span><span style="display:flex;"><span>			Poll::Ready(res) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">match</span> res {
</span></span><span style="display:flex;"><span>				Ok(x) <span style="color:#f92672">=&gt;</span> this.b_res <span style="color:#f92672">=</span> Some(x),
</span></span><span style="display:flex;"><span>				Err(e) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">return</span> Poll::Ready(Err(e)),
</span></span><span style="display:flex;"><span>			},
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	todo!()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>好了，这个应该能让 <code>a</code> 和 <code>b</code> 有机会在我们崩溃之前完成：</p>
<pre tabindex="0"><code class="language-nil" data-lang="nil">$ RUST_LOG=info cargo run --quiet --release
Jul 25 23:11:03.851  INFO waytoodeep: Got response! status=HTTP/1.1 200 OK name=first
Jul 25 23:11:04.380  INFO waytoodeep: Got response! status=HTTP/1.1 200 OK name=second
The application panicked (crashed).
Message:  not yet implemented
Location: src/tj.rs:69

Backtrace omitted.
Run with RUST_BACKTRACE=1 environment variable to display it.
Run with RUST_BACKTRACE=full to include source snippets.
</code></pre><p>很好！现在我们需要做的就是解出两个结果并返回它们：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">// instead of the `todo!()`:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> (Some(_), Some(_)) <span style="color:#f92672">=</span> (<span style="color:#f92672">&amp;</span>this.a_res, <span style="color:#f92672">&amp;</span>this.b_res) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> a <span style="color:#f92672">=</span> this.a_res.take().unwrap();
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> b <span style="color:#f92672">=</span> this.b_res.take().unwrap();
</span></span><span style="display:flex;"><span>	Poll::Ready(Ok((a, b)))
</span></span><span style="display:flex;"><span>} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>	Poll::Pending
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>可以工作：</p>
<pre tabindex="0"><code class="language-nil" data-lang="nil">$ RUST_LOG=info cargo run --quiet --release
Jul 25 23:13:32.497  INFO waytoodeep: Got response! status=HTTP/1.1 200 OK name=first
Jul 25 23:13:32.829  INFO waytoodeep: Got response! status=HTTP/1.1 200 OK name=second
Jul 25 23:13:32.829  INFO waytoodeep: All done! res=(&#34;first&#34;, &#34;second&#34;)
</code></pre><p>。。。但是这不是 <code>try_join</code> 的实现。我们正在做的和这个完全一样：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">// (pseudo-code, buncha things are missing)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">try_join</span>(a: <span style="color:#a6e22e">A</span>, b: <span style="color:#a6e22e">B</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> a <span style="color:#f92672">=</span> self.a.<span style="color:#66d9ef">await</span><span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> b <span style="color:#f92672">=</span> self.b.<span style="color:#66d9ef">await</span><span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>	Ok((a, b))
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>是顺序的执行的。请记住，仅仅是因为 tokio 的执行器可能用了一堆线程并意味着同时运行是自动的。
前面我们不得不使用 <code>tokio::spwan</code> 或 <code>UnorderedFutures</code> 或 <code>try_join!</code> 让其同时运行。</p>
<p>所以让我们重新看一下。。。当我们轮询 <code>a</code> 的是后发生了什么？</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> this.a_res.is_none() {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">match</span> a.poll(cx) {
</span></span><span style="display:flex;"><span>		Poll::Pending <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">return</span> Poll::Pending,
</span></span><span style="display:flex;"><span>		Poll::Ready(res) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">match</span> res {
</span></span><span style="display:flex;"><span>			Ok(x) <span style="color:#f92672">=&gt;</span> this.a_res <span style="color:#f92672">=</span> Some(x),
</span></span><span style="display:flex;"><span>			Err(e) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">return</span> Poll::Ready(Err(e)),
</span></span><span style="display:flex;"><span>		},
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>额，当轮询 <code>a</code> 的时候返回 <code>Poll::Pending</code> 时我们也会返回 <code>Poll::Pending</code>  。所以这就是问题。
如果 <code>a</code> 正在等待（pending）我们不应该返回。因为如果这时候 <code>b</code> 已经准备好或者有错误呢？</p>
<p>或者如果，我们像这样调用 <code>try_join</code> 呢：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>info<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;Joining...&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> res <span style="color:#f92672">=</span> tj::try_join(
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">async</span> <span style="color:#66d9ef">move</span> {
</span></span><span style="display:flex;"><span>		sleep(Duration::from_millis(<span style="color:#ae81ff">2000</span>)).<span style="color:#66d9ef">await</span>;
</span></span><span style="display:flex;"><span>		Ok(())
</span></span><span style="display:flex;"><span>	},
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">async</span> <span style="color:#66d9ef">move</span> {
</span></span><span style="display:flex;"><span>		sleep(Duration::from_millis(<span style="color:#ae81ff">10</span>)).<span style="color:#66d9ef">await</span>;
</span></span><span style="display:flex;"><span>		Err::<span style="color:#f92672">&lt;</span>(), Report<span style="color:#f92672">&gt;</span>(color_eyre::eyre::eyre<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;uh oh&#34;</span>))
</span></span><span style="display:flex;"><span>	},
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>.<span style="color:#66d9ef">await</span>;
</span></span></code></pre></div><p>。。。然后 <code>a</code> 花费了 2 秒钟才准备好，同时 <code>b</code> 会在 10毫秒之后返回一个错误，如果我们轮询它！</p>
<p>嗐，我们并没有：</p>
<pre tabindex="0"><code class="language-nil" data-lang="nil">$ RUST_LOG=info cargo run --quiet --release
Jul 25 23:19:26.972  INFO waytoodeep: Joining...
Jul 25 23:19:28.990  INFO waytoodeep: All done! res=Err(
   0: uh oh

Location:
   src/main.rs:28
(cut)
</code></pre><p>（注意时间戳）</p>
<p>重点是 <code>try_join</code> 会提前失败：一旦 Future 返回 <code>Result::Err~</code> 。</p>
<p>所以我们必须同时轮询 <code>a</code> 和 <code>b</code> 。好吧。。。不是严格意义的同时。我们必须每次我们的 <code>TryJoin</code> future 对象被轮询时并发（concurrently）的轮询它们，
直到它们返回结果。</p>
<p>有一个简单解决办法 &ndash; 在任一 future 对象返回 <code>Poll::Pending</code> 时不返回 <code>Poll::Pending</code> 。</p>
<p>同时，我厌倦了输入 <code>Poll::Ready</code> 并且 <code>Poll&lt;T&gt;</code> 实现了 <code>From&lt;T&gt;</code> ,所以我们可以使用 <code>.into()</code> 了：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">poll</span>(self: <span style="color:#a6e22e">Pin</span><span style="color:#f92672">&lt;&amp;</span><span style="color:#66d9ef">mut</span> Self<span style="color:#f92672">&gt;</span>, cx: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> Context<span style="color:#f92672">&lt;&#39;</span>_<span style="color:#f92672">&gt;</span>) -&gt; <span style="color:#a6e22e">Poll</span><span style="color:#f92672">&lt;</span>Self::Output<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> this <span style="color:#f92672">=</span> <span style="color:#66d9ef">unsafe</span> { self.get_unchecked_mut() };
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> (a, b) <span style="color:#f92672">=</span> <span style="color:#66d9ef">unsafe</span> {
</span></span><span style="display:flex;"><span>		(
</span></span><span style="display:flex;"><span>			Pin::new_unchecked(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> this.a),
</span></span><span style="display:flex;"><span>			Pin::new_unchecked(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> this.b),
</span></span><span style="display:flex;"><span>		)
</span></span><span style="display:flex;"><span>	};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> this.a_res.is_none() {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> Poll::Ready(res) <span style="color:#f92672">=</span> a.poll(cx) {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">match</span> res {
</span></span><span style="display:flex;"><span>				Ok(x) <span style="color:#f92672">=&gt;</span> this.a_res <span style="color:#f92672">=</span> Some(x),
</span></span><span style="display:flex;"><span>				Err(e) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">return</span> Err(e).into(),
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> this.b_res.is_none() {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> Poll::Ready(res) <span style="color:#f92672">=</span> b.poll(cx) {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">match</span> res {
</span></span><span style="display:flex;"><span>				Ok(x) <span style="color:#f92672">=&gt;</span> this.b_res <span style="color:#f92672">=</span> Some(x),
</span></span><span style="display:flex;"><span>				Err(e) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">return</span> Err(e).into(),
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> (Some(_), Some(_)) <span style="color:#f92672">=</span> (<span style="color:#f92672">&amp;</span>this.a_res, <span style="color:#f92672">&amp;</span>this.b_res) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">let</span> a <span style="color:#f92672">=</span> this.a_res.take().unwrap();
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">let</span> b <span style="color:#f92672">=</span> this.b_res.take().unwrap();
</span></span><span style="display:flex;"><span>		Ok((a, b)).into()
</span></span><span style="display:flex;"><span>	} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>		Poll::Pending
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>让我们再次运行</p>
<pre tabindex="0"><code class="language-nil" data-lang="nil">$ RUST_LOG=info cargo run --quiet --release
Jul 25 23:22:40.238  INFO waytoodeep: Joining...
Jul 25 23:22:40.253  INFO waytoodeep: All done! res=Err(
   0: uh oh

Location:
   src/main.rs:28

(cut)
</code></pre><p>。。。可以了！我是说它按照预期的失败了。预期的失败就是成功。</p>
<p>然后我们将这个方法应用到调用 <code>try_join</code> :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">#[tokio::main(flavor = </span><span style="color:#e6db74">&#34;current_thread&#34;</span><span style="color:#75715e">)]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() -&gt; Result<span style="color:#f92672">&lt;</span>(), Report<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>	setup()<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	info<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;Joining...&#34;</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> res <span style="color:#f92672">=</span> tj::try_join(fetch_thing(<span style="color:#e6db74">&#34;first&#34;</span>), fetch_thing(<span style="color:#e6db74">&#34;second&#34;</span>)).<span style="color:#66d9ef">await</span><span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>	info<span style="color:#f92672">!</span>(<span style="color:#f92672">?</span>res, <span style="color:#e6db74">&#34;All done!&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	Ok(())
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>我们可以看到竞争又回来了：有时 <code>first</code> 先完成，有时则不是：</p>
<pre tabindex="0"><code class="language-nil" data-lang="nil">$ RUST_LOG=info cargo run --quiet --release
Jul 25 23:25:25.925  INFO waytoodeep: Joining...
Jul 25 23:25:26.224  INFO waytoodeep: Got response! status=HTTP/1.1 200 OK name=first
Jul 25 23:25:26.236  INFO waytoodeep: Got response! status=HTTP/1.1 200 OK name=second
Jul 25 23:25:26.236  INFO waytoodeep: All done! res=(&#34;first&#34;, &#34;second&#34;)
$ RUST_LOG=info cargo run --quiet --release
Jul 25 23:25:26.937  INFO waytoodeep: Joining...
Jul 25 23:25:27.237  INFO waytoodeep: Got response! status=HTTP/1.1 200 OK name=first
Jul 25 23:25:27.242  INFO waytoodeep: Got response! status=HTTP/1.1 200 OK name=second
Jul 25 23:25:27.242  INFO waytoodeep: All done! res=(&#34;first&#34;, &#34;second&#34;)
$ RUST_LOG=info cargo run --quiet --release
Jul 25 23:25:27.865  INFO waytoodeep: Joining...
Jul 25 23:25:28.164  INFO waytoodeep: Got response! status=HTTP/1.1 200 OK name=second
Jul 25 23:25:28.818  INFO waytoodeep: Got response! status=HTTP/1.1 200 OK name=first
Jul 25 23:25:28.818  INFO waytoodeep: All done! res=(&#34;first&#34;, &#34;second&#34;)
$ RUST_LOG=info cargo run --quiet --release
Jul 25 23:25:30.153  INFO waytoodeep: Joining...
Jul 25 23:25:31.477  INFO waytoodeep: Got response! status=HTTP/1.1 200 OK name=second
Jul 25 23:25:31.496  INFO waytoodeep: Got response! status=HTTP/1.1 200 OK name=first
Jul 25 23:25:31.496  INFO waytoodeep: All done! res=(&#34;first&#34;, &#34;second&#34;)
</code></pre><p>。。。同时结果的顺序是正确的。</p>
<p>非常好，我们实现了它！</p>
<p>但是！</p>
<h3 id="我们可以做的更好">我们可以做的更好<a href="#我们可以做的更好" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>幸运的是，坏就是好。</p>
<p>下面这个类型困扰着我：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">TryJoin</span><span style="color:#f92672">&lt;</span>A, B, AR, BR, E<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">where</span>
</span></span><span style="display:flex;"><span>	A: <span style="color:#a6e22e">Future</span><span style="color:#f92672">&lt;</span>Output <span style="color:#f92672">=</span> Result<span style="color:#f92672">&lt;</span>AR, E<span style="color:#f92672">&gt;&gt;</span>,
</span></span><span style="display:flex;"><span>	B: <span style="color:#a6e22e">Future</span><span style="color:#f92672">&lt;</span>Output <span style="color:#f92672">=</span> Result<span style="color:#f92672">&lt;</span>BR, E<span style="color:#f92672">&gt;&gt;</span>,
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	a: <span style="color:#a6e22e">A</span>,
</span></span><span style="display:flex;"><span>	b: <span style="color:#a6e22e">B</span>,
</span></span><span style="display:flex;"><span>	a_res: Option<span style="color:#f92672">&lt;</span>AR<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>	b_res: Option<span style="color:#f92672">&lt;</span>BR<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>我其实只有在 <code>a</code> 完成后才需要 <code>a_res</code> 。一旦 <code>a</code> 完成然后将结果存储到 <code>a_res</code> ，我们就不再需要 <code>a</code> 了。</p>
<p>实际上，甚至我们不应该再碰 <code>a</code>  。</p>
<p>这听起来更像我们要么持有 <code>A</code> 要么持有 <code>AR</code> ，但是永远不会同时持有。</p>
<blockquote>
<p><code>SUM TYPES</code> : Rust 的枚举就是一个汇总类型。</p>
</blockquote>
<p>所以！汇总类型。Rust 枚举。这就是我们想要的。让我们创建一个叫做 <code>State</code> 的类型，然后它有两个变体：
一个用于它还是 future 对象，一个用于它是一个结果。非常简单！</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">State</span><span style="color:#f92672">&lt;</span>F, T, E<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">where</span>
</span></span><span style="display:flex;"><span>	F: <span style="color:#a6e22e">Future</span><span style="color:#f92672">&lt;</span>Output <span style="color:#f92672">=</span> Result<span style="color:#f92672">&lt;</span>T, E<span style="color:#f92672">&gt;&gt;</span>,
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	Future(F),
</span></span><span style="display:flex;"><span>	Ok(T),
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>这将会非常棒！</p>
<p>让我们赋给我们的 <code>TryJoin</code> 结构体：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">TryJoin</span><span style="color:#f92672">&lt;</span>A, B, AR, BR, E<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">where</span>
</span></span><span style="display:flex;"><span>	A: <span style="color:#a6e22e">Future</span><span style="color:#f92672">&lt;</span>Output <span style="color:#f92672">=</span> Result<span style="color:#f92672">&lt;</span>AR, E<span style="color:#f92672">&gt;&gt;</span>,
</span></span><span style="display:flex;"><span>	B: <span style="color:#a6e22e">Future</span><span style="color:#f92672">&lt;</span>Output <span style="color:#f92672">=</span> Result<span style="color:#f92672">&lt;</span>BR, E<span style="color:#f92672">&gt;&gt;</span>,
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	a: <span style="color:#a6e22e">State</span><span style="color:#f92672">&lt;</span>A, AR, E<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>	b: <span style="color:#a6e22e">State</span><span style="color:#f92672">&lt;</span>B, BR, E<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>（是不是非常漂亮）</p>
<p>然后初始化它们：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">try_join</span><span style="color:#f92672">&lt;</span>A, B, AR, BR, E<span style="color:#f92672">&gt;</span>(a: <span style="color:#a6e22e">A</span>, b: <span style="color:#a6e22e">B</span>) -&gt; <span style="color:#a6e22e">impl</span> Future<span style="color:#f92672">&lt;</span>Output <span style="color:#f92672">=</span> Result<span style="color:#f92672">&lt;</span>(AR, BR), E<span style="color:#f92672">&gt;&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">where</span>
</span></span><span style="display:flex;"><span>	A: <span style="color:#a6e22e">Future</span><span style="color:#f92672">&lt;</span>Output <span style="color:#f92672">=</span> Result<span style="color:#f92672">&lt;</span>AR, E<span style="color:#f92672">&gt;&gt;</span>,
</span></span><span style="display:flex;"><span>	B: <span style="color:#a6e22e">Future</span><span style="color:#f92672">&lt;</span>Output <span style="color:#f92672">=</span> Result<span style="color:#f92672">&lt;</span>BR, E<span style="color:#f92672">&gt;&gt;</span>,
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	TryJoin {
</span></span><span style="display:flex;"><span>		a: <span style="color:#a6e22e">State</span>::Future(a),
</span></span><span style="display:flex;"><span>		b: <span style="color:#a6e22e">State</span>::Future(b),
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>非常酷。然后我们只需要稍微调整一下我们的 <code>poll</code> 方法，我们需要将 <code>Pin&lt;&amp;mut Self&gt;</code> 转换为 <code>&amp;mut Self</code> 。。。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">poll</span>(self: <span style="color:#a6e22e">Pin</span><span style="color:#f92672">&lt;&amp;</span><span style="color:#66d9ef">mut</span> Self<span style="color:#f92672">&gt;</span>, cx: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> Context<span style="color:#f92672">&lt;&#39;</span>_<span style="color:#f92672">&gt;</span>) -&gt; <span style="color:#a6e22e">Poll</span><span style="color:#f92672">&lt;</span>Self::Output<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> this <span style="color:#f92672">=</span> <span style="color:#66d9ef">unsafe</span> { self.get_unchecked_mut() };
</span></span></code></pre></div><p>这是可以的，因为我们承诺维护不变量，也就是说我们不会转移（move） <code>State::Future</code> 内部。</p>
<p>然后如果 <code>a</code> 是 <code>State::Future</code> 我们就轮询它，然后我们再传播错误或者保存它的结果：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> State::Future(a) <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> this.a {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> a <span style="color:#f92672">=</span> <span style="color:#66d9ef">unsafe</span> { Pin::new_unchecked(a) };
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> Poll::Ready(res) <span style="color:#f92672">=</span> a.poll(cx) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">match</span> res {
</span></span><span style="display:flex;"><span>			Ok(t) <span style="color:#f92672">=&gt;</span> this.a <span style="color:#f92672">=</span> State::Ok(t),
</span></span><span style="display:flex;"><span>			Err(e) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">return</span> Err(e).into(),
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>然后同样的修改 <code>b</code> 。。。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">// you can figure that one out, I believe in you
</span></span></span></code></pre></div><p>然后我们就完成了如果它们都是 <code>State::Ok</code> ！否则我们就返回 <code>Poll::Pending</code> :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">match</span> (this.a, this.b) {
</span></span><span style="display:flex;"><span>	(State::Ok(a), State::Ok(b)) <span style="color:#f92672">=&gt;</span> Ok((a, b)).into(),
</span></span><span style="display:flex;"><span>	_ <span style="color:#f92672">=&gt;</span> Poll::Pending,
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>非常好。</p>
<p>除了它无法通过编译：</p>
<pre tabindex="0"><code class="language-nil" data-lang="nil">$ RUST_LOG=info cargo run --quiet --release
error[E0507]: cannot move out of `this.a` which is behind a mutable reference
  --&gt; src/tj.rs:65:16
   |
65 |         match (this.a, this.b) {
   |                ^^^^^^ move occurs because `this.a` has type `State&lt;A, AR, E&gt;`, which does not implement the `Copy` trait

error[E0507]: cannot move out of `this.b` which is behind a mutable reference
  --&gt; src/tj.rs:65:24
   |
65 |         match (this.a, this.b) {
   |                        ^^^^^^ move occurs because `this.b` has type `State&lt;B, BR, E&gt;`, which does not implement the `Copy` trait

error: aborting due to 2 previous errors

For more information about this error, try `rustc --explain E0507`.
error: could not compile `waytoodeep`

To learn more, run the command again with --verbose.
</code></pre><p>因为。。。我们只有 <code>&amp;mut Self</code> 而不是 <code>Self</code> 。</p>
<p>我们没有自己的所有权，仅仅是借用我们自己。</p>
<p>所以，我们不能将将我们的成员转移（move）出去，因为我们不能阻止其他人再次轮询 <code>TryJoin</code> 。
所以这种情况，我们需要崩溃（panic）。</p>
<p>当然，如果我们像 <code>Option&lt;T&gt;</code> 那样有一个 <code>.take()</code> 方法事情就会大大简化。
它返回 Option 拥有的任何内容，或者 <code>None</code> 。</p>
<p>但是我们没有 <code>None</code> 。我们只有 <code>State::Future</code> 和 <code>State::OK</code> ，没有“中立”（neutral）状态。</p>
<p>让我们创建一个：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">State</span><span style="color:#f92672">&lt;</span>F, T, E<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">where</span>
</span></span><span style="display:flex;"><span>	F: <span style="color:#a6e22e">Future</span><span style="color:#f92672">&lt;</span>Output <span style="color:#f92672">=</span> Result<span style="color:#f92672">&lt;</span>T, E<span style="color:#f92672">&gt;&gt;</span>,
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	Future(F),
</span></span><span style="display:flex;"><span>	Ok(T),
</span></span><span style="display:flex;"><span>	Gone,
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>现在，我们可以将 <code>this.a</code> 和 <code>this.b</code> 替换为 <code>State::Gone</code> 。。。或者它的返回结果（我们拥有所有权）。
然后我们就可以将它们转移（move）出去。</p>
<p>但是同时。。。我们需要再次对其进行模式匹配（pattern match）。</p>
<p>就像：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">match</span> (<span style="color:#f92672">&amp;</span>this.a, <span style="color:#f92672">&amp;</span>this.b) {
</span></span><span style="display:flex;"><span>	(State::Ok(_), State::Ok(_)) <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">let</span> a <span style="color:#f92672">=</span> <span style="color:#66d9ef">match</span> std::mem::replace(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> this.a, State::Gone) {
</span></span><span style="display:flex;"><span>			State::Ok(t) <span style="color:#f92672">=&gt;</span> t,
</span></span><span style="display:flex;"><span>			_ <span style="color:#f92672">=&gt;</span> unreachable!(),
</span></span><span style="display:flex;"><span>		};
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">let</span> b <span style="color:#f92672">=</span> <span style="color:#66d9ef">match</span> std::mem::replace(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> this.b, State::Gone) {
</span></span><span style="display:flex;"><span>			State::Ok(t) <span style="color:#f92672">=&gt;</span> t,
</span></span><span style="display:flex;"><span>			_ <span style="color:#f92672">=&gt;</span> unreachable!(),
</span></span><span style="display:flex;"><span>		};
</span></span><span style="display:flex;"><span>		Ok((a, b)).into()
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	_ <span style="color:#f92672">=&gt;</span> Poll::Pending,
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>实话说。。。我看过更糟的代码。它只是没那么<a href="https://en.wikipedia.org/wiki/Don%27t%5Frepeat%5Fyourself">DRY</a>。</p>
<p>非常好的实现！</p>
<pre tabindex="0"><code class="language-nil" data-lang="nil">$ RUST_LOG=info cargo run --quiet --release
Jul 25 23:52:24.097  INFO waytoodeep: Joining...
Jul 25 23:52:25.050  INFO waytoodeep: Got response! status=HTTP/1.1 200 OK name=second
Jul 25 23:52:25.061  INFO waytoodeep: Got response! status=HTTP/1.1 200 OK name=first
Jul 25 23:52:25.061  INFO waytoodeep: All done! res=(&#34;first&#34;, &#34;second&#34;)
</code></pre><p>看，只有 11ms 的间隔。</p>
<h3 id="更进一步">更进一步？<a href="#更进一步" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>这段代码再次困扰了我：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">TryJoin</span><span style="color:#f92672">&lt;</span>A, B, AR, BR, E<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">where</span>
</span></span><span style="display:flex;"><span>	A: <span style="color:#a6e22e">Future</span><span style="color:#f92672">&lt;</span>Output <span style="color:#f92672">=</span> Result<span style="color:#f92672">&lt;</span>AR, E<span style="color:#f92672">&gt;&gt;</span>,
</span></span><span style="display:flex;"><span>	B: <span style="color:#a6e22e">Future</span><span style="color:#f92672">&lt;</span>Output <span style="color:#f92672">=</span> Result<span style="color:#f92672">&lt;</span>BR, E<span style="color:#f92672">&gt;&gt;</span>,
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	a: <span style="color:#a6e22e">State</span><span style="color:#f92672">&lt;</span>A, AR, E<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>	b: <span style="color:#a6e22e">State</span><span style="color:#f92672">&lt;</span>B, BR, E<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>因为现在 <code>a</code> 和 <code>b</code> 是三态的（tri-state）： <code>Future</code> 、 <code>Ok</code> 或者 <code>Gone</code> 。</p>
<p>如果 <code>a</code> 和 <code>b</code> 都是 <code>Gone</code> 呢？这个状态不合理！</p>
<p>如果发生了这个状态，我们现在将会永远返回 <code>Poll::Pending</code> &ndash; 这不太好 &ndash; 一个死锁。</p>
<p>我们真正想要的是。。。两个枚举。实际上我们想要整个 <code>TryJoin</code> 类型是一个 <code>enum</code> 。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">TryJoin</span><span style="color:#f92672">&lt;</span>A, B, AR, BR, E<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">where</span>
</span></span><span style="display:flex;"><span>	A: <span style="color:#a6e22e">Future</span><span style="color:#f92672">&lt;</span>Output <span style="color:#f92672">=</span> Result<span style="color:#f92672">&lt;</span>AR, E<span style="color:#f92672">&gt;&gt;</span>,
</span></span><span style="display:flex;"><span>	B: <span style="color:#a6e22e">Future</span><span style="color:#f92672">&lt;</span>Output <span style="color:#f92672">=</span> Result<span style="color:#f92672">&lt;</span>BR, E<span style="color:#f92672">&gt;&gt;</span>,
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	Polling {
</span></span><span style="display:flex;"><span>		a: <span style="color:#a6e22e">State</span><span style="color:#f92672">&lt;</span>A, AR, E<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>		b: <span style="color:#a6e22e">State</span><span style="color:#f92672">&lt;</span>B, BR, E<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>	},
</span></span><span style="display:flex;"><span>	Done,
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>像这样初始化：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">try_join</span><span style="color:#f92672">&lt;</span>A, B, AR, BR, E<span style="color:#f92672">&gt;</span>(a: <span style="color:#a6e22e">A</span>, b: <span style="color:#a6e22e">B</span>) -&gt; <span style="color:#a6e22e">impl</span> Future<span style="color:#f92672">&lt;</span>Output <span style="color:#f92672">=</span> Result<span style="color:#f92672">&lt;</span>(AR, BR), E<span style="color:#f92672">&gt;&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">where</span>
</span></span><span style="display:flex;"><span>	A: <span style="color:#a6e22e">Future</span><span style="color:#f92672">&lt;</span>Output <span style="color:#f92672">=</span> Result<span style="color:#f92672">&lt;</span>AR, E<span style="color:#f92672">&gt;&gt;</span>,
</span></span><span style="display:flex;"><span>	B: <span style="color:#a6e22e">Future</span><span style="color:#f92672">&lt;</span>Output <span style="color:#f92672">=</span> Result<span style="color:#f92672">&lt;</span>BR, E<span style="color:#f92672">&gt;&gt;</span>,
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	TryJoin::Polling {
</span></span><span style="display:flex;"><span>		a: <span style="color:#a6e22e">State</span>::Future(a),
</span></span><span style="display:flex;"><span>		b: <span style="color:#a6e22e">State</span>::Future(b),
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>然后，surprice！ <code>Poll&lt;T&gt;</code> 实现了 <a href="https://doc.rust-lang.org/stable/std/ops/trait.Try.html">Try</a> trait。所以我们可以使用 <code>?</code> 。
所以最终我们的代码实际上非常短小：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>A, B, AR, BR, E<span style="color:#f92672">&gt;</span> Future <span style="color:#66d9ef">for</span> TryJoin<span style="color:#f92672">&lt;</span>A, B, AR, BR, E<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">where</span>
</span></span><span style="display:flex;"><span>	A: <span style="color:#a6e22e">Future</span><span style="color:#f92672">&lt;</span>Output <span style="color:#f92672">=</span> Result<span style="color:#f92672">&lt;</span>AR, E<span style="color:#f92672">&gt;&gt;</span>,
</span></span><span style="display:flex;"><span>	B: <span style="color:#a6e22e">Future</span><span style="color:#f92672">&lt;</span>Output <span style="color:#f92672">=</span> Result<span style="color:#f92672">&lt;</span>BR, E<span style="color:#f92672">&gt;&gt;</span>,
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Output</span> <span style="color:#f92672">=</span> Result<span style="color:#f92672">&lt;</span>(AR, BR), E<span style="color:#f92672">&gt;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">poll</span>(self: <span style="color:#a6e22e">Pin</span><span style="color:#f92672">&lt;&amp;</span><span style="color:#66d9ef">mut</span> Self<span style="color:#f92672">&gt;</span>, cx: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> Context<span style="color:#f92672">&lt;&#39;</span>_<span style="color:#f92672">&gt;</span>) -&gt; <span style="color:#a6e22e">Poll</span><span style="color:#f92672">&lt;</span>Self::Output<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">let</span> this <span style="color:#f92672">=</span> <span style="color:#66d9ef">unsafe</span> { self.get_unchecked_mut() };
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">let</span> (a, b) <span style="color:#f92672">=</span> <span style="color:#66d9ef">match</span> this {
</span></span><span style="display:flex;"><span>			Self::Polling { a, b } <span style="color:#f92672">=&gt;</span> (a, b),
</span></span><span style="display:flex;"><span>			Self::Done <span style="color:#f92672">=&gt;</span> panic!(<span style="color:#e6db74">&#34;TryJoin future polled after completion&#34;</span>),
</span></span><span style="display:flex;"><span>		};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> State::Future(fut) <span style="color:#f92672">=</span> a {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> Poll::Ready(res) <span style="color:#f92672">=</span> <span style="color:#66d9ef">unsafe</span> { Pin::new_unchecked(fut) }.poll(cx) {
</span></span><span style="display:flex;"><span>				<span style="color:#f92672">*</span>a <span style="color:#f92672">=</span> State::Ok(res<span style="color:#f92672">?</span>);
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> State::Future(fut) <span style="color:#f92672">=</span> b {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> Poll::Ready(res) <span style="color:#f92672">=</span> <span style="color:#66d9ef">unsafe</span> { Pin::new_unchecked(fut) }.poll(cx) {
</span></span><span style="display:flex;"><span>				<span style="color:#f92672">*</span>b <span style="color:#f92672">=</span> State::Ok(res<span style="color:#f92672">?</span>);
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">match</span> (a, b) {
</span></span><span style="display:flex;"><span>			(State::Ok(_), State::Ok(_)) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">match</span> std::mem::replace(this, Self::Done) {
</span></span><span style="display:flex;"><span>				Self::Polling {
</span></span><span style="display:flex;"><span>					a: <span style="color:#a6e22e">State</span>::Ok(a),
</span></span><span style="display:flex;"><span>					b: <span style="color:#a6e22e">State</span>::Ok(b),
</span></span><span style="display:flex;"><span>				} <span style="color:#f92672">=&gt;</span> Ok((a, b)).into(),
</span></span><span style="display:flex;"><span>				_ <span style="color:#f92672">=&gt;</span> unreachable!(),
</span></span><span style="display:flex;"><span>			},
</span></span><span style="display:flex;"><span>			_ <span style="color:#f92672">=&gt;</span> Poll::Pending,
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>现在，我知道你在想什么。 <code>Pin&lt;&amp;mut T&gt;</code> 不是恰恰用来避免像 <code>std::mem::swap</code> 和 <code>std::mem::replace</code> 吗？
这些所有的转移（move）都是围绕着内存！这是被禁止的！是的，我们承诺了不去转移（move）它。
但是在这个情况下，我们只是在完成轮询两个 future 对象后转移了 <code>self</code> / <code>this</code> 。</p>
<p>然后我们就再也没有使用过两个 future 对象，无论固定还是非固定。同时我们从来也没保证过结果自身是否将要被固定（pinned）！</p>
<p>我们只需要决定某些东西是“永远固定”还是“永不固定”，然后我们可能会编写结果正确的代码。</p>
<p>在我们的场景下，只有 <code>TryJoin::Polling(State::Future(_))</code> 就是“永远固定” 的，其他都不是。</p>
<p>当然，我们快速的从 <code>Pin&lt;&amp;mut Self&gt;</code> 切换到 <code>&amp;mut Self</code> ，然后又回到 <code>Pin&lt;&amp;mut A&gt;</code> ，
但只要我们不要在中间移动就没有问题。</p>
<p>如果我们在持有 future 对象的情况下使用 <code>std::mem:replace</code> 或 <code>std::mem::swap</code> 就会不妙。
所以，我们还好，我想，我不太确定。如果不是，有人应该会留言。</p>
<h3 id="就这样">就这样<a href="#就这样" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>让我们回顾我们的工作：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">// in `src/tj.rs`
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">use</span> std::{
</span></span><span style="display:flex;"><span>	future::Future,
</span></span><span style="display:flex;"><span>	pin::Pin,
</span></span><span style="display:flex;"><span>	task::{Context, Poll},
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">try_join</span><span style="color:#f92672">&lt;</span>A, B, AR, BR, E<span style="color:#f92672">&gt;</span>(a: <span style="color:#a6e22e">A</span>, b: <span style="color:#a6e22e">B</span>) -&gt; <span style="color:#a6e22e">impl</span> Future<span style="color:#f92672">&lt;</span>Output <span style="color:#f92672">=</span> Result<span style="color:#f92672">&lt;</span>(AR, BR), E<span style="color:#f92672">&gt;&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">where</span>
</span></span><span style="display:flex;"><span>	A: <span style="color:#a6e22e">Future</span><span style="color:#f92672">&lt;</span>Output <span style="color:#f92672">=</span> Result<span style="color:#f92672">&lt;</span>AR, E<span style="color:#f92672">&gt;&gt;</span>,
</span></span><span style="display:flex;"><span>	B: <span style="color:#a6e22e">Future</span><span style="color:#f92672">&lt;</span>Output <span style="color:#f92672">=</span> Result<span style="color:#f92672">&lt;</span>BR, E<span style="color:#f92672">&gt;&gt;</span>,
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	TryJoin::Polling {
</span></span><span style="display:flex;"><span>		a: <span style="color:#a6e22e">State</span>::Future(a),
</span></span><span style="display:flex;"><span>		b: <span style="color:#a6e22e">State</span>::Future(b),
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">State</span><span style="color:#f92672">&lt;</span>F, T, E<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">where</span>
</span></span><span style="display:flex;"><span>	F: <span style="color:#a6e22e">Future</span><span style="color:#f92672">&lt;</span>Output <span style="color:#f92672">=</span> Result<span style="color:#f92672">&lt;</span>T, E<span style="color:#f92672">&gt;&gt;</span>,
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	Future(F),
</span></span><span style="display:flex;"><span>	Ok(T),
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">TryJoin</span><span style="color:#f92672">&lt;</span>A, B, AR, BR, E<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">where</span>
</span></span><span style="display:flex;"><span>	A: <span style="color:#a6e22e">Future</span><span style="color:#f92672">&lt;</span>Output <span style="color:#f92672">=</span> Result<span style="color:#f92672">&lt;</span>AR, E<span style="color:#f92672">&gt;&gt;</span>,
</span></span><span style="display:flex;"><span>	B: <span style="color:#a6e22e">Future</span><span style="color:#f92672">&lt;</span>Output <span style="color:#f92672">=</span> Result<span style="color:#f92672">&lt;</span>BR, E<span style="color:#f92672">&gt;&gt;</span>,
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	Polling {
</span></span><span style="display:flex;"><span>		a: <span style="color:#a6e22e">State</span><span style="color:#f92672">&lt;</span>A, AR, E<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>		b: <span style="color:#a6e22e">State</span><span style="color:#f92672">&lt;</span>B, BR, E<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>	},
</span></span><span style="display:flex;"><span>	Done,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>A, B, AR, BR, E<span style="color:#f92672">&gt;</span> Future <span style="color:#66d9ef">for</span> TryJoin<span style="color:#f92672">&lt;</span>A, B, AR, BR, E<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">where</span>
</span></span><span style="display:flex;"><span>	A: <span style="color:#a6e22e">Future</span><span style="color:#f92672">&lt;</span>Output <span style="color:#f92672">=</span> Result<span style="color:#f92672">&lt;</span>AR, E<span style="color:#f92672">&gt;&gt;</span>,
</span></span><span style="display:flex;"><span>	B: <span style="color:#a6e22e">Future</span><span style="color:#f92672">&lt;</span>Output <span style="color:#f92672">=</span> Result<span style="color:#f92672">&lt;</span>BR, E<span style="color:#f92672">&gt;&gt;</span>,
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Output</span> <span style="color:#f92672">=</span> Result<span style="color:#f92672">&lt;</span>(AR, BR), E<span style="color:#f92672">&gt;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">poll</span>(self: <span style="color:#a6e22e">Pin</span><span style="color:#f92672">&lt;&amp;</span><span style="color:#66d9ef">mut</span> Self<span style="color:#f92672">&gt;</span>, cx: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> Context<span style="color:#f92672">&lt;&#39;</span>_<span style="color:#f92672">&gt;</span>) -&gt; <span style="color:#a6e22e">Poll</span><span style="color:#f92672">&lt;</span>Self::Output<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">let</span> this <span style="color:#f92672">=</span> <span style="color:#66d9ef">unsafe</span> { self.get_unchecked_mut() };
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">let</span> (a, b) <span style="color:#f92672">=</span> <span style="color:#66d9ef">match</span> this {
</span></span><span style="display:flex;"><span>			Self::Polling { a, b } <span style="color:#f92672">=&gt;</span> (a, b),
</span></span><span style="display:flex;"><span>			Self::Done <span style="color:#f92672">=&gt;</span> panic!(<span style="color:#e6db74">&#34;TryJoin future polled after completion&#34;</span>),
</span></span><span style="display:flex;"><span>		};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> State::Future(fut) <span style="color:#f92672">=</span> a {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> Poll::Ready(res) <span style="color:#f92672">=</span> <span style="color:#66d9ef">unsafe</span> { Pin::new_unchecked(fut) }.poll(cx) {
</span></span><span style="display:flex;"><span>				<span style="color:#f92672">*</span>a <span style="color:#f92672">=</span> State::Ok(res<span style="color:#f92672">?</span>);
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> State::Future(fut) <span style="color:#f92672">=</span> b {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> Poll::Ready(res) <span style="color:#f92672">=</span> <span style="color:#66d9ef">unsafe</span> { Pin::new_unchecked(fut) }.poll(cx) {
</span></span><span style="display:flex;"><span>				<span style="color:#f92672">*</span>b <span style="color:#f92672">=</span> State::Ok(res<span style="color:#f92672">?</span>);
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">match</span> (a, b) {
</span></span><span style="display:flex;"><span>			(State::Ok(_), State::Ok(_)) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">match</span> std::mem::replace(this, Self::Done) {
</span></span><span style="display:flex;"><span>				Self::Polling {
</span></span><span style="display:flex;"><span>					a: <span style="color:#a6e22e">State</span>::Ok(a),
</span></span><span style="display:flex;"><span>					b: <span style="color:#a6e22e">State</span>::Ok(b),
</span></span><span style="display:flex;"><span>				} <span style="color:#f92672">=&gt;</span> Ok((a, b)).into(),
</span></span><span style="display:flex;"><span>				_ <span style="color:#f92672">=&gt;</span> unreachable!(),
</span></span><span style="display:flex;"><span>			},
</span></span><span style="display:flex;"><span>			_ <span style="color:#f92672">=&gt;</span> Poll::Pending,
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>还有我们小小的 HTTPS 客户端：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">// in `src/main.rs`
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">use</span> color_eyre::Report;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">use</span> std::{net::SocketAddr, sync::Arc};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">use</span> tokio::{
</span></span><span style="display:flex;"><span>	io::{AsyncReadExt, AsyncWriteExt},
</span></span><span style="display:flex;"><span>	net::TcpStream,
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">use</span> tokio_rustls::{rustls::ClientConfig, TlsConnector};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">use</span> tracing::info;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">use</span> tracing_subscriber::EnvFilter;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">use</span> webpki::DNSNameRef;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">mod</span> tj;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#[tokio::main(flavor = </span><span style="color:#e6db74">&#34;current_thread&#34;</span><span style="color:#75715e">)]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() -&gt; Result<span style="color:#f92672">&lt;</span>(), Report<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>	setup()<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	info<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;Joining...&#34;</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> res <span style="color:#f92672">=</span> tj::try_join(fetch_thing(<span style="color:#e6db74">&#34;first&#34;</span>), fetch_thing(<span style="color:#e6db74">&#34;second&#34;</span>)).<span style="color:#66d9ef">await</span><span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>	info<span style="color:#f92672">!</span>(<span style="color:#f92672">?</span>res, <span style="color:#e6db74">&#34;All done!&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	Ok(())
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#[allow(dead_code)]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">fetch_thing</span>(name: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>) -&gt; Result<span style="color:#f92672">&lt;&amp;</span><span style="color:#66d9ef">str</span>, Report<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// look out it&#39;s port 443 now
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">let</span> addr: <span style="color:#a6e22e">SocketAddr</span> <span style="color:#f92672">=</span> ([<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>], <span style="color:#ae81ff">443</span>).into();
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> socket <span style="color:#f92672">=</span> TcpStream::connect(addr).<span style="color:#66d9ef">await</span><span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// establish a TLS session...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">let</span> connector: <span style="color:#a6e22e">TlsConnector</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> config <span style="color:#f92672">=</span> ClientConfig::new();
</span></span><span style="display:flex;"><span>		config
</span></span><span style="display:flex;"><span>			.root_store
</span></span><span style="display:flex;"><span>			.add_server_trust_anchors(<span style="color:#f92672">&amp;</span>webpki_roots::TLS_SERVER_ROOTS);
</span></span><span style="display:flex;"><span>		Arc::new(config).into()
</span></span><span style="display:flex;"><span>	};
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> dnsname <span style="color:#f92672">=</span> DNSNameRef::try_from_ascii_str(<span style="color:#e6db74">&#34;one.one.one.one&#34;</span>)<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> socket <span style="color:#f92672">=</span> connector.connect(dnsname, socket).<span style="color:#66d9ef">await</span><span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// we&#39;re writing straight to the socket, there&#39;s no buffering
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// so no need to flush
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	socket.write_all(<span style="color:#e6db74">b&#34;GET / HTTP/1.1</span><span style="color:#ae81ff">\r\n</span><span style="color:#e6db74">&#34;</span>).<span style="color:#66d9ef">await</span><span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>	socket.write_all(<span style="color:#e6db74">b&#34;Host: one.one.one.one</span><span style="color:#ae81ff">\r\n</span><span style="color:#e6db74">&#34;</span>).<span style="color:#66d9ef">await</span><span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>	socket.write_all(<span style="color:#e6db74">b&#34;User-Agent: cool-bear</span><span style="color:#ae81ff">\r\n</span><span style="color:#e6db74">&#34;</span>).<span style="color:#66d9ef">await</span><span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>	socket.write_all(<span style="color:#e6db74">b&#34;Connection: close</span><span style="color:#ae81ff">\r\n</span><span style="color:#e6db74">&#34;</span>).<span style="color:#66d9ef">await</span><span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>	socket.write_all(<span style="color:#e6db74">b&#34;</span><span style="color:#ae81ff">\r\n</span><span style="color:#e6db74">&#34;</span>).<span style="color:#66d9ef">await</span><span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> response <span style="color:#f92672">=</span> String::with_capacity(<span style="color:#ae81ff">256</span>);
</span></span><span style="display:flex;"><span>	socket.read_to_string(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> response).<span style="color:#66d9ef">await</span><span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> status <span style="color:#f92672">=</span> response.lines().next().unwrap_or_default();
</span></span><span style="display:flex;"><span>	info<span style="color:#f92672">!</span>(<span style="color:#f92672">%</span>status, , <span style="color:#e6db74">&#34;Got response!&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// dropping the socket will close the connection
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	Ok(name)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">setup</span>() -&gt; Result<span style="color:#f92672">&lt;</span>(), Report<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> std::env::var(<span style="color:#e6db74">&#34;RUST_LIB_BACKTRACE&#34;</span>).is_err() {
</span></span><span style="display:flex;"><span>		std::env::set_var(<span style="color:#e6db74">&#34;RUST_LIB_BACKTRACE&#34;</span>, <span style="color:#e6db74">&#34;1&#34;</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	color_eyre::install()<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> std::env::var(<span style="color:#e6db74">&#34;RUST_LOG&#34;</span>).is_err() {
</span></span><span style="display:flex;"><span>		std::env::set_var(<span style="color:#e6db74">&#34;RUST_LOG&#34;</span>, <span style="color:#e6db74">&#34;info&#34;</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	tracing_subscriber::fmt::fmt()
</span></span><span style="display:flex;"><span>		.with_env_filter(EnvFilter::from_default_env())
</span></span><span style="display:flex;"><span>		.init();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	Ok(())
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>And it works.</p>
<pre tabindex="0"><code class="language-nil" data-lang="nil">$ RUST_LOG=info cargo run --quiet --release
Jul 26 00:08:13.399  INFO waytoodeep: Joining...
Jul 26 00:08:13.707  INFO waytoodeep: Got response! status=HTTP/1.1 200 OK name=first
Jul 26 00:08:13.709  INFO waytoodeep: Got response! status=HTTP/1.1 200 OK name=second
Jul 26 00:08:13.710  INFO waytoodeep: All done! res=(&#34;first&#34;, &#34;second&#34;)
</code></pre><p>2ms 间隔！这是一个新的记录。</p>

      </div></div>

  

  


   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   


<hr>

  <div class="bl-section">
    <h4>No notes link to this note</h4>
  </div>


</div>

  </div>

  
    <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright">
        <span>© 2022 Powered by <a href="http://gohugo.io">Hugo</a></span>
    
        <span>:: Theme made by <a href="https://twitter.com/panr">panr</a></span>
      </div>
  </div>
</footer>

<script src="https://www.linuxzen.com/notes/assets/main.js"></script>
<script src="https://www.linuxzen.com/notes/assets/prism.js"></script>




<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.css" integrity="sha384-RZU/ijkSsFbcmivfdRBQDtwuwVqK7GMOw6IMvKyeWL2K5UAlyp6WonmB8m7Jd0Hn" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.js" integrity="sha384-pK1WpvzWVBQiP0/GjnvRxV4mOb0oxFuyRxJlk6vVw146n3egcN5C925NCP7a7BY8" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/contrib/auto-render.min.js" integrity="sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl" crossorigin="anonymous"
    onload="renderMathInElement(document.body);"></script>


  
</div>

</body>
</html>
